
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Business
 * 
 */
export type Business = $Result.DefaultSelection<Prisma.$BusinessPayload>
/**
 * Model Messages
 * 
 */
export type Messages = $Result.DefaultSelection<Prisma.$MessagesPayload>
/**
 * Model Affiliates
 * 
 */
export type Affiliates = $Result.DefaultSelection<Prisma.$AffiliatesPayload>
/**
 * Model Affiliate_Business
 * 
 */
export type Affiliate_Business = $Result.DefaultSelection<Prisma.$Affiliate_BusinessPayload>
/**
 * Model Orders
 * 
 */
export type Orders = $Result.DefaultSelection<Prisma.$OrdersPayload>
/**
 * Model Products
 * 
 */
export type Products = $Result.DefaultSelection<Prisma.$ProductsPayload>
/**
 * Model Pipelines
 * 
 */
export type Pipelines = $Result.DefaultSelection<Prisma.$PipelinesPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model Waitlist
 * 
 */
export type Waitlist = $Result.DefaultSelection<Prisma.$WaitlistPayload>
/**
 * Model Pending_Payments
 * 
 */
export type Pending_Payments = $Result.DefaultSelection<Prisma.$Pending_PaymentsPayload>
/**
 * Model Affiliate_Pending_Payments
 * 
 */
export type Affiliate_Pending_Payments = $Result.DefaultSelection<Prisma.$Affiliate_Pending_PaymentsPayload>
/**
 * Model embeddings
 * 
 */
export type embeddings = $Result.DefaultSelection<Prisma.$embeddingsPayload>
/**
 * Model ig_chat_history
 * 
 */
export type ig_chat_history = $Result.DefaultSelection<Prisma.$ig_chat_historyPayload>
/**
 * Model resources
 * 
 */
export type resources = $Result.DefaultSelection<Prisma.$resourcesPayload>
/**
 * Model ig_access_token
 * 
 */
export type ig_access_token = $Result.DefaultSelection<Prisma.$ig_access_tokenPayload>
/**
 * Model ig_scope_identifiers
 * 
 */
export type ig_scope_identifiers = $Result.DefaultSelection<Prisma.$ig_scope_identifiersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PricePlan: {
  Trial: 'Trial',
  Starter: 'Starter',
  Growth: 'Growth',
  Enterprise: 'Enterprise'
};

export type PricePlan = (typeof PricePlan)[keyof typeof PricePlan]


export const RunMode: {
  Manual: 'Manual',
  Auto: 'Auto'
};

export type RunMode = (typeof RunMode)[keyof typeof RunMode]


export const PaymentPreference: {
  FullCrypto: 'FullCrypto',
  HalfCryptoHalfFiat: 'HalfCryptoHalfFiat',
  FullFiat: 'FullFiat'
};

export type PaymentPreference = (typeof PaymentPreference)[keyof typeof PaymentPreference]


export const PriceType: {
  Subscription: 'Subscription',
  OneTime: 'OneTime'
};

export type PriceType = (typeof PriceType)[keyof typeof PriceType]

}

export type PricePlan = $Enums.PricePlan

export const PricePlan: typeof $Enums.PricePlan

export type RunMode = $Enums.RunMode

export const RunMode: typeof $Enums.RunMode

export type PaymentPreference = $Enums.PaymentPreference

export const PaymentPreference: typeof $Enums.PaymentPreference

export type PriceType = $Enums.PriceType

export const PriceType: typeof $Enums.PriceType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Businesses
 * const businesses = await prisma.business.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Businesses
   * const businesses = await prisma.business.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.business`: Exposes CRUD operations for the **Business** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Businesses
    * const businesses = await prisma.business.findMany()
    * ```
    */
  get business(): Prisma.BusinessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messages`: Exposes CRUD operations for the **Messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.messages.findMany()
    * ```
    */
  get messages(): Prisma.MessagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.affiliates`: Exposes CRUD operations for the **Affiliates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Affiliates
    * const affiliates = await prisma.affiliates.findMany()
    * ```
    */
  get affiliates(): Prisma.AffiliatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.affiliate_Business`: Exposes CRUD operations for the **Affiliate_Business** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Affiliate_Businesses
    * const affiliate_Businesses = await prisma.affiliate_Business.findMany()
    * ```
    */
  get affiliate_Business(): Prisma.Affiliate_BusinessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **Orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.OrdersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **Products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.ProductsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pipelines`: Exposes CRUD operations for the **Pipelines** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pipelines
    * const pipelines = await prisma.pipelines.findMany()
    * ```
    */
  get pipelines(): Prisma.PipelinesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.waitlist`: Exposes CRUD operations for the **Waitlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Waitlists
    * const waitlists = await prisma.waitlist.findMany()
    * ```
    */
  get waitlist(): Prisma.WaitlistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pending_Payments`: Exposes CRUD operations for the **Pending_Payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pending_Payments
    * const pending_Payments = await prisma.pending_Payments.findMany()
    * ```
    */
  get pending_Payments(): Prisma.Pending_PaymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.affiliate_Pending_Payments`: Exposes CRUD operations for the **Affiliate_Pending_Payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Affiliate_Pending_Payments
    * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.findMany()
    * ```
    */
  get affiliate_Pending_Payments(): Prisma.Affiliate_Pending_PaymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.embeddings`: Exposes CRUD operations for the **embeddings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Embeddings
    * const embeddings = await prisma.embeddings.findMany()
    * ```
    */
  get embeddings(): Prisma.embeddingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ig_chat_history`: Exposes CRUD operations for the **ig_chat_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ig_chat_histories
    * const ig_chat_histories = await prisma.ig_chat_history.findMany()
    * ```
    */
  get ig_chat_history(): Prisma.ig_chat_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resources`: Exposes CRUD operations for the **resources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resources.findMany()
    * ```
    */
  get resources(): Prisma.resourcesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ig_access_token`: Exposes CRUD operations for the **ig_access_token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ig_access_tokens
    * const ig_access_tokens = await prisma.ig_access_token.findMany()
    * ```
    */
  get ig_access_token(): Prisma.ig_access_tokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ig_scope_identifiers`: Exposes CRUD operations for the **ig_scope_identifiers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ig_scope_identifiers
    * const ig_scope_identifiers = await prisma.ig_scope_identifiers.findMany()
    * ```
    */
  get ig_scope_identifiers(): Prisma.ig_scope_identifiersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.0
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Business: 'Business',
    Messages: 'Messages',
    Affiliates: 'Affiliates',
    Affiliate_Business: 'Affiliate_Business',
    Orders: 'Orders',
    Products: 'Products',
    Pipelines: 'Pipelines',
    ChatMessage: 'ChatMessage',
    Waitlist: 'Waitlist',
    Pending_Payments: 'Pending_Payments',
    Affiliate_Pending_Payments: 'Affiliate_Pending_Payments',
    embeddings: 'embeddings',
    ig_chat_history: 'ig_chat_history',
    resources: 'resources',
    ig_access_token: 'ig_access_token',
    ig_scope_identifiers: 'ig_scope_identifiers'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "business" | "messages" | "affiliates" | "affiliate_Business" | "orders" | "products" | "pipelines" | "chatMessage" | "waitlist" | "pending_Payments" | "affiliate_Pending_Payments" | "embeddings" | "ig_chat_history" | "resources" | "ig_access_token" | "ig_scope_identifiers"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Business: {
        payload: Prisma.$BusinessPayload<ExtArgs>
        fields: Prisma.BusinessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findFirst: {
            args: Prisma.BusinessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findMany: {
            args: Prisma.BusinessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          create: {
            args: Prisma.BusinessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          createMany: {
            args: Prisma.BusinessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          delete: {
            args: Prisma.BusinessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          update: {
            args: Prisma.BusinessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          deleteMany: {
            args: Prisma.BusinessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          upsert: {
            args: Prisma.BusinessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          aggregate: {
            args: Prisma.BusinessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusiness>
          }
          groupBy: {
            args: Prisma.BusinessGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessCountAggregateOutputType> | number
          }
        }
      }
      Messages: {
        payload: Prisma.$MessagesPayload<ExtArgs>
        fields: Prisma.MessagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          findFirst: {
            args: Prisma.MessagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          findMany: {
            args: Prisma.MessagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>[]
          }
          create: {
            args: Prisma.MessagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          createMany: {
            args: Prisma.MessagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>[]
          }
          delete: {
            args: Prisma.MessagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          update: {
            args: Prisma.MessagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          deleteMany: {
            args: Prisma.MessagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>[]
          }
          upsert: {
            args: Prisma.MessagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          aggregate: {
            args: Prisma.MessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessages>
          }
          groupBy: {
            args: Prisma.MessagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessagesCountArgs<ExtArgs>
            result: $Utils.Optional<MessagesCountAggregateOutputType> | number
          }
        }
      }
      Affiliates: {
        payload: Prisma.$AffiliatesPayload<ExtArgs>
        fields: Prisma.AffiliatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>
          }
          findFirst: {
            args: Prisma.AffiliatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>
          }
          findMany: {
            args: Prisma.AffiliatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>[]
          }
          create: {
            args: Prisma.AffiliatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>
          }
          createMany: {
            args: Prisma.AffiliatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>[]
          }
          delete: {
            args: Prisma.AffiliatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>
          }
          update: {
            args: Prisma.AffiliatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>
          }
          deleteMany: {
            args: Prisma.AffiliatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AffiliatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>[]
          }
          upsert: {
            args: Prisma.AffiliatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>
          }
          aggregate: {
            args: Prisma.AffiliatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliates>
          }
          groupBy: {
            args: Prisma.AffiliatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliatesCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliatesCountAggregateOutputType> | number
          }
        }
      }
      Affiliate_Business: {
        payload: Prisma.$Affiliate_BusinessPayload<ExtArgs>
        fields: Prisma.Affiliate_BusinessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Affiliate_BusinessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_BusinessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Affiliate_BusinessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_BusinessPayload>
          }
          findFirst: {
            args: Prisma.Affiliate_BusinessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_BusinessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Affiliate_BusinessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_BusinessPayload>
          }
          findMany: {
            args: Prisma.Affiliate_BusinessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_BusinessPayload>[]
          }
          create: {
            args: Prisma.Affiliate_BusinessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_BusinessPayload>
          }
          createMany: {
            args: Prisma.Affiliate_BusinessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Affiliate_BusinessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_BusinessPayload>[]
          }
          delete: {
            args: Prisma.Affiliate_BusinessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_BusinessPayload>
          }
          update: {
            args: Prisma.Affiliate_BusinessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_BusinessPayload>
          }
          deleteMany: {
            args: Prisma.Affiliate_BusinessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Affiliate_BusinessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Affiliate_BusinessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_BusinessPayload>[]
          }
          upsert: {
            args: Prisma.Affiliate_BusinessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_BusinessPayload>
          }
          aggregate: {
            args: Prisma.Affiliate_BusinessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliate_Business>
          }
          groupBy: {
            args: Prisma.Affiliate_BusinessGroupByArgs<ExtArgs>
            result: $Utils.Optional<Affiliate_BusinessGroupByOutputType>[]
          }
          count: {
            args: Prisma.Affiliate_BusinessCountArgs<ExtArgs>
            result: $Utils.Optional<Affiliate_BusinessCountAggregateOutputType> | number
          }
        }
      }
      Orders: {
        payload: Prisma.$OrdersPayload<ExtArgs>
        fields: Prisma.OrdersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          findFirst: {
            args: Prisma.OrdersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          findMany: {
            args: Prisma.OrdersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>[]
          }
          create: {
            args: Prisma.OrdersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          createMany: {
            args: Prisma.OrdersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrdersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>[]
          }
          delete: {
            args: Prisma.OrdersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          update: {
            args: Prisma.OrdersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          deleteMany: {
            args: Prisma.OrdersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrdersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrdersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>[]
          }
          upsert: {
            args: Prisma.OrdersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          aggregate: {
            args: Prisma.OrdersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrders>
          }
          groupBy: {
            args: Prisma.OrdersGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdersGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdersCountArgs<ExtArgs>
            result: $Utils.Optional<OrdersCountAggregateOutputType> | number
          }
        }
      }
      Products: {
        payload: Prisma.$ProductsPayload<ExtArgs>
        fields: Prisma.ProductsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          findFirst: {
            args: Prisma.ProductsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          findMany: {
            args: Prisma.ProductsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          create: {
            args: Prisma.ProductsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          createMany: {
            args: Prisma.ProductsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          delete: {
            args: Prisma.ProductsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          update: {
            args: Prisma.ProductsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          deleteMany: {
            args: Prisma.ProductsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          upsert: {
            args: Prisma.ProductsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.ProductsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      Pipelines: {
        payload: Prisma.$PipelinesPayload<ExtArgs>
        fields: Prisma.PipelinesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PipelinesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PipelinesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>
          }
          findFirst: {
            args: Prisma.PipelinesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PipelinesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>
          }
          findMany: {
            args: Prisma.PipelinesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>[]
          }
          create: {
            args: Prisma.PipelinesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>
          }
          createMany: {
            args: Prisma.PipelinesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PipelinesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>[]
          }
          delete: {
            args: Prisma.PipelinesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>
          }
          update: {
            args: Prisma.PipelinesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>
          }
          deleteMany: {
            args: Prisma.PipelinesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PipelinesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PipelinesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>[]
          }
          upsert: {
            args: Prisma.PipelinesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>
          }
          aggregate: {
            args: Prisma.PipelinesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePipelines>
          }
          groupBy: {
            args: Prisma.PipelinesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PipelinesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PipelinesCountArgs<ExtArgs>
            result: $Utils.Optional<PipelinesCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      Waitlist: {
        payload: Prisma.$WaitlistPayload<ExtArgs>
        fields: Prisma.WaitlistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WaitlistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WaitlistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>
          }
          findFirst: {
            args: Prisma.WaitlistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WaitlistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>
          }
          findMany: {
            args: Prisma.WaitlistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>[]
          }
          create: {
            args: Prisma.WaitlistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>
          }
          createMany: {
            args: Prisma.WaitlistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WaitlistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>[]
          }
          delete: {
            args: Prisma.WaitlistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>
          }
          update: {
            args: Prisma.WaitlistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>
          }
          deleteMany: {
            args: Prisma.WaitlistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WaitlistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WaitlistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>[]
          }
          upsert: {
            args: Prisma.WaitlistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>
          }
          aggregate: {
            args: Prisma.WaitlistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWaitlist>
          }
          groupBy: {
            args: Prisma.WaitlistGroupByArgs<ExtArgs>
            result: $Utils.Optional<WaitlistGroupByOutputType>[]
          }
          count: {
            args: Prisma.WaitlistCountArgs<ExtArgs>
            result: $Utils.Optional<WaitlistCountAggregateOutputType> | number
          }
        }
      }
      Pending_Payments: {
        payload: Prisma.$Pending_PaymentsPayload<ExtArgs>
        fields: Prisma.Pending_PaymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Pending_PaymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Pending_PaymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Pending_PaymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Pending_PaymentsPayload>
          }
          findFirst: {
            args: Prisma.Pending_PaymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Pending_PaymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Pending_PaymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Pending_PaymentsPayload>
          }
          findMany: {
            args: Prisma.Pending_PaymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Pending_PaymentsPayload>[]
          }
          create: {
            args: Prisma.Pending_PaymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Pending_PaymentsPayload>
          }
          createMany: {
            args: Prisma.Pending_PaymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Pending_PaymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Pending_PaymentsPayload>[]
          }
          delete: {
            args: Prisma.Pending_PaymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Pending_PaymentsPayload>
          }
          update: {
            args: Prisma.Pending_PaymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Pending_PaymentsPayload>
          }
          deleteMany: {
            args: Prisma.Pending_PaymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Pending_PaymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Pending_PaymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Pending_PaymentsPayload>[]
          }
          upsert: {
            args: Prisma.Pending_PaymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Pending_PaymentsPayload>
          }
          aggregate: {
            args: Prisma.Pending_PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePending_Payments>
          }
          groupBy: {
            args: Prisma.Pending_PaymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pending_PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Pending_PaymentsCountArgs<ExtArgs>
            result: $Utils.Optional<Pending_PaymentsCountAggregateOutputType> | number
          }
        }
      }
      Affiliate_Pending_Payments: {
        payload: Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>
        fields: Prisma.Affiliate_Pending_PaymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Affiliate_Pending_PaymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_Pending_PaymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Affiliate_Pending_PaymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_Pending_PaymentsPayload>
          }
          findFirst: {
            args: Prisma.Affiliate_Pending_PaymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_Pending_PaymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Affiliate_Pending_PaymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_Pending_PaymentsPayload>
          }
          findMany: {
            args: Prisma.Affiliate_Pending_PaymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_Pending_PaymentsPayload>[]
          }
          create: {
            args: Prisma.Affiliate_Pending_PaymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_Pending_PaymentsPayload>
          }
          createMany: {
            args: Prisma.Affiliate_Pending_PaymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Affiliate_Pending_PaymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_Pending_PaymentsPayload>[]
          }
          delete: {
            args: Prisma.Affiliate_Pending_PaymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_Pending_PaymentsPayload>
          }
          update: {
            args: Prisma.Affiliate_Pending_PaymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_Pending_PaymentsPayload>
          }
          deleteMany: {
            args: Prisma.Affiliate_Pending_PaymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Affiliate_Pending_PaymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Affiliate_Pending_PaymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_Pending_PaymentsPayload>[]
          }
          upsert: {
            args: Prisma.Affiliate_Pending_PaymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Affiliate_Pending_PaymentsPayload>
          }
          aggregate: {
            args: Prisma.Affiliate_Pending_PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliate_Pending_Payments>
          }
          groupBy: {
            args: Prisma.Affiliate_Pending_PaymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Affiliate_Pending_PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Affiliate_Pending_PaymentsCountArgs<ExtArgs>
            result: $Utils.Optional<Affiliate_Pending_PaymentsCountAggregateOutputType> | number
          }
        }
      }
      embeddings: {
        payload: Prisma.$embeddingsPayload<ExtArgs>
        fields: Prisma.embeddingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.embeddingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$embeddingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.embeddingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$embeddingsPayload>
          }
          findFirst: {
            args: Prisma.embeddingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$embeddingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.embeddingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$embeddingsPayload>
          }
          findMany: {
            args: Prisma.embeddingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$embeddingsPayload>[]
          }
          create: {
            args: Prisma.embeddingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$embeddingsPayload>
          }
          createMany: {
            args: Prisma.embeddingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.embeddingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$embeddingsPayload>[]
          }
          delete: {
            args: Prisma.embeddingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$embeddingsPayload>
          }
          update: {
            args: Prisma.embeddingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$embeddingsPayload>
          }
          deleteMany: {
            args: Prisma.embeddingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.embeddingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.embeddingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$embeddingsPayload>[]
          }
          upsert: {
            args: Prisma.embeddingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$embeddingsPayload>
          }
          aggregate: {
            args: Prisma.EmbeddingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmbeddings>
          }
          groupBy: {
            args: Prisma.embeddingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmbeddingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.embeddingsCountArgs<ExtArgs>
            result: $Utils.Optional<EmbeddingsCountAggregateOutputType> | number
          }
        }
      }
      ig_chat_history: {
        payload: Prisma.$ig_chat_historyPayload<ExtArgs>
        fields: Prisma.ig_chat_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ig_chat_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_chat_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ig_chat_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_chat_historyPayload>
          }
          findFirst: {
            args: Prisma.ig_chat_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_chat_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ig_chat_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_chat_historyPayload>
          }
          findMany: {
            args: Prisma.ig_chat_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_chat_historyPayload>[]
          }
          create: {
            args: Prisma.ig_chat_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_chat_historyPayload>
          }
          createMany: {
            args: Prisma.ig_chat_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ig_chat_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_chat_historyPayload>[]
          }
          delete: {
            args: Prisma.ig_chat_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_chat_historyPayload>
          }
          update: {
            args: Prisma.ig_chat_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_chat_historyPayload>
          }
          deleteMany: {
            args: Prisma.ig_chat_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ig_chat_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ig_chat_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_chat_historyPayload>[]
          }
          upsert: {
            args: Prisma.ig_chat_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_chat_historyPayload>
          }
          aggregate: {
            args: Prisma.Ig_chat_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIg_chat_history>
          }
          groupBy: {
            args: Prisma.ig_chat_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ig_chat_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ig_chat_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Ig_chat_historyCountAggregateOutputType> | number
          }
        }
      }
      resources: {
        payload: Prisma.$resourcesPayload<ExtArgs>
        fields: Prisma.resourcesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.resourcesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.resourcesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>
          }
          findFirst: {
            args: Prisma.resourcesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.resourcesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>
          }
          findMany: {
            args: Prisma.resourcesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>[]
          }
          create: {
            args: Prisma.resourcesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>
          }
          createMany: {
            args: Prisma.resourcesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.resourcesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>[]
          }
          delete: {
            args: Prisma.resourcesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>
          }
          update: {
            args: Prisma.resourcesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>
          }
          deleteMany: {
            args: Prisma.resourcesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.resourcesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.resourcesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>[]
          }
          upsert: {
            args: Prisma.resourcesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>
          }
          aggregate: {
            args: Prisma.ResourcesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResources>
          }
          groupBy: {
            args: Prisma.resourcesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourcesGroupByOutputType>[]
          }
          count: {
            args: Prisma.resourcesCountArgs<ExtArgs>
            result: $Utils.Optional<ResourcesCountAggregateOutputType> | number
          }
        }
      }
      ig_access_token: {
        payload: Prisma.$ig_access_tokenPayload<ExtArgs>
        fields: Prisma.ig_access_tokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ig_access_tokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_access_tokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ig_access_tokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_access_tokenPayload>
          }
          findFirst: {
            args: Prisma.ig_access_tokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_access_tokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ig_access_tokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_access_tokenPayload>
          }
          findMany: {
            args: Prisma.ig_access_tokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_access_tokenPayload>[]
          }
          create: {
            args: Prisma.ig_access_tokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_access_tokenPayload>
          }
          createMany: {
            args: Prisma.ig_access_tokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ig_access_tokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_access_tokenPayload>[]
          }
          delete: {
            args: Prisma.ig_access_tokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_access_tokenPayload>
          }
          update: {
            args: Prisma.ig_access_tokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_access_tokenPayload>
          }
          deleteMany: {
            args: Prisma.ig_access_tokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ig_access_tokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ig_access_tokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_access_tokenPayload>[]
          }
          upsert: {
            args: Prisma.ig_access_tokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_access_tokenPayload>
          }
          aggregate: {
            args: Prisma.Ig_access_tokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIg_access_token>
          }
          groupBy: {
            args: Prisma.ig_access_tokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ig_access_tokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.ig_access_tokenCountArgs<ExtArgs>
            result: $Utils.Optional<Ig_access_tokenCountAggregateOutputType> | number
          }
        }
      }
      ig_scope_identifiers: {
        payload: Prisma.$ig_scope_identifiersPayload<ExtArgs>
        fields: Prisma.ig_scope_identifiersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ig_scope_identifiersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_scope_identifiersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ig_scope_identifiersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_scope_identifiersPayload>
          }
          findFirst: {
            args: Prisma.ig_scope_identifiersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_scope_identifiersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ig_scope_identifiersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_scope_identifiersPayload>
          }
          findMany: {
            args: Prisma.ig_scope_identifiersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_scope_identifiersPayload>[]
          }
          create: {
            args: Prisma.ig_scope_identifiersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_scope_identifiersPayload>
          }
          createMany: {
            args: Prisma.ig_scope_identifiersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ig_scope_identifiersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_scope_identifiersPayload>[]
          }
          delete: {
            args: Prisma.ig_scope_identifiersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_scope_identifiersPayload>
          }
          update: {
            args: Prisma.ig_scope_identifiersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_scope_identifiersPayload>
          }
          deleteMany: {
            args: Prisma.ig_scope_identifiersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ig_scope_identifiersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ig_scope_identifiersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_scope_identifiersPayload>[]
          }
          upsert: {
            args: Prisma.ig_scope_identifiersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ig_scope_identifiersPayload>
          }
          aggregate: {
            args: Prisma.Ig_scope_identifiersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIg_scope_identifiers>
          }
          groupBy: {
            args: Prisma.ig_scope_identifiersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ig_scope_identifiersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ig_scope_identifiersCountArgs<ExtArgs>
            result: $Utils.Optional<Ig_scope_identifiersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    business?: BusinessOmit
    messages?: MessagesOmit
    affiliates?: AffiliatesOmit
    affiliate_Business?: Affiliate_BusinessOmit
    orders?: OrdersOmit
    products?: ProductsOmit
    pipelines?: PipelinesOmit
    chatMessage?: ChatMessageOmit
    waitlist?: WaitlistOmit
    pending_Payments?: Pending_PaymentsOmit
    affiliate_Pending_Payments?: Affiliate_Pending_PaymentsOmit
    embeddings?: embeddingsOmit
    ig_chat_history?: ig_chat_historyOmit
    resources?: resourcesOmit
    ig_access_token?: ig_access_tokenOmit
    ig_scope_identifiers?: ig_scope_identifiersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BusinessCountOutputType
   */

  export type BusinessCountOutputType = {
    affiliate_business: number
    messages: number
    orders: number
    pipelines: number
    products: number
    pending_payments: number
  }

  export type BusinessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_business?: boolean | BusinessCountOutputTypeCountAffiliate_businessArgs
    messages?: boolean | BusinessCountOutputTypeCountMessagesArgs
    orders?: boolean | BusinessCountOutputTypeCountOrdersArgs
    pipelines?: boolean | BusinessCountOutputTypeCountPipelinesArgs
    products?: boolean | BusinessCountOutputTypeCountProductsArgs
    pending_payments?: boolean | BusinessCountOutputTypeCountPending_paymentsArgs
  }

  // Custom InputTypes
  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCountOutputType
     */
    select?: BusinessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountAffiliate_businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Affiliate_BusinessWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelinesWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountPending_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Pending_PaymentsWhereInput
  }


  /**
   * Count Type MessagesCountOutputType
   */

  export type MessagesCountOutputType = {
    replies: number
  }

  export type MessagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | MessagesCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * MessagesCountOutputType without action
   */
  export type MessagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesCountOutputType
     */
    select?: MessagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessagesCountOutputType without action
   */
  export type MessagesCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
  }


  /**
   * Count Type AffiliatesCountOutputType
   */

  export type AffiliatesCountOutputType = {
    affiliate_business: number
    orders: number
    affiliate_pending_payments: number
  }

  export type AffiliatesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_business?: boolean | AffiliatesCountOutputTypeCountAffiliate_businessArgs
    orders?: boolean | AffiliatesCountOutputTypeCountOrdersArgs
    affiliate_pending_payments?: boolean | AffiliatesCountOutputTypeCountAffiliate_pending_paymentsArgs
  }

  // Custom InputTypes
  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatesCountOutputType
     */
    select?: AffiliatesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountAffiliate_businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Affiliate_BusinessWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountAffiliate_pending_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Affiliate_Pending_PaymentsWhereInput
  }


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    affiliate_business: number
    orders: number
    pipelines: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_business?: boolean | ProductsCountOutputTypeCountAffiliate_businessArgs
    orders?: boolean | ProductsCountOutputTypeCountOrdersArgs
    pipelines?: boolean | ProductsCountOutputTypeCountPipelinesArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountAffiliate_businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Affiliate_BusinessWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelinesWhereInput
  }


  /**
   * Count Type PipelinesCountOutputType
   */

  export type PipelinesCountOutputType = {
    affiliate_business: number
    ChatMessage: number
  }

  export type PipelinesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_business?: boolean | PipelinesCountOutputTypeCountAffiliate_businessArgs
    ChatMessage?: boolean | PipelinesCountOutputTypeCountChatMessageArgs
  }

  // Custom InputTypes
  /**
   * PipelinesCountOutputType without action
   */
  export type PipelinesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelinesCountOutputType
     */
    select?: PipelinesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PipelinesCountOutputType without action
   */
  export type PipelinesCountOutputTypeCountAffiliate_businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Affiliate_BusinessWhereInput
  }

  /**
   * PipelinesCountOutputType without action
   */
  export type PipelinesCountOutputTypeCountChatMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type ResourcesCountOutputType
   */

  export type ResourcesCountOutputType = {
    embeddings: number
  }

  export type ResourcesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    embeddings?: boolean | ResourcesCountOutputTypeCountEmbeddingsArgs
  }

  // Custom InputTypes
  /**
   * ResourcesCountOutputType without action
   */
  export type ResourcesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourcesCountOutputType
     */
    select?: ResourcesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourcesCountOutputType without action
   */
  export type ResourcesCountOutputTypeCountEmbeddingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: embeddingsWhereInput
  }


  /**
   * Count Type Ig_scope_identifiersCountOutputType
   */

  export type Ig_scope_identifiersCountOutputType = {
    affiliate_business: number
  }

  export type Ig_scope_identifiersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_business?: boolean | Ig_scope_identifiersCountOutputTypeCountAffiliate_businessArgs
  }

  // Custom InputTypes
  /**
   * Ig_scope_identifiersCountOutputType without action
   */
  export type Ig_scope_identifiersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ig_scope_identifiersCountOutputType
     */
    select?: Ig_scope_identifiersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Ig_scope_identifiersCountOutputType without action
   */
  export type Ig_scope_identifiersCountOutputTypeCountAffiliate_businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Affiliate_BusinessWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Business
   */

  export type AggregateBusiness = {
    _count: BusinessCountAggregateOutputType | null
    _avg: BusinessAvgAggregateOutputType | null
    _sum: BusinessSumAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  export type BusinessAvgAggregateOutputType = {
    commission: number | null
  }

  export type BusinessSumAggregateOutputType = {
    commission: number | null
  }

  export type BusinessMinAggregateOutputType = {
    id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    store_name: string | null
    slug: string | null
    description: string | null
    url: string | null
    wallet_address: string | null
    commission: number | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    affiliate_hub_description: string | null
    svix_consumer_app_id: string | null
    stripe_connected_account: string | null
    price_plan: $Enums.PricePlan | null
    trial_ends_at: Date | null
    stripe_customer_id: string | null
    stripe_subscription_id: string | null
    payment_preference: $Enums.PaymentPreference | null
  }

  export type BusinessMaxAggregateOutputType = {
    id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    store_name: string | null
    slug: string | null
    description: string | null
    url: string | null
    wallet_address: string | null
    commission: number | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    affiliate_hub_description: string | null
    svix_consumer_app_id: string | null
    stripe_connected_account: string | null
    price_plan: $Enums.PricePlan | null
    trial_ends_at: Date | null
    stripe_customer_id: string | null
    stripe_subscription_id: string | null
    payment_preference: $Enums.PaymentPreference | null
  }

  export type BusinessCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    store_name: number
    slug: number
    description: number
    url: number
    wallet_address: number
    commission: number
    status: number
    created_at: number
    updated_at: number
    affiliate_hub_description: number
    svix_consumer_app_id: number
    stripe_connected_account: number
    price_plan: number
    trial_ends_at: number
    stripe_customer_id: number
    stripe_subscription_id: number
    payment_preference: number
    _all: number
  }


  export type BusinessAvgAggregateInputType = {
    commission?: true
  }

  export type BusinessSumAggregateInputType = {
    commission?: true
  }

  export type BusinessMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    store_name?: true
    slug?: true
    description?: true
    url?: true
    wallet_address?: true
    commission?: true
    status?: true
    created_at?: true
    updated_at?: true
    affiliate_hub_description?: true
    svix_consumer_app_id?: true
    stripe_connected_account?: true
    price_plan?: true
    trial_ends_at?: true
    stripe_customer_id?: true
    stripe_subscription_id?: true
    payment_preference?: true
  }

  export type BusinessMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    store_name?: true
    slug?: true
    description?: true
    url?: true
    wallet_address?: true
    commission?: true
    status?: true
    created_at?: true
    updated_at?: true
    affiliate_hub_description?: true
    svix_consumer_app_id?: true
    stripe_connected_account?: true
    price_plan?: true
    trial_ends_at?: true
    stripe_customer_id?: true
    stripe_subscription_id?: true
    payment_preference?: true
  }

  export type BusinessCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    store_name?: true
    slug?: true
    description?: true
    url?: true
    wallet_address?: true
    commission?: true
    status?: true
    created_at?: true
    updated_at?: true
    affiliate_hub_description?: true
    svix_consumer_app_id?: true
    stripe_connected_account?: true
    price_plan?: true
    trial_ends_at?: true
    stripe_customer_id?: true
    stripe_subscription_id?: true
    payment_preference?: true
    _all?: true
  }

  export type BusinessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Business to aggregate.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Businesses
    **/
    _count?: true | BusinessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessMaxAggregateInputType
  }

  export type GetBusinessAggregateType<T extends BusinessAggregateArgs> = {
        [P in keyof T & keyof AggregateBusiness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusiness[P]>
      : GetScalarType<T[P], AggregateBusiness[P]>
  }




  export type BusinessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithAggregationInput | BusinessOrderByWithAggregationInput[]
    by: BusinessScalarFieldEnum[] | BusinessScalarFieldEnum
    having?: BusinessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessCountAggregateInputType | true
    _avg?: BusinessAvgAggregateInputType
    _sum?: BusinessSumAggregateInputType
    _min?: BusinessMinAggregateInputType
    _max?: BusinessMaxAggregateInputType
  }

  export type BusinessGroupByOutputType = {
    id: string
    first_name: string | null
    last_name: string | null
    email: string
    store_name: string | null
    slug: string
    description: string | null
    url: string | null
    wallet_address: string | null
    commission: number | null
    status: string
    created_at: Date
    updated_at: Date
    affiliate_hub_description: string | null
    svix_consumer_app_id: string | null
    stripe_connected_account: string | null
    price_plan: $Enums.PricePlan | null
    trial_ends_at: Date | null
    stripe_customer_id: string | null
    stripe_subscription_id: string | null
    payment_preference: $Enums.PaymentPreference
    _count: BusinessCountAggregateOutputType | null
    _avg: BusinessAvgAggregateOutputType | null
    _sum: BusinessSumAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  type GetBusinessGroupByPayload<T extends BusinessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessGroupByOutputType[P]>
        }
      >
    >


  export type BusinessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    store_name?: boolean
    slug?: boolean
    description?: boolean
    url?: boolean
    wallet_address?: boolean
    commission?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliate_hub_description?: boolean
    svix_consumer_app_id?: boolean
    stripe_connected_account?: boolean
    price_plan?: boolean
    trial_ends_at?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_id?: boolean
    payment_preference?: boolean
    affiliate_business?: boolean | Business$affiliate_businessArgs<ExtArgs>
    messages?: boolean | Business$messagesArgs<ExtArgs>
    orders?: boolean | Business$ordersArgs<ExtArgs>
    pipelines?: boolean | Business$pipelinesArgs<ExtArgs>
    products?: boolean | Business$productsArgs<ExtArgs>
    pending_payments?: boolean | Business$pending_paymentsArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    store_name?: boolean
    slug?: boolean
    description?: boolean
    url?: boolean
    wallet_address?: boolean
    commission?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliate_hub_description?: boolean
    svix_consumer_app_id?: boolean
    stripe_connected_account?: boolean
    price_plan?: boolean
    trial_ends_at?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_id?: boolean
    payment_preference?: boolean
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    store_name?: boolean
    slug?: boolean
    description?: boolean
    url?: boolean
    wallet_address?: boolean
    commission?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliate_hub_description?: boolean
    svix_consumer_app_id?: boolean
    stripe_connected_account?: boolean
    price_plan?: boolean
    trial_ends_at?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_id?: boolean
    payment_preference?: boolean
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    store_name?: boolean
    slug?: boolean
    description?: boolean
    url?: boolean
    wallet_address?: boolean
    commission?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliate_hub_description?: boolean
    svix_consumer_app_id?: boolean
    stripe_connected_account?: boolean
    price_plan?: boolean
    trial_ends_at?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_id?: boolean
    payment_preference?: boolean
  }

  export type BusinessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "email" | "store_name" | "slug" | "description" | "url" | "wallet_address" | "commission" | "status" | "created_at" | "updated_at" | "affiliate_hub_description" | "svix_consumer_app_id" | "stripe_connected_account" | "price_plan" | "trial_ends_at" | "stripe_customer_id" | "stripe_subscription_id" | "payment_preference", ExtArgs["result"]["business"]>
  export type BusinessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_business?: boolean | Business$affiliate_businessArgs<ExtArgs>
    messages?: boolean | Business$messagesArgs<ExtArgs>
    orders?: boolean | Business$ordersArgs<ExtArgs>
    pipelines?: boolean | Business$pipelinesArgs<ExtArgs>
    products?: boolean | Business$productsArgs<ExtArgs>
    pending_payments?: boolean | Business$pending_paymentsArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BusinessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BusinessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Business"
    objects: {
      affiliate_business: Prisma.$Affiliate_BusinessPayload<ExtArgs>[]
      messages: Prisma.$MessagesPayload<ExtArgs>[]
      orders: Prisma.$OrdersPayload<ExtArgs>[]
      pipelines: Prisma.$PipelinesPayload<ExtArgs>[]
      products: Prisma.$ProductsPayload<ExtArgs>[]
      pending_payments: Prisma.$Pending_PaymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      first_name: string | null
      last_name: string | null
      email: string
      store_name: string | null
      slug: string
      description: string | null
      url: string | null
      wallet_address: string | null
      commission: number | null
      status: string
      created_at: Date
      updated_at: Date
      affiliate_hub_description: string | null
      svix_consumer_app_id: string | null
      stripe_connected_account: string | null
      price_plan: $Enums.PricePlan | null
      trial_ends_at: Date | null
      stripe_customer_id: string | null
      stripe_subscription_id: string | null
      payment_preference: $Enums.PaymentPreference
    }, ExtArgs["result"]["business"]>
    composites: {}
  }

  type BusinessGetPayload<S extends boolean | null | undefined | BusinessDefaultArgs> = $Result.GetResult<Prisma.$BusinessPayload, S>

  type BusinessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessCountAggregateInputType | true
    }

  export interface BusinessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Business'], meta: { name: 'Business' } }
    /**
     * Find zero or one Business that matches the filter.
     * @param {BusinessFindUniqueArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessFindUniqueArgs>(args: SelectSubset<T, BusinessFindUniqueArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Business that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessFindUniqueOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Business that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessFindFirstArgs>(args?: SelectSubset<T, BusinessFindFirstArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Business that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Businesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Businesses
     * const businesses = await prisma.business.findMany()
     * 
     * // Get first 10 Businesses
     * const businesses = await prisma.business.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessWithIdOnly = await prisma.business.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessFindManyArgs>(args?: SelectSubset<T, BusinessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Business.
     * @param {BusinessCreateArgs} args - Arguments to create a Business.
     * @example
     * // Create one Business
     * const Business = await prisma.business.create({
     *   data: {
     *     // ... data to create a Business
     *   }
     * })
     * 
     */
    create<T extends BusinessCreateArgs>(args: SelectSubset<T, BusinessCreateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Businesses.
     * @param {BusinessCreateManyArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessCreateManyArgs>(args?: SelectSubset<T, BusinessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Businesses and returns the data saved in the database.
     * @param {BusinessCreateManyAndReturnArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Businesses and only return the `id`
     * const businessWithIdOnly = await prisma.business.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Business.
     * @param {BusinessDeleteArgs} args - Arguments to delete one Business.
     * @example
     * // Delete one Business
     * const Business = await prisma.business.delete({
     *   where: {
     *     // ... filter to delete one Business
     *   }
     * })
     * 
     */
    delete<T extends BusinessDeleteArgs>(args: SelectSubset<T, BusinessDeleteArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Business.
     * @param {BusinessUpdateArgs} args - Arguments to update one Business.
     * @example
     * // Update one Business
     * const business = await prisma.business.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUpdateArgs>(args: SelectSubset<T, BusinessUpdateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Businesses.
     * @param {BusinessDeleteManyArgs} args - Arguments to filter Businesses to delete.
     * @example
     * // Delete a few Businesses
     * const { count } = await prisma.business.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessDeleteManyArgs>(args?: SelectSubset<T, BusinessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUpdateManyArgs>(args: SelectSubset<T, BusinessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses and returns the data updated in the database.
     * @param {BusinessUpdateManyAndReturnArgs} args - Arguments to update many Businesses.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Businesses and only return the `id`
     * const businessWithIdOnly = await prisma.business.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Business.
     * @param {BusinessUpsertArgs} args - Arguments to update or create a Business.
     * @example
     * // Update or create a Business
     * const business = await prisma.business.upsert({
     *   create: {
     *     // ... data to create a Business
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Business we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUpsertArgs>(args: SelectSubset<T, BusinessUpsertArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCountArgs} args - Arguments to filter Businesses to count.
     * @example
     * // Count the number of Businesses
     * const count = await prisma.business.count({
     *   where: {
     *     // ... the filter for the Businesses we want to count
     *   }
     * })
    **/
    count<T extends BusinessCountArgs>(
      args?: Subset<T, BusinessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessAggregateArgs>(args: Subset<T, BusinessAggregateArgs>): Prisma.PrismaPromise<GetBusinessAggregateType<T>>

    /**
     * Group by Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessGroupByArgs['orderBy'] }
        : { orderBy?: BusinessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Business model
   */
  readonly fields: BusinessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Business.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate_business<T extends Business$affiliate_businessArgs<ExtArgs> = {}>(args?: Subset<T, Business$affiliate_businessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Business$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Business$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Business$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Business$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pipelines<T extends Business$pipelinesArgs<ExtArgs> = {}>(args?: Subset<T, Business$pipelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Business$productsArgs<ExtArgs> = {}>(args?: Subset<T, Business$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pending_payments<T extends Business$pending_paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Business$pending_paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Pending_PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Business model
   */
  interface BusinessFieldRefs {
    readonly id: FieldRef<"Business", 'String'>
    readonly first_name: FieldRef<"Business", 'String'>
    readonly last_name: FieldRef<"Business", 'String'>
    readonly email: FieldRef<"Business", 'String'>
    readonly store_name: FieldRef<"Business", 'String'>
    readonly slug: FieldRef<"Business", 'String'>
    readonly description: FieldRef<"Business", 'String'>
    readonly url: FieldRef<"Business", 'String'>
    readonly wallet_address: FieldRef<"Business", 'String'>
    readonly commission: FieldRef<"Business", 'Int'>
    readonly status: FieldRef<"Business", 'String'>
    readonly created_at: FieldRef<"Business", 'DateTime'>
    readonly updated_at: FieldRef<"Business", 'DateTime'>
    readonly affiliate_hub_description: FieldRef<"Business", 'String'>
    readonly svix_consumer_app_id: FieldRef<"Business", 'String'>
    readonly stripe_connected_account: FieldRef<"Business", 'String'>
    readonly price_plan: FieldRef<"Business", 'PricePlan'>
    readonly trial_ends_at: FieldRef<"Business", 'DateTime'>
    readonly stripe_customer_id: FieldRef<"Business", 'String'>
    readonly stripe_subscription_id: FieldRef<"Business", 'String'>
    readonly payment_preference: FieldRef<"Business", 'PaymentPreference'>
  }
    

  // Custom InputTypes
  /**
   * Business findUnique
   */
  export type BusinessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findUniqueOrThrow
   */
  export type BusinessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findFirst
   */
  export type BusinessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findFirstOrThrow
   */
  export type BusinessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findMany
   */
  export type BusinessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Businesses to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business create
   */
  export type BusinessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to create a Business.
     */
    data: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
  }

  /**
   * Business createMany
   */
  export type BusinessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Business createManyAndReturn
   */
  export type BusinessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Business update
   */
  export type BusinessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to update a Business.
     */
    data: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
    /**
     * Choose, which Business to update.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business updateMany
   */
  export type BusinessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
    /**
     * Limit how many Businesses to update.
     */
    limit?: number
  }

  /**
   * Business updateManyAndReturn
   */
  export type BusinessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
    /**
     * Limit how many Businesses to update.
     */
    limit?: number
  }

  /**
   * Business upsert
   */
  export type BusinessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The filter to search for the Business to update in case it exists.
     */
    where: BusinessWhereUniqueInput
    /**
     * In case the Business found by the `where` argument doesn't exist, create a new Business with this data.
     */
    create: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
    /**
     * In case the Business was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
  }

  /**
   * Business delete
   */
  export type BusinessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter which Business to delete.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business deleteMany
   */
  export type BusinessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Businesses to delete
     */
    where?: BusinessWhereInput
    /**
     * Limit how many Businesses to delete.
     */
    limit?: number
  }

  /**
   * Business.affiliate_business
   */
  export type Business$affiliate_businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    where?: Affiliate_BusinessWhereInput
    orderBy?: Affiliate_BusinessOrderByWithRelationInput | Affiliate_BusinessOrderByWithRelationInput[]
    cursor?: Affiliate_BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Affiliate_BusinessScalarFieldEnum | Affiliate_BusinessScalarFieldEnum[]
  }

  /**
   * Business.messages
   */
  export type Business$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    cursor?: MessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Business.orders
   */
  export type Business$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Business.pipelines
   */
  export type Business$pipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    where?: PipelinesWhereInput
    orderBy?: PipelinesOrderByWithRelationInput | PipelinesOrderByWithRelationInput[]
    cursor?: PipelinesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelinesScalarFieldEnum | PipelinesScalarFieldEnum[]
  }

  /**
   * Business.products
   */
  export type Business$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    cursor?: ProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Business.pending_payments
   */
  export type Business$pending_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsInclude<ExtArgs> | null
    where?: Pending_PaymentsWhereInput
    orderBy?: Pending_PaymentsOrderByWithRelationInput | Pending_PaymentsOrderByWithRelationInput[]
    cursor?: Pending_PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pending_PaymentsScalarFieldEnum | Pending_PaymentsScalarFieldEnum[]
  }

  /**
   * Business without action
   */
  export type BusinessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
  }


  /**
   * Model Messages
   */

  export type AggregateMessages = {
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  export type MessagesMinAggregateOutputType = {
    id: string | null
    message: string | null
    type: string | null
    sent_at: Date | null
    business_id: string | null
    message_id: string | null
    email: string | null
    name: string | null
    subject: string | null
    parent_id: string | null
    channel_id: string | null
    video_id: string | null
  }

  export type MessagesMaxAggregateOutputType = {
    id: string | null
    message: string | null
    type: string | null
    sent_at: Date | null
    business_id: string | null
    message_id: string | null
    email: string | null
    name: string | null
    subject: string | null
    parent_id: string | null
    channel_id: string | null
    video_id: string | null
  }

  export type MessagesCountAggregateOutputType = {
    id: number
    message: number
    type: number
    sent_at: number
    business_id: number
    message_id: number
    email: number
    name: number
    subject: number
    parent_id: number
    channel_id: number
    video_id: number
    _all: number
  }


  export type MessagesMinAggregateInputType = {
    id?: true
    message?: true
    type?: true
    sent_at?: true
    business_id?: true
    message_id?: true
    email?: true
    name?: true
    subject?: true
    parent_id?: true
    channel_id?: true
    video_id?: true
  }

  export type MessagesMaxAggregateInputType = {
    id?: true
    message?: true
    type?: true
    sent_at?: true
    business_id?: true
    message_id?: true
    email?: true
    name?: true
    subject?: true
    parent_id?: true
    channel_id?: true
    video_id?: true
  }

  export type MessagesCountAggregateInputType = {
    id?: true
    message?: true
    type?: true
    sent_at?: true
    business_id?: true
    message_id?: true
    email?: true
    name?: true
    subject?: true
    parent_id?: true
    channel_id?: true
    video_id?: true
    _all?: true
  }

  export type MessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to aggregate.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesMaxAggregateInputType
  }

  export type GetMessagesAggregateType<T extends MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages[P]>
      : GetScalarType<T[P], AggregateMessages[P]>
  }




  export type MessagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithAggregationInput | MessagesOrderByWithAggregationInput[]
    by: MessagesScalarFieldEnum[] | MessagesScalarFieldEnum
    having?: MessagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesCountAggregateInputType | true
    _min?: MessagesMinAggregateInputType
    _max?: MessagesMaxAggregateInputType
  }

  export type MessagesGroupByOutputType = {
    id: string
    message: string
    type: string
    sent_at: Date
    business_id: string
    message_id: string | null
    email: string | null
    name: string | null
    subject: string
    parent_id: string | null
    channel_id: string | null
    video_id: string | null
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  type GetMessagesGroupByPayload<T extends MessagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesGroupByOutputType[P]>
        }
      >
    >


  export type MessagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    type?: boolean
    sent_at?: boolean
    business_id?: boolean
    message_id?: boolean
    email?: boolean
    name?: boolean
    subject?: boolean
    parent_id?: boolean
    channel_id?: boolean
    video_id?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    parent?: boolean | Messages$parentArgs<ExtArgs>
    replies?: boolean | Messages$repliesArgs<ExtArgs>
    _count?: boolean | MessagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type MessagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    type?: boolean
    sent_at?: boolean
    business_id?: boolean
    message_id?: boolean
    email?: boolean
    name?: boolean
    subject?: boolean
    parent_id?: boolean
    channel_id?: boolean
    video_id?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    parent?: boolean | Messages$parentArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type MessagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    type?: boolean
    sent_at?: boolean
    business_id?: boolean
    message_id?: boolean
    email?: boolean
    name?: boolean
    subject?: boolean
    parent_id?: boolean
    channel_id?: boolean
    video_id?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    parent?: boolean | Messages$parentArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type MessagesSelectScalar = {
    id?: boolean
    message?: boolean
    type?: boolean
    sent_at?: boolean
    business_id?: boolean
    message_id?: boolean
    email?: boolean
    name?: boolean
    subject?: boolean
    parent_id?: boolean
    channel_id?: boolean
    video_id?: boolean
  }

  export type MessagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message" | "type" | "sent_at" | "business_id" | "message_id" | "email" | "name" | "subject" | "parent_id" | "channel_id" | "video_id", ExtArgs["result"]["messages"]>
  export type MessagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    parent?: boolean | Messages$parentArgs<ExtArgs>
    replies?: boolean | Messages$repliesArgs<ExtArgs>
    _count?: boolean | MessagesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    parent?: boolean | Messages$parentArgs<ExtArgs>
  }
  export type MessagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    parent?: boolean | Messages$parentArgs<ExtArgs>
  }

  export type $MessagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Messages"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      parent: Prisma.$MessagesPayload<ExtArgs> | null
      replies: Prisma.$MessagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      message: string
      type: string
      sent_at: Date
      business_id: string
      message_id: string | null
      email: string | null
      name: string | null
      subject: string
      parent_id: string | null
      channel_id: string | null
      video_id: string | null
    }, ExtArgs["result"]["messages"]>
    composites: {}
  }

  type MessagesGetPayload<S extends boolean | null | undefined | MessagesDefaultArgs> = $Result.GetResult<Prisma.$MessagesPayload, S>

  type MessagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessagesCountAggregateInputType | true
    }

  export interface MessagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Messages'], meta: { name: 'Messages' } }
    /**
     * Find zero or one Messages that matches the filter.
     * @param {MessagesFindUniqueArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessagesFindUniqueArgs>(args: SelectSubset<T, MessagesFindUniqueArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessagesFindUniqueOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessagesFindUniqueOrThrowArgs>(args: SelectSubset<T, MessagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindFirstArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessagesFindFirstArgs>(args?: SelectSubset<T, MessagesFindFirstArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindFirstOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessagesFindFirstOrThrowArgs>(args?: SelectSubset<T, MessagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.messages.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messagesWithIdOnly = await prisma.messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessagesFindManyArgs>(args?: SelectSubset<T, MessagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Messages.
     * @param {MessagesCreateArgs} args - Arguments to create a Messages.
     * @example
     * // Create one Messages
     * const Messages = await prisma.messages.create({
     *   data: {
     *     // ... data to create a Messages
     *   }
     * })
     * 
     */
    create<T extends MessagesCreateArgs>(args: SelectSubset<T, MessagesCreateArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessagesCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessagesCreateManyArgs>(args?: SelectSubset<T, MessagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessagesCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessagesCreateManyAndReturnArgs>(args?: SelectSubset<T, MessagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Messages.
     * @param {MessagesDeleteArgs} args - Arguments to delete one Messages.
     * @example
     * // Delete one Messages
     * const Messages = await prisma.messages.delete({
     *   where: {
     *     // ... filter to delete one Messages
     *   }
     * })
     * 
     */
    delete<T extends MessagesDeleteArgs>(args: SelectSubset<T, MessagesDeleteArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Messages.
     * @param {MessagesUpdateArgs} args - Arguments to update one Messages.
     * @example
     * // Update one Messages
     * const messages = await prisma.messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessagesUpdateArgs>(args: SelectSubset<T, MessagesUpdateArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessagesDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessagesDeleteManyArgs>(args?: SelectSubset<T, MessagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessagesUpdateManyArgs>(args: SelectSubset<T, MessagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessagesUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessagesUpdateManyAndReturnArgs>(args: SelectSubset<T, MessagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Messages.
     * @param {MessagesUpsertArgs} args - Arguments to update or create a Messages.
     * @example
     * // Update or create a Messages
     * const messages = await prisma.messages.upsert({
     *   create: {
     *     // ... data to create a Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages we want to update
     *   }
     * })
     */
    upsert<T extends MessagesUpsertArgs>(args: SelectSubset<T, MessagesUpsertArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.messages.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessagesCountArgs>(
      args?: Subset<T, MessagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesAggregateArgs>(args: Subset<T, MessagesAggregateArgs>): Prisma.PrismaPromise<GetMessagesAggregateType<T>>

    /**
     * Group by Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessagesGroupByArgs['orderBy'] }
        : { orderBy?: MessagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Messages model
   */
  readonly fields: MessagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Messages$parentArgs<ExtArgs> = {}>(args?: Subset<T, Messages$parentArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Messages$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Messages$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Messages model
   */
  interface MessagesFieldRefs {
    readonly id: FieldRef<"Messages", 'String'>
    readonly message: FieldRef<"Messages", 'String'>
    readonly type: FieldRef<"Messages", 'String'>
    readonly sent_at: FieldRef<"Messages", 'DateTime'>
    readonly business_id: FieldRef<"Messages", 'String'>
    readonly message_id: FieldRef<"Messages", 'String'>
    readonly email: FieldRef<"Messages", 'String'>
    readonly name: FieldRef<"Messages", 'String'>
    readonly subject: FieldRef<"Messages", 'String'>
    readonly parent_id: FieldRef<"Messages", 'String'>
    readonly channel_id: FieldRef<"Messages", 'String'>
    readonly video_id: FieldRef<"Messages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Messages findUnique
   */
  export type MessagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages findUniqueOrThrow
   */
  export type MessagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages findFirst
   */
  export type MessagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages findFirstOrThrow
   */
  export type MessagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages findMany
   */
  export type MessagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages create
   */
  export type MessagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The data needed to create a Messages.
     */
    data: XOR<MessagesCreateInput, MessagesUncheckedCreateInput>
  }

  /**
   * Messages createMany
   */
  export type MessagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessagesCreateManyInput | MessagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Messages createManyAndReturn
   */
  export type MessagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessagesCreateManyInput | MessagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Messages update
   */
  export type MessagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The data needed to update a Messages.
     */
    data: XOR<MessagesUpdateInput, MessagesUncheckedUpdateInput>
    /**
     * Choose, which Messages to update.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages updateMany
   */
  export type MessagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessagesWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Messages updateManyAndReturn
   */
  export type MessagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessagesWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Messages upsert
   */
  export type MessagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The filter to search for the Messages to update in case it exists.
     */
    where: MessagesWhereUniqueInput
    /**
     * In case the Messages found by the `where` argument doesn't exist, create a new Messages with this data.
     */
    create: XOR<MessagesCreateInput, MessagesUncheckedCreateInput>
    /**
     * In case the Messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessagesUpdateInput, MessagesUncheckedUpdateInput>
  }

  /**
   * Messages delete
   */
  export type MessagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter which Messages to delete.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages deleteMany
   */
  export type MessagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessagesWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Messages.parent
   */
  export type Messages$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    where?: MessagesWhereInput
  }

  /**
   * Messages.replies
   */
  export type Messages$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    cursor?: MessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages without action
   */
  export type MessagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
  }


  /**
   * Model Affiliates
   */

  export type AggregateAffiliates = {
    _count: AffiliatesCountAggregateOutputType | null
    _avg: AffiliatesAvgAggregateOutputType | null
    _sum: AffiliatesSumAggregateOutputType | null
    _min: AffiliatesMinAggregateOutputType | null
    _max: AffiliatesMaxAggregateOutputType | null
  }

  export type AffiliatesAvgAggregateOutputType = {
    id: number | null
  }

  export type AffiliatesSumAggregateOutputType = {
    id: number | null
  }

  export type AffiliatesMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
    status: string | null
    wallet_address: string | null
  }

  export type AffiliatesMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
    status: string | null
    wallet_address: string | null
  }

  export type AffiliatesCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    description: number
    created_at: number
    updated_at: number
    status: number
    wallet_address: number
    metadata: number
    social_media_profiles: number
    _all: number
  }


  export type AffiliatesAvgAggregateInputType = {
    id?: true
  }

  export type AffiliatesSumAggregateInputType = {
    id?: true
  }

  export type AffiliatesMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    description?: true
    created_at?: true
    updated_at?: true
    status?: true
    wallet_address?: true
  }

  export type AffiliatesMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    description?: true
    created_at?: true
    updated_at?: true
    status?: true
    wallet_address?: true
  }

  export type AffiliatesCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    description?: true
    created_at?: true
    updated_at?: true
    status?: true
    wallet_address?: true
    metadata?: true
    social_media_profiles?: true
    _all?: true
  }

  export type AffiliatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Affiliates to aggregate.
     */
    where?: AffiliatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliatesOrderByWithRelationInput | AffiliatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Affiliates
    **/
    _count?: true | AffiliatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliatesMaxAggregateInputType
  }

  export type GetAffiliatesAggregateType<T extends AffiliatesAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliates[P]>
      : GetScalarType<T[P], AggregateAffiliates[P]>
  }




  export type AffiliatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliatesWhereInput
    orderBy?: AffiliatesOrderByWithAggregationInput | AffiliatesOrderByWithAggregationInput[]
    by: AffiliatesScalarFieldEnum[] | AffiliatesScalarFieldEnum
    having?: AffiliatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliatesCountAggregateInputType | true
    _avg?: AffiliatesAvgAggregateInputType
    _sum?: AffiliatesSumAggregateInputType
    _min?: AffiliatesMinAggregateInputType
    _max?: AffiliatesMaxAggregateInputType
  }

  export type AffiliatesGroupByOutputType = {
    id: number
    first_name: string | null
    last_name: string | null
    email: string
    description: string | null
    created_at: Date
    updated_at: Date
    status: string
    wallet_address: string | null
    metadata: JsonValue | null
    social_media_profiles: JsonValue | null
    _count: AffiliatesCountAggregateOutputType | null
    _avg: AffiliatesAvgAggregateOutputType | null
    _sum: AffiliatesSumAggregateOutputType | null
    _min: AffiliatesMinAggregateOutputType | null
    _max: AffiliatesMaxAggregateOutputType | null
  }

  type GetAffiliatesGroupByPayload<T extends AffiliatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliatesGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliatesGroupByOutputType[P]>
        }
      >
    >


  export type AffiliatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    wallet_address?: boolean
    metadata?: boolean
    social_media_profiles?: boolean
    affiliate_business?: boolean | Affiliates$affiliate_businessArgs<ExtArgs>
    orders?: boolean | Affiliates$ordersArgs<ExtArgs>
    affiliate_pending_payments?: boolean | Affiliates$affiliate_pending_paymentsArgs<ExtArgs>
    _count?: boolean | AffiliatesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliates"]>

  export type AffiliatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    wallet_address?: boolean
    metadata?: boolean
    social_media_profiles?: boolean
  }, ExtArgs["result"]["affiliates"]>

  export type AffiliatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    wallet_address?: boolean
    metadata?: boolean
    social_media_profiles?: boolean
  }, ExtArgs["result"]["affiliates"]>

  export type AffiliatesSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    wallet_address?: boolean
    metadata?: boolean
    social_media_profiles?: boolean
  }

  export type AffiliatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "email" | "description" | "created_at" | "updated_at" | "status" | "wallet_address" | "metadata" | "social_media_profiles", ExtArgs["result"]["affiliates"]>
  export type AffiliatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_business?: boolean | Affiliates$affiliate_businessArgs<ExtArgs>
    orders?: boolean | Affiliates$ordersArgs<ExtArgs>
    affiliate_pending_payments?: boolean | Affiliates$affiliate_pending_paymentsArgs<ExtArgs>
    _count?: boolean | AffiliatesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AffiliatesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AffiliatesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AffiliatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Affiliates"
    objects: {
      affiliate_business: Prisma.$Affiliate_BusinessPayload<ExtArgs>[]
      orders: Prisma.$OrdersPayload<ExtArgs>[]
      affiliate_pending_payments: Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string | null
      last_name: string | null
      email: string
      description: string | null
      created_at: Date
      updated_at: Date
      status: string
      wallet_address: string | null
      metadata: Prisma.JsonValue | null
      social_media_profiles: Prisma.JsonValue | null
    }, ExtArgs["result"]["affiliates"]>
    composites: {}
  }

  type AffiliatesGetPayload<S extends boolean | null | undefined | AffiliatesDefaultArgs> = $Result.GetResult<Prisma.$AffiliatesPayload, S>

  type AffiliatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AffiliatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AffiliatesCountAggregateInputType | true
    }

  export interface AffiliatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Affiliates'], meta: { name: 'Affiliates' } }
    /**
     * Find zero or one Affiliates that matches the filter.
     * @param {AffiliatesFindUniqueArgs} args - Arguments to find a Affiliates
     * @example
     * // Get one Affiliates
     * const affiliates = await prisma.affiliates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliatesFindUniqueArgs>(args: SelectSubset<T, AffiliatesFindUniqueArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Affiliates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AffiliatesFindUniqueOrThrowArgs} args - Arguments to find a Affiliates
     * @example
     * // Get one Affiliates
     * const affiliates = await prisma.affiliates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliatesFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Affiliates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesFindFirstArgs} args - Arguments to find a Affiliates
     * @example
     * // Get one Affiliates
     * const affiliates = await prisma.affiliates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliatesFindFirstArgs>(args?: SelectSubset<T, AffiliatesFindFirstArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Affiliates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesFindFirstOrThrowArgs} args - Arguments to find a Affiliates
     * @example
     * // Get one Affiliates
     * const affiliates = await prisma.affiliates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliatesFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Affiliates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Affiliates
     * const affiliates = await prisma.affiliates.findMany()
     * 
     * // Get first 10 Affiliates
     * const affiliates = await prisma.affiliates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliatesWithIdOnly = await prisma.affiliates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliatesFindManyArgs>(args?: SelectSubset<T, AffiliatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Affiliates.
     * @param {AffiliatesCreateArgs} args - Arguments to create a Affiliates.
     * @example
     * // Create one Affiliates
     * const Affiliates = await prisma.affiliates.create({
     *   data: {
     *     // ... data to create a Affiliates
     *   }
     * })
     * 
     */
    create<T extends AffiliatesCreateArgs>(args: SelectSubset<T, AffiliatesCreateArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Affiliates.
     * @param {AffiliatesCreateManyArgs} args - Arguments to create many Affiliates.
     * @example
     * // Create many Affiliates
     * const affiliates = await prisma.affiliates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliatesCreateManyArgs>(args?: SelectSubset<T, AffiliatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Affiliates and returns the data saved in the database.
     * @param {AffiliatesCreateManyAndReturnArgs} args - Arguments to create many Affiliates.
     * @example
     * // Create many Affiliates
     * const affiliates = await prisma.affiliates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Affiliates and only return the `id`
     * const affiliatesWithIdOnly = await prisma.affiliates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliatesCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Affiliates.
     * @param {AffiliatesDeleteArgs} args - Arguments to delete one Affiliates.
     * @example
     * // Delete one Affiliates
     * const Affiliates = await prisma.affiliates.delete({
     *   where: {
     *     // ... filter to delete one Affiliates
     *   }
     * })
     * 
     */
    delete<T extends AffiliatesDeleteArgs>(args: SelectSubset<T, AffiliatesDeleteArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Affiliates.
     * @param {AffiliatesUpdateArgs} args - Arguments to update one Affiliates.
     * @example
     * // Update one Affiliates
     * const affiliates = await prisma.affiliates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliatesUpdateArgs>(args: SelectSubset<T, AffiliatesUpdateArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Affiliates.
     * @param {AffiliatesDeleteManyArgs} args - Arguments to filter Affiliates to delete.
     * @example
     * // Delete a few Affiliates
     * const { count } = await prisma.affiliates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliatesDeleteManyArgs>(args?: SelectSubset<T, AffiliatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Affiliates
     * const affiliates = await prisma.affiliates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliatesUpdateManyArgs>(args: SelectSubset<T, AffiliatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affiliates and returns the data updated in the database.
     * @param {AffiliatesUpdateManyAndReturnArgs} args - Arguments to update many Affiliates.
     * @example
     * // Update many Affiliates
     * const affiliates = await prisma.affiliates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Affiliates and only return the `id`
     * const affiliatesWithIdOnly = await prisma.affiliates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AffiliatesUpdateManyAndReturnArgs>(args: SelectSubset<T, AffiliatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Affiliates.
     * @param {AffiliatesUpsertArgs} args - Arguments to update or create a Affiliates.
     * @example
     * // Update or create a Affiliates
     * const affiliates = await prisma.affiliates.upsert({
     *   create: {
     *     // ... data to create a Affiliates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Affiliates we want to update
     *   }
     * })
     */
    upsert<T extends AffiliatesUpsertArgs>(args: SelectSubset<T, AffiliatesUpsertArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesCountArgs} args - Arguments to filter Affiliates to count.
     * @example
     * // Count the number of Affiliates
     * const count = await prisma.affiliates.count({
     *   where: {
     *     // ... the filter for the Affiliates we want to count
     *   }
     * })
    **/
    count<T extends AffiliatesCountArgs>(
      args?: Subset<T, AffiliatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliatesAggregateArgs>(args: Subset<T, AffiliatesAggregateArgs>): Prisma.PrismaPromise<GetAffiliatesAggregateType<T>>

    /**
     * Group by Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliatesGroupByArgs['orderBy'] }
        : { orderBy?: AffiliatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Affiliates model
   */
  readonly fields: AffiliatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Affiliates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate_business<T extends Affiliates$affiliate_businessArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$affiliate_businessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Affiliates$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    affiliate_pending_payments<T extends Affiliates$affiliate_pending_paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$affiliate_pending_paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Affiliates model
   */
  interface AffiliatesFieldRefs {
    readonly id: FieldRef<"Affiliates", 'Int'>
    readonly first_name: FieldRef<"Affiliates", 'String'>
    readonly last_name: FieldRef<"Affiliates", 'String'>
    readonly email: FieldRef<"Affiliates", 'String'>
    readonly description: FieldRef<"Affiliates", 'String'>
    readonly created_at: FieldRef<"Affiliates", 'DateTime'>
    readonly updated_at: FieldRef<"Affiliates", 'DateTime'>
    readonly status: FieldRef<"Affiliates", 'String'>
    readonly wallet_address: FieldRef<"Affiliates", 'String'>
    readonly metadata: FieldRef<"Affiliates", 'Json'>
    readonly social_media_profiles: FieldRef<"Affiliates", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Affiliates findUnique
   */
  export type AffiliatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which Affiliates to fetch.
     */
    where: AffiliatesWhereUniqueInput
  }

  /**
   * Affiliates findUniqueOrThrow
   */
  export type AffiliatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which Affiliates to fetch.
     */
    where: AffiliatesWhereUniqueInput
  }

  /**
   * Affiliates findFirst
   */
  export type AffiliatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which Affiliates to fetch.
     */
    where?: AffiliatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliatesOrderByWithRelationInput | AffiliatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Affiliates.
     */
    cursor?: AffiliatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Affiliates.
     */
    distinct?: AffiliatesScalarFieldEnum | AffiliatesScalarFieldEnum[]
  }

  /**
   * Affiliates findFirstOrThrow
   */
  export type AffiliatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which Affiliates to fetch.
     */
    where?: AffiliatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliatesOrderByWithRelationInput | AffiliatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Affiliates.
     */
    cursor?: AffiliatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Affiliates.
     */
    distinct?: AffiliatesScalarFieldEnum | AffiliatesScalarFieldEnum[]
  }

  /**
   * Affiliates findMany
   */
  export type AffiliatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which Affiliates to fetch.
     */
    where?: AffiliatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliatesOrderByWithRelationInput | AffiliatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Affiliates.
     */
    cursor?: AffiliatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    distinct?: AffiliatesScalarFieldEnum | AffiliatesScalarFieldEnum[]
  }

  /**
   * Affiliates create
   */
  export type AffiliatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * The data needed to create a Affiliates.
     */
    data: XOR<AffiliatesCreateInput, AffiliatesUncheckedCreateInput>
  }

  /**
   * Affiliates createMany
   */
  export type AffiliatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Affiliates.
     */
    data: AffiliatesCreateManyInput | AffiliatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Affiliates createManyAndReturn
   */
  export type AffiliatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * The data used to create many Affiliates.
     */
    data: AffiliatesCreateManyInput | AffiliatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Affiliates update
   */
  export type AffiliatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * The data needed to update a Affiliates.
     */
    data: XOR<AffiliatesUpdateInput, AffiliatesUncheckedUpdateInput>
    /**
     * Choose, which Affiliates to update.
     */
    where: AffiliatesWhereUniqueInput
  }

  /**
   * Affiliates updateMany
   */
  export type AffiliatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Affiliates.
     */
    data: XOR<AffiliatesUpdateManyMutationInput, AffiliatesUncheckedUpdateManyInput>
    /**
     * Filter which Affiliates to update
     */
    where?: AffiliatesWhereInput
    /**
     * Limit how many Affiliates to update.
     */
    limit?: number
  }

  /**
   * Affiliates updateManyAndReturn
   */
  export type AffiliatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * The data used to update Affiliates.
     */
    data: XOR<AffiliatesUpdateManyMutationInput, AffiliatesUncheckedUpdateManyInput>
    /**
     * Filter which Affiliates to update
     */
    where?: AffiliatesWhereInput
    /**
     * Limit how many Affiliates to update.
     */
    limit?: number
  }

  /**
   * Affiliates upsert
   */
  export type AffiliatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * The filter to search for the Affiliates to update in case it exists.
     */
    where: AffiliatesWhereUniqueInput
    /**
     * In case the Affiliates found by the `where` argument doesn't exist, create a new Affiliates with this data.
     */
    create: XOR<AffiliatesCreateInput, AffiliatesUncheckedCreateInput>
    /**
     * In case the Affiliates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliatesUpdateInput, AffiliatesUncheckedUpdateInput>
  }

  /**
   * Affiliates delete
   */
  export type AffiliatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * Filter which Affiliates to delete.
     */
    where: AffiliatesWhereUniqueInput
  }

  /**
   * Affiliates deleteMany
   */
  export type AffiliatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Affiliates to delete
     */
    where?: AffiliatesWhereInput
    /**
     * Limit how many Affiliates to delete.
     */
    limit?: number
  }

  /**
   * Affiliates.affiliate_business
   */
  export type Affiliates$affiliate_businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    where?: Affiliate_BusinessWhereInput
    orderBy?: Affiliate_BusinessOrderByWithRelationInput | Affiliate_BusinessOrderByWithRelationInput[]
    cursor?: Affiliate_BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Affiliate_BusinessScalarFieldEnum | Affiliate_BusinessScalarFieldEnum[]
  }

  /**
   * Affiliates.orders
   */
  export type Affiliates$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Affiliates.affiliate_pending_payments
   */
  export type Affiliates$affiliate_pending_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsInclude<ExtArgs> | null
    where?: Affiliate_Pending_PaymentsWhereInput
    orderBy?: Affiliate_Pending_PaymentsOrderByWithRelationInput | Affiliate_Pending_PaymentsOrderByWithRelationInput[]
    cursor?: Affiliate_Pending_PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Affiliate_Pending_PaymentsScalarFieldEnum | Affiliate_Pending_PaymentsScalarFieldEnum[]
  }

  /**
   * Affiliates without action
   */
  export type AffiliatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
  }


  /**
   * Model Affiliate_Business
   */

  export type AggregateAffiliate_Business = {
    _count: Affiliate_BusinessCountAggregateOutputType | null
    _avg: Affiliate_BusinessAvgAggregateOutputType | null
    _sum: Affiliate_BusinessSumAggregateOutputType | null
    _min: Affiliate_BusinessMinAggregateOutputType | null
    _max: Affiliate_BusinessMaxAggregateOutputType | null
  }

  export type Affiliate_BusinessAvgAggregateOutputType = {
    affiliate_id: number | null
    product_id: number | null
    pipeline_id: number | null
  }

  export type Affiliate_BusinessSumAggregateOutputType = {
    affiliate_id: number | null
    product_id: number | null
    pipeline_id: number | null
  }

  export type Affiliate_BusinessMinAggregateOutputType = {
    id: string | null
    business_id: string | null
    affiliate_id: number | null
    affiliate_link: string | null
    affiliate_link_key: string | null
    product_id: number | null
    pipeline_id: number | null
    instagram_scope_identifier: string | null
  }

  export type Affiliate_BusinessMaxAggregateOutputType = {
    id: string | null
    business_id: string | null
    affiliate_id: number | null
    affiliate_link: string | null
    affiliate_link_key: string | null
    product_id: number | null
    pipeline_id: number | null
    instagram_scope_identifier: string | null
  }

  export type Affiliate_BusinessCountAggregateOutputType = {
    id: number
    business_id: number
    affiliate_id: number
    affiliate_link: number
    affiliate_link_key: number
    product_id: number
    pipeline_id: number
    instagram_scope_identifier: number
    _all: number
  }


  export type Affiliate_BusinessAvgAggregateInputType = {
    affiliate_id?: true
    product_id?: true
    pipeline_id?: true
  }

  export type Affiliate_BusinessSumAggregateInputType = {
    affiliate_id?: true
    product_id?: true
    pipeline_id?: true
  }

  export type Affiliate_BusinessMinAggregateInputType = {
    id?: true
    business_id?: true
    affiliate_id?: true
    affiliate_link?: true
    affiliate_link_key?: true
    product_id?: true
    pipeline_id?: true
    instagram_scope_identifier?: true
  }

  export type Affiliate_BusinessMaxAggregateInputType = {
    id?: true
    business_id?: true
    affiliate_id?: true
    affiliate_link?: true
    affiliate_link_key?: true
    product_id?: true
    pipeline_id?: true
    instagram_scope_identifier?: true
  }

  export type Affiliate_BusinessCountAggregateInputType = {
    id?: true
    business_id?: true
    affiliate_id?: true
    affiliate_link?: true
    affiliate_link_key?: true
    product_id?: true
    pipeline_id?: true
    instagram_scope_identifier?: true
    _all?: true
  }

  export type Affiliate_BusinessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Affiliate_Business to aggregate.
     */
    where?: Affiliate_BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliate_Businesses to fetch.
     */
    orderBy?: Affiliate_BusinessOrderByWithRelationInput | Affiliate_BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Affiliate_BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliate_Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliate_Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Affiliate_Businesses
    **/
    _count?: true | Affiliate_BusinessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Affiliate_BusinessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Affiliate_BusinessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Affiliate_BusinessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Affiliate_BusinessMaxAggregateInputType
  }

  export type GetAffiliate_BusinessAggregateType<T extends Affiliate_BusinessAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliate_Business]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliate_Business[P]>
      : GetScalarType<T[P], AggregateAffiliate_Business[P]>
  }




  export type Affiliate_BusinessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Affiliate_BusinessWhereInput
    orderBy?: Affiliate_BusinessOrderByWithAggregationInput | Affiliate_BusinessOrderByWithAggregationInput[]
    by: Affiliate_BusinessScalarFieldEnum[] | Affiliate_BusinessScalarFieldEnum
    having?: Affiliate_BusinessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Affiliate_BusinessCountAggregateInputType | true
    _avg?: Affiliate_BusinessAvgAggregateInputType
    _sum?: Affiliate_BusinessSumAggregateInputType
    _min?: Affiliate_BusinessMinAggregateInputType
    _max?: Affiliate_BusinessMaxAggregateInputType
  }

  export type Affiliate_BusinessGroupByOutputType = {
    id: string
    business_id: string
    affiliate_id: number
    affiliate_link: string | null
    affiliate_link_key: string | null
    product_id: number | null
    pipeline_id: number | null
    instagram_scope_identifier: string | null
    _count: Affiliate_BusinessCountAggregateOutputType | null
    _avg: Affiliate_BusinessAvgAggregateOutputType | null
    _sum: Affiliate_BusinessSumAggregateOutputType | null
    _min: Affiliate_BusinessMinAggregateOutputType | null
    _max: Affiliate_BusinessMaxAggregateOutputType | null
  }

  type GetAffiliate_BusinessGroupByPayload<T extends Affiliate_BusinessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Affiliate_BusinessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Affiliate_BusinessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Affiliate_BusinessGroupByOutputType[P]>
            : GetScalarType<T[P], Affiliate_BusinessGroupByOutputType[P]>
        }
      >
    >


  export type Affiliate_BusinessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    business_id?: boolean
    affiliate_id?: boolean
    affiliate_link?: boolean
    affiliate_link_key?: boolean
    product_id?: boolean
    pipeline_id?: boolean
    instagram_scope_identifier?: boolean
    ig_scope_identifier?: boolean | Affiliate_Business$ig_scope_identifierArgs<ExtArgs>
    affiliate?: boolean | AffiliatesDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    products?: boolean | Affiliate_Business$productsArgs<ExtArgs>
    pipelines?: boolean | Affiliate_Business$pipelinesArgs<ExtArgs>
  }, ExtArgs["result"]["affiliate_Business"]>

  export type Affiliate_BusinessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    business_id?: boolean
    affiliate_id?: boolean
    affiliate_link?: boolean
    affiliate_link_key?: boolean
    product_id?: boolean
    pipeline_id?: boolean
    instagram_scope_identifier?: boolean
    ig_scope_identifier?: boolean | Affiliate_Business$ig_scope_identifierArgs<ExtArgs>
    affiliate?: boolean | AffiliatesDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    products?: boolean | Affiliate_Business$productsArgs<ExtArgs>
    pipelines?: boolean | Affiliate_Business$pipelinesArgs<ExtArgs>
  }, ExtArgs["result"]["affiliate_Business"]>

  export type Affiliate_BusinessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    business_id?: boolean
    affiliate_id?: boolean
    affiliate_link?: boolean
    affiliate_link_key?: boolean
    product_id?: boolean
    pipeline_id?: boolean
    instagram_scope_identifier?: boolean
    ig_scope_identifier?: boolean | Affiliate_Business$ig_scope_identifierArgs<ExtArgs>
    affiliate?: boolean | AffiliatesDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    products?: boolean | Affiliate_Business$productsArgs<ExtArgs>
    pipelines?: boolean | Affiliate_Business$pipelinesArgs<ExtArgs>
  }, ExtArgs["result"]["affiliate_Business"]>

  export type Affiliate_BusinessSelectScalar = {
    id?: boolean
    business_id?: boolean
    affiliate_id?: boolean
    affiliate_link?: boolean
    affiliate_link_key?: boolean
    product_id?: boolean
    pipeline_id?: boolean
    instagram_scope_identifier?: boolean
  }

  export type Affiliate_BusinessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "business_id" | "affiliate_id" | "affiliate_link" | "affiliate_link_key" | "product_id" | "pipeline_id" | "instagram_scope_identifier", ExtArgs["result"]["affiliate_Business"]>
  export type Affiliate_BusinessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ig_scope_identifier?: boolean | Affiliate_Business$ig_scope_identifierArgs<ExtArgs>
    affiliate?: boolean | AffiliatesDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    products?: boolean | Affiliate_Business$productsArgs<ExtArgs>
    pipelines?: boolean | Affiliate_Business$pipelinesArgs<ExtArgs>
  }
  export type Affiliate_BusinessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ig_scope_identifier?: boolean | Affiliate_Business$ig_scope_identifierArgs<ExtArgs>
    affiliate?: boolean | AffiliatesDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    products?: boolean | Affiliate_Business$productsArgs<ExtArgs>
    pipelines?: boolean | Affiliate_Business$pipelinesArgs<ExtArgs>
  }
  export type Affiliate_BusinessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ig_scope_identifier?: boolean | Affiliate_Business$ig_scope_identifierArgs<ExtArgs>
    affiliate?: boolean | AffiliatesDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    products?: boolean | Affiliate_Business$productsArgs<ExtArgs>
    pipelines?: boolean | Affiliate_Business$pipelinesArgs<ExtArgs>
  }

  export type $Affiliate_BusinessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Affiliate_Business"
    objects: {
      ig_scope_identifier: Prisma.$ig_scope_identifiersPayload<ExtArgs> | null
      affiliate: Prisma.$AffiliatesPayload<ExtArgs>
      business: Prisma.$BusinessPayload<ExtArgs>
      products: Prisma.$ProductsPayload<ExtArgs> | null
      pipelines: Prisma.$PipelinesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      business_id: string
      affiliate_id: number
      affiliate_link: string | null
      affiliate_link_key: string | null
      product_id: number | null
      pipeline_id: number | null
      instagram_scope_identifier: string | null
    }, ExtArgs["result"]["affiliate_Business"]>
    composites: {}
  }

  type Affiliate_BusinessGetPayload<S extends boolean | null | undefined | Affiliate_BusinessDefaultArgs> = $Result.GetResult<Prisma.$Affiliate_BusinessPayload, S>

  type Affiliate_BusinessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Affiliate_BusinessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Affiliate_BusinessCountAggregateInputType | true
    }

  export interface Affiliate_BusinessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Affiliate_Business'], meta: { name: 'Affiliate_Business' } }
    /**
     * Find zero or one Affiliate_Business that matches the filter.
     * @param {Affiliate_BusinessFindUniqueArgs} args - Arguments to find a Affiliate_Business
     * @example
     * // Get one Affiliate_Business
     * const affiliate_Business = await prisma.affiliate_Business.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Affiliate_BusinessFindUniqueArgs>(args: SelectSubset<T, Affiliate_BusinessFindUniqueArgs<ExtArgs>>): Prisma__Affiliate_BusinessClient<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Affiliate_Business that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Affiliate_BusinessFindUniqueOrThrowArgs} args - Arguments to find a Affiliate_Business
     * @example
     * // Get one Affiliate_Business
     * const affiliate_Business = await prisma.affiliate_Business.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Affiliate_BusinessFindUniqueOrThrowArgs>(args: SelectSubset<T, Affiliate_BusinessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Affiliate_BusinessClient<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Affiliate_Business that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_BusinessFindFirstArgs} args - Arguments to find a Affiliate_Business
     * @example
     * // Get one Affiliate_Business
     * const affiliate_Business = await prisma.affiliate_Business.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Affiliate_BusinessFindFirstArgs>(args?: SelectSubset<T, Affiliate_BusinessFindFirstArgs<ExtArgs>>): Prisma__Affiliate_BusinessClient<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Affiliate_Business that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_BusinessFindFirstOrThrowArgs} args - Arguments to find a Affiliate_Business
     * @example
     * // Get one Affiliate_Business
     * const affiliate_Business = await prisma.affiliate_Business.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Affiliate_BusinessFindFirstOrThrowArgs>(args?: SelectSubset<T, Affiliate_BusinessFindFirstOrThrowArgs<ExtArgs>>): Prisma__Affiliate_BusinessClient<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Affiliate_Businesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_BusinessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Affiliate_Businesses
     * const affiliate_Businesses = await prisma.affiliate_Business.findMany()
     * 
     * // Get first 10 Affiliate_Businesses
     * const affiliate_Businesses = await prisma.affiliate_Business.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliate_BusinessWithIdOnly = await prisma.affiliate_Business.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Affiliate_BusinessFindManyArgs>(args?: SelectSubset<T, Affiliate_BusinessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Affiliate_Business.
     * @param {Affiliate_BusinessCreateArgs} args - Arguments to create a Affiliate_Business.
     * @example
     * // Create one Affiliate_Business
     * const Affiliate_Business = await prisma.affiliate_Business.create({
     *   data: {
     *     // ... data to create a Affiliate_Business
     *   }
     * })
     * 
     */
    create<T extends Affiliate_BusinessCreateArgs>(args: SelectSubset<T, Affiliate_BusinessCreateArgs<ExtArgs>>): Prisma__Affiliate_BusinessClient<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Affiliate_Businesses.
     * @param {Affiliate_BusinessCreateManyArgs} args - Arguments to create many Affiliate_Businesses.
     * @example
     * // Create many Affiliate_Businesses
     * const affiliate_Business = await prisma.affiliate_Business.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Affiliate_BusinessCreateManyArgs>(args?: SelectSubset<T, Affiliate_BusinessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Affiliate_Businesses and returns the data saved in the database.
     * @param {Affiliate_BusinessCreateManyAndReturnArgs} args - Arguments to create many Affiliate_Businesses.
     * @example
     * // Create many Affiliate_Businesses
     * const affiliate_Business = await prisma.affiliate_Business.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Affiliate_Businesses and only return the `id`
     * const affiliate_BusinessWithIdOnly = await prisma.affiliate_Business.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Affiliate_BusinessCreateManyAndReturnArgs>(args?: SelectSubset<T, Affiliate_BusinessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Affiliate_Business.
     * @param {Affiliate_BusinessDeleteArgs} args - Arguments to delete one Affiliate_Business.
     * @example
     * // Delete one Affiliate_Business
     * const Affiliate_Business = await prisma.affiliate_Business.delete({
     *   where: {
     *     // ... filter to delete one Affiliate_Business
     *   }
     * })
     * 
     */
    delete<T extends Affiliate_BusinessDeleteArgs>(args: SelectSubset<T, Affiliate_BusinessDeleteArgs<ExtArgs>>): Prisma__Affiliate_BusinessClient<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Affiliate_Business.
     * @param {Affiliate_BusinessUpdateArgs} args - Arguments to update one Affiliate_Business.
     * @example
     * // Update one Affiliate_Business
     * const affiliate_Business = await prisma.affiliate_Business.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Affiliate_BusinessUpdateArgs>(args: SelectSubset<T, Affiliate_BusinessUpdateArgs<ExtArgs>>): Prisma__Affiliate_BusinessClient<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Affiliate_Businesses.
     * @param {Affiliate_BusinessDeleteManyArgs} args - Arguments to filter Affiliate_Businesses to delete.
     * @example
     * // Delete a few Affiliate_Businesses
     * const { count } = await prisma.affiliate_Business.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Affiliate_BusinessDeleteManyArgs>(args?: SelectSubset<T, Affiliate_BusinessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affiliate_Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_BusinessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Affiliate_Businesses
     * const affiliate_Business = await prisma.affiliate_Business.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Affiliate_BusinessUpdateManyArgs>(args: SelectSubset<T, Affiliate_BusinessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affiliate_Businesses and returns the data updated in the database.
     * @param {Affiliate_BusinessUpdateManyAndReturnArgs} args - Arguments to update many Affiliate_Businesses.
     * @example
     * // Update many Affiliate_Businesses
     * const affiliate_Business = await prisma.affiliate_Business.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Affiliate_Businesses and only return the `id`
     * const affiliate_BusinessWithIdOnly = await prisma.affiliate_Business.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Affiliate_BusinessUpdateManyAndReturnArgs>(args: SelectSubset<T, Affiliate_BusinessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Affiliate_Business.
     * @param {Affiliate_BusinessUpsertArgs} args - Arguments to update or create a Affiliate_Business.
     * @example
     * // Update or create a Affiliate_Business
     * const affiliate_Business = await prisma.affiliate_Business.upsert({
     *   create: {
     *     // ... data to create a Affiliate_Business
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Affiliate_Business we want to update
     *   }
     * })
     */
    upsert<T extends Affiliate_BusinessUpsertArgs>(args: SelectSubset<T, Affiliate_BusinessUpsertArgs<ExtArgs>>): Prisma__Affiliate_BusinessClient<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Affiliate_Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_BusinessCountArgs} args - Arguments to filter Affiliate_Businesses to count.
     * @example
     * // Count the number of Affiliate_Businesses
     * const count = await prisma.affiliate_Business.count({
     *   where: {
     *     // ... the filter for the Affiliate_Businesses we want to count
     *   }
     * })
    **/
    count<T extends Affiliate_BusinessCountArgs>(
      args?: Subset<T, Affiliate_BusinessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Affiliate_BusinessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Affiliate_Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_BusinessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Affiliate_BusinessAggregateArgs>(args: Subset<T, Affiliate_BusinessAggregateArgs>): Prisma.PrismaPromise<GetAffiliate_BusinessAggregateType<T>>

    /**
     * Group by Affiliate_Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_BusinessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Affiliate_BusinessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Affiliate_BusinessGroupByArgs['orderBy'] }
        : { orderBy?: Affiliate_BusinessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Affiliate_BusinessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliate_BusinessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Affiliate_Business model
   */
  readonly fields: Affiliate_BusinessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Affiliate_Business.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Affiliate_BusinessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ig_scope_identifier<T extends Affiliate_Business$ig_scope_identifierArgs<ExtArgs> = {}>(args?: Subset<T, Affiliate_Business$ig_scope_identifierArgs<ExtArgs>>): Prisma__ig_scope_identifiersClient<$Result.GetResult<Prisma.$ig_scope_identifiersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    affiliate<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    products<T extends Affiliate_Business$productsArgs<ExtArgs> = {}>(args?: Subset<T, Affiliate_Business$productsArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pipelines<T extends Affiliate_Business$pipelinesArgs<ExtArgs> = {}>(args?: Subset<T, Affiliate_Business$pipelinesArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Affiliate_Business model
   */
  interface Affiliate_BusinessFieldRefs {
    readonly id: FieldRef<"Affiliate_Business", 'String'>
    readonly business_id: FieldRef<"Affiliate_Business", 'String'>
    readonly affiliate_id: FieldRef<"Affiliate_Business", 'Int'>
    readonly affiliate_link: FieldRef<"Affiliate_Business", 'String'>
    readonly affiliate_link_key: FieldRef<"Affiliate_Business", 'String'>
    readonly product_id: FieldRef<"Affiliate_Business", 'Int'>
    readonly pipeline_id: FieldRef<"Affiliate_Business", 'Int'>
    readonly instagram_scope_identifier: FieldRef<"Affiliate_Business", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Affiliate_Business findUnique
   */
  export type Affiliate_BusinessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate_Business to fetch.
     */
    where: Affiliate_BusinessWhereUniqueInput
  }

  /**
   * Affiliate_Business findUniqueOrThrow
   */
  export type Affiliate_BusinessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate_Business to fetch.
     */
    where: Affiliate_BusinessWhereUniqueInput
  }

  /**
   * Affiliate_Business findFirst
   */
  export type Affiliate_BusinessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate_Business to fetch.
     */
    where?: Affiliate_BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliate_Businesses to fetch.
     */
    orderBy?: Affiliate_BusinessOrderByWithRelationInput | Affiliate_BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Affiliate_Businesses.
     */
    cursor?: Affiliate_BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliate_Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliate_Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Affiliate_Businesses.
     */
    distinct?: Affiliate_BusinessScalarFieldEnum | Affiliate_BusinessScalarFieldEnum[]
  }

  /**
   * Affiliate_Business findFirstOrThrow
   */
  export type Affiliate_BusinessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate_Business to fetch.
     */
    where?: Affiliate_BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliate_Businesses to fetch.
     */
    orderBy?: Affiliate_BusinessOrderByWithRelationInput | Affiliate_BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Affiliate_Businesses.
     */
    cursor?: Affiliate_BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliate_Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliate_Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Affiliate_Businesses.
     */
    distinct?: Affiliate_BusinessScalarFieldEnum | Affiliate_BusinessScalarFieldEnum[]
  }

  /**
   * Affiliate_Business findMany
   */
  export type Affiliate_BusinessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate_Businesses to fetch.
     */
    where?: Affiliate_BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliate_Businesses to fetch.
     */
    orderBy?: Affiliate_BusinessOrderByWithRelationInput | Affiliate_BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Affiliate_Businesses.
     */
    cursor?: Affiliate_BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliate_Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliate_Businesses.
     */
    skip?: number
    distinct?: Affiliate_BusinessScalarFieldEnum | Affiliate_BusinessScalarFieldEnum[]
  }

  /**
   * Affiliate_Business create
   */
  export type Affiliate_BusinessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    /**
     * The data needed to create a Affiliate_Business.
     */
    data: XOR<Affiliate_BusinessCreateInput, Affiliate_BusinessUncheckedCreateInput>
  }

  /**
   * Affiliate_Business createMany
   */
  export type Affiliate_BusinessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Affiliate_Businesses.
     */
    data: Affiliate_BusinessCreateManyInput | Affiliate_BusinessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Affiliate_Business createManyAndReturn
   */
  export type Affiliate_BusinessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * The data used to create many Affiliate_Businesses.
     */
    data: Affiliate_BusinessCreateManyInput | Affiliate_BusinessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Affiliate_Business update
   */
  export type Affiliate_BusinessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    /**
     * The data needed to update a Affiliate_Business.
     */
    data: XOR<Affiliate_BusinessUpdateInput, Affiliate_BusinessUncheckedUpdateInput>
    /**
     * Choose, which Affiliate_Business to update.
     */
    where: Affiliate_BusinessWhereUniqueInput
  }

  /**
   * Affiliate_Business updateMany
   */
  export type Affiliate_BusinessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Affiliate_Businesses.
     */
    data: XOR<Affiliate_BusinessUpdateManyMutationInput, Affiliate_BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Affiliate_Businesses to update
     */
    where?: Affiliate_BusinessWhereInput
    /**
     * Limit how many Affiliate_Businesses to update.
     */
    limit?: number
  }

  /**
   * Affiliate_Business updateManyAndReturn
   */
  export type Affiliate_BusinessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * The data used to update Affiliate_Businesses.
     */
    data: XOR<Affiliate_BusinessUpdateManyMutationInput, Affiliate_BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Affiliate_Businesses to update
     */
    where?: Affiliate_BusinessWhereInput
    /**
     * Limit how many Affiliate_Businesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Affiliate_Business upsert
   */
  export type Affiliate_BusinessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    /**
     * The filter to search for the Affiliate_Business to update in case it exists.
     */
    where: Affiliate_BusinessWhereUniqueInput
    /**
     * In case the Affiliate_Business found by the `where` argument doesn't exist, create a new Affiliate_Business with this data.
     */
    create: XOR<Affiliate_BusinessCreateInput, Affiliate_BusinessUncheckedCreateInput>
    /**
     * In case the Affiliate_Business was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Affiliate_BusinessUpdateInput, Affiliate_BusinessUncheckedUpdateInput>
  }

  /**
   * Affiliate_Business delete
   */
  export type Affiliate_BusinessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    /**
     * Filter which Affiliate_Business to delete.
     */
    where: Affiliate_BusinessWhereUniqueInput
  }

  /**
   * Affiliate_Business deleteMany
   */
  export type Affiliate_BusinessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Affiliate_Businesses to delete
     */
    where?: Affiliate_BusinessWhereInput
    /**
     * Limit how many Affiliate_Businesses to delete.
     */
    limit?: number
  }

  /**
   * Affiliate_Business.ig_scope_identifier
   */
  export type Affiliate_Business$ig_scope_identifierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ig_scope_identifiersInclude<ExtArgs> | null
    where?: ig_scope_identifiersWhereInput
  }

  /**
   * Affiliate_Business.products
   */
  export type Affiliate_Business$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
  }

  /**
   * Affiliate_Business.pipelines
   */
  export type Affiliate_Business$pipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    where?: PipelinesWhereInput
  }

  /**
   * Affiliate_Business without action
   */
  export type Affiliate_BusinessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
  }


  /**
   * Model Orders
   */

  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    order_quantity: number | null
    affiliate_id: number | null
    product_id: number | null
  }

  export type OrdersSumAggregateOutputType = {
    order_quantity: number | null
    affiliate_id: number | null
    product_id: number | null
  }

  export type OrdersMinAggregateOutputType = {
    id: string | null
    customer_name: string | null
    customer_email: string | null
    customer_address: string | null
    invoice_url: string | null
    order_quantity: number | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    business_id: string | null
    affiliate_id: number | null
    product_id: number | null
  }

  export type OrdersMaxAggregateOutputType = {
    id: string | null
    customer_name: string | null
    customer_email: string | null
    customer_address: string | null
    invoice_url: string | null
    order_quantity: number | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    business_id: string | null
    affiliate_id: number | null
    product_id: number | null
  }

  export type OrdersCountAggregateOutputType = {
    id: number
    customer_name: number
    customer_email: number
    customer_address: number
    invoice_url: number
    order_quantity: number
    status: number
    created_at: number
    updated_at: number
    business_id: number
    affiliate_id: number
    product_id: number
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    order_quantity?: true
    affiliate_id?: true
    product_id?: true
  }

  export type OrdersSumAggregateInputType = {
    order_quantity?: true
    affiliate_id?: true
    product_id?: true
  }

  export type OrdersMinAggregateInputType = {
    id?: true
    customer_name?: true
    customer_email?: true
    customer_address?: true
    invoice_url?: true
    order_quantity?: true
    status?: true
    created_at?: true
    updated_at?: true
    business_id?: true
    affiliate_id?: true
    product_id?: true
  }

  export type OrdersMaxAggregateInputType = {
    id?: true
    customer_name?: true
    customer_email?: true
    customer_address?: true
    invoice_url?: true
    order_quantity?: true
    status?: true
    created_at?: true
    updated_at?: true
    business_id?: true
    affiliate_id?: true
    product_id?: true
  }

  export type OrdersCountAggregateInputType = {
    id?: true
    customer_name?: true
    customer_email?: true
    customer_address?: true
    invoice_url?: true
    order_quantity?: true
    status?: true
    created_at?: true
    updated_at?: true
    business_id?: true
    affiliate_id?: true
    product_id?: true
    _all?: true
  }

  export type OrdersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to aggregate.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type OrdersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithAggregationInput | OrdersOrderByWithAggregationInput[]
    by: OrdersScalarFieldEnum[] | OrdersScalarFieldEnum
    having?: OrdersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _avg?: OrdersAvgAggregateInputType
    _sum?: OrdersSumAggregateInputType
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }

  export type OrdersGroupByOutputType = {
    id: string
    customer_name: string | null
    customer_email: string
    customer_address: string | null
    invoice_url: string | null
    order_quantity: number | null
    status: string | null
    created_at: Date
    updated_at: Date
    business_id: string | null
    affiliate_id: number | null
    product_id: number | null
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends OrdersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type OrdersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_name?: boolean
    customer_email?: boolean
    customer_address?: boolean
    invoice_url?: boolean
    order_quantity?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    business_id?: boolean
    affiliate_id?: boolean
    product_id?: boolean
    affiliate?: boolean | Orders$affiliateArgs<ExtArgs>
    business?: boolean | Orders$businessArgs<ExtArgs>
    products?: boolean | Orders$productsArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type OrdersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_name?: boolean
    customer_email?: boolean
    customer_address?: boolean
    invoice_url?: boolean
    order_quantity?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    business_id?: boolean
    affiliate_id?: boolean
    product_id?: boolean
    affiliate?: boolean | Orders$affiliateArgs<ExtArgs>
    business?: boolean | Orders$businessArgs<ExtArgs>
    products?: boolean | Orders$productsArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type OrdersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_name?: boolean
    customer_email?: boolean
    customer_address?: boolean
    invoice_url?: boolean
    order_quantity?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    business_id?: boolean
    affiliate_id?: boolean
    product_id?: boolean
    affiliate?: boolean | Orders$affiliateArgs<ExtArgs>
    business?: boolean | Orders$businessArgs<ExtArgs>
    products?: boolean | Orders$productsArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type OrdersSelectScalar = {
    id?: boolean
    customer_name?: boolean
    customer_email?: boolean
    customer_address?: boolean
    invoice_url?: boolean
    order_quantity?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    business_id?: boolean
    affiliate_id?: boolean
    product_id?: boolean
  }

  export type OrdersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_name" | "customer_email" | "customer_address" | "invoice_url" | "order_quantity" | "status" | "created_at" | "updated_at" | "business_id" | "affiliate_id" | "product_id", ExtArgs["result"]["orders"]>
  export type OrdersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | Orders$affiliateArgs<ExtArgs>
    business?: boolean | Orders$businessArgs<ExtArgs>
    products?: boolean | Orders$productsArgs<ExtArgs>
  }
  export type OrdersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | Orders$affiliateArgs<ExtArgs>
    business?: boolean | Orders$businessArgs<ExtArgs>
    products?: boolean | Orders$productsArgs<ExtArgs>
  }
  export type OrdersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | Orders$affiliateArgs<ExtArgs>
    business?: boolean | Orders$businessArgs<ExtArgs>
    products?: boolean | Orders$productsArgs<ExtArgs>
  }

  export type $OrdersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Orders"
    objects: {
      affiliate: Prisma.$AffiliatesPayload<ExtArgs> | null
      business: Prisma.$BusinessPayload<ExtArgs> | null
      products: Prisma.$ProductsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_name: string | null
      customer_email: string
      customer_address: string | null
      invoice_url: string | null
      order_quantity: number | null
      status: string | null
      created_at: Date
      updated_at: Date
      business_id: string | null
      affiliate_id: number | null
      product_id: number | null
    }, ExtArgs["result"]["orders"]>
    composites: {}
  }

  type OrdersGetPayload<S extends boolean | null | undefined | OrdersDefaultArgs> = $Result.GetResult<Prisma.$OrdersPayload, S>

  type OrdersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrdersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrdersCountAggregateInputType | true
    }

  export interface OrdersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Orders'], meta: { name: 'Orders' } }
    /**
     * Find zero or one Orders that matches the filter.
     * @param {OrdersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrdersFindUniqueArgs>(args: SelectSubset<T, OrdersFindUniqueArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Orders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrdersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrdersFindUniqueOrThrowArgs>(args: SelectSubset<T, OrdersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrdersFindFirstArgs>(args?: SelectSubset<T, OrdersFindFirstArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrdersFindFirstOrThrowArgs>(args?: SelectSubset<T, OrdersFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordersWithIdOnly = await prisma.orders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrdersFindManyArgs>(args?: SelectSubset<T, OrdersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Orders.
     * @param {OrdersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
     */
    create<T extends OrdersCreateArgs>(args: SelectSubset<T, OrdersCreateArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrdersCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrdersCreateManyArgs>(args?: SelectSubset<T, OrdersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrdersCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const ordersWithIdOnly = await prisma.orders.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrdersCreateManyAndReturnArgs>(args?: SelectSubset<T, OrdersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Orders.
     * @param {OrdersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
     */
    delete<T extends OrdersDeleteArgs>(args: SelectSubset<T, OrdersDeleteArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Orders.
     * @param {OrdersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrdersUpdateArgs>(args: SelectSubset<T, OrdersUpdateArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrdersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrdersDeleteManyArgs>(args?: SelectSubset<T, OrdersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrdersUpdateManyArgs>(args: SelectSubset<T, OrdersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrdersUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const ordersWithIdOnly = await prisma.orders.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrdersUpdateManyAndReturnArgs>(args: SelectSubset<T, OrdersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Orders.
     * @param {OrdersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
     */
    upsert<T extends OrdersUpsertArgs>(args: SelectSubset<T, OrdersUpsertArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrdersCountArgs>(
      args?: Subset<T, OrdersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): Prisma.PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdersGroupByArgs['orderBy'] }
        : { orderBy?: OrdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Orders model
   */
  readonly fields: OrdersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate<T extends Orders$affiliateArgs<ExtArgs> = {}>(args?: Subset<T, Orders$affiliateArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    business<T extends Orders$businessArgs<ExtArgs> = {}>(args?: Subset<T, Orders$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends Orders$productsArgs<ExtArgs> = {}>(args?: Subset<T, Orders$productsArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Orders model
   */
  interface OrdersFieldRefs {
    readonly id: FieldRef<"Orders", 'String'>
    readonly customer_name: FieldRef<"Orders", 'String'>
    readonly customer_email: FieldRef<"Orders", 'String'>
    readonly customer_address: FieldRef<"Orders", 'String'>
    readonly invoice_url: FieldRef<"Orders", 'String'>
    readonly order_quantity: FieldRef<"Orders", 'Int'>
    readonly status: FieldRef<"Orders", 'String'>
    readonly created_at: FieldRef<"Orders", 'DateTime'>
    readonly updated_at: FieldRef<"Orders", 'DateTime'>
    readonly business_id: FieldRef<"Orders", 'String'>
    readonly affiliate_id: FieldRef<"Orders", 'Int'>
    readonly product_id: FieldRef<"Orders", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Orders findUnique
   */
  export type OrdersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders findUniqueOrThrow
   */
  export type OrdersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders findFirst
   */
  export type OrdersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Orders findFirstOrThrow
   */
  export type OrdersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Orders findMany
   */
  export type OrdersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Orders create
   */
  export type OrdersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The data needed to create a Orders.
     */
    data: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
  }

  /**
   * Orders createMany
   */
  export type OrdersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrdersCreateManyInput | OrdersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Orders createManyAndReturn
   */
  export type OrdersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrdersCreateManyInput | OrdersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Orders update
   */
  export type OrdersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The data needed to update a Orders.
     */
    data: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
    /**
     * Choose, which Orders to update.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders updateMany
   */
  export type OrdersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrdersWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Orders updateManyAndReturn
   */
  export type OrdersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrdersWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Orders upsert
   */
  export type OrdersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The filter to search for the Orders to update in case it exists.
     */
    where: OrdersWhereUniqueInput
    /**
     * In case the Orders found by the `where` argument doesn't exist, create a new Orders with this data.
     */
    create: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
    /**
     * In case the Orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
  }

  /**
   * Orders delete
   */
  export type OrdersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter which Orders to delete.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders deleteMany
   */
  export type OrdersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrdersWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Orders.affiliate
   */
  export type Orders$affiliateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliates
     */
    omit?: AffiliatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    where?: AffiliatesWhereInput
  }

  /**
   * Orders.business
   */
  export type Orders$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * Orders.products
   */
  export type Orders$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
  }

  /**
   * Orders without action
   */
  export type OrdersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
  }


  /**
   * Model Products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    price: number | null
    id: number | null
  }

  export type ProductsSumAggregateOutputType = {
    price: number | null
    id: number | null
  }

  export type ProductsMinAggregateOutputType = {
    name: string | null
    description: string | null
    html_description: string | null
    image_url: string | null
    price: number | null
    price_currency: string | null
    is_shippable: boolean | null
    price_type: $Enums.PriceType | null
    created_at: Date | null
    updated_at: Date | null
    status: string | null
    business_id: string | null
    id: number | null
  }

  export type ProductsMaxAggregateOutputType = {
    name: string | null
    description: string | null
    html_description: string | null
    image_url: string | null
    price: number | null
    price_currency: string | null
    is_shippable: boolean | null
    price_type: $Enums.PriceType | null
    created_at: Date | null
    updated_at: Date | null
    status: string | null
    business_id: string | null
    id: number | null
  }

  export type ProductsCountAggregateOutputType = {
    name: number
    description: number
    html_description: number
    image_url: number
    price: number
    price_currency: number
    is_shippable: number
    price_type: number
    created_at: number
    updated_at: number
    status: number
    business_id: number
    metadata: number
    id: number
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    price?: true
    id?: true
  }

  export type ProductsSumAggregateInputType = {
    price?: true
    id?: true
  }

  export type ProductsMinAggregateInputType = {
    name?: true
    description?: true
    html_description?: true
    image_url?: true
    price?: true
    price_currency?: true
    is_shippable?: true
    price_type?: true
    created_at?: true
    updated_at?: true
    status?: true
    business_id?: true
    id?: true
  }

  export type ProductsMaxAggregateInputType = {
    name?: true
    description?: true
    html_description?: true
    image_url?: true
    price?: true
    price_currency?: true
    is_shippable?: true
    price_type?: true
    created_at?: true
    updated_at?: true
    status?: true
    business_id?: true
    id?: true
  }

  export type ProductsCountAggregateInputType = {
    name?: true
    description?: true
    html_description?: true
    image_url?: true
    price?: true
    price_currency?: true
    is_shippable?: true
    price_type?: true
    created_at?: true
    updated_at?: true
    status?: true
    business_id?: true
    metadata?: true
    id?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to aggregate.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type ProductsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithAggregationInput | ProductsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: ProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _avg?: ProductsAvgAggregateInputType
    _sum?: ProductsSumAggregateInputType
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    name: string
    description: string
    html_description: string | null
    image_url: string | null
    price: number
    price_currency: string | null
    is_shippable: boolean | null
    price_type: $Enums.PriceType | null
    created_at: Date
    updated_at: Date
    status: string
    business_id: string | null
    metadata: JsonValue | null
    id: number
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends ProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type ProductsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    html_description?: boolean
    image_url?: boolean
    price?: boolean
    price_currency?: boolean
    is_shippable?: boolean
    price_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    business_id?: boolean
    metadata?: boolean
    id?: boolean
    affiliate_business?: boolean | Products$affiliate_businessArgs<ExtArgs>
    orders?: boolean | Products$ordersArgs<ExtArgs>
    pipelines?: boolean | Products$pipelinesArgs<ExtArgs>
    business?: boolean | Products$businessArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type ProductsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    html_description?: boolean
    image_url?: boolean
    price?: boolean
    price_currency?: boolean
    is_shippable?: boolean
    price_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    business_id?: boolean
    metadata?: boolean
    id?: boolean
    business?: boolean | Products$businessArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type ProductsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    html_description?: boolean
    image_url?: boolean
    price?: boolean
    price_currency?: boolean
    is_shippable?: boolean
    price_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    business_id?: boolean
    metadata?: boolean
    id?: boolean
    business?: boolean | Products$businessArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type ProductsSelectScalar = {
    name?: boolean
    description?: boolean
    html_description?: boolean
    image_url?: boolean
    price?: boolean
    price_currency?: boolean
    is_shippable?: boolean
    price_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    business_id?: boolean
    metadata?: boolean
    id?: boolean
  }

  export type ProductsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "html_description" | "image_url" | "price" | "price_currency" | "is_shippable" | "price_type" | "created_at" | "updated_at" | "status" | "business_id" | "metadata" | "id", ExtArgs["result"]["products"]>
  export type ProductsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_business?: boolean | Products$affiliate_businessArgs<ExtArgs>
    orders?: boolean | Products$ordersArgs<ExtArgs>
    pipelines?: boolean | Products$pipelinesArgs<ExtArgs>
    business?: boolean | Products$businessArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | Products$businessArgs<ExtArgs>
  }
  export type ProductsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | Products$businessArgs<ExtArgs>
  }

  export type $ProductsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Products"
    objects: {
      affiliate_business: Prisma.$Affiliate_BusinessPayload<ExtArgs>[]
      orders: Prisma.$OrdersPayload<ExtArgs>[]
      pipelines: Prisma.$PipelinesPayload<ExtArgs>[]
      business: Prisma.$BusinessPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      description: string
      html_description: string | null
      image_url: string | null
      price: number
      price_currency: string | null
      is_shippable: boolean | null
      price_type: $Enums.PriceType | null
      created_at: Date
      updated_at: Date
      status: string
      business_id: string | null
      metadata: Prisma.JsonValue | null
      id: number
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type ProductsGetPayload<S extends boolean | null | undefined | ProductsDefaultArgs> = $Result.GetResult<Prisma.$ProductsPayload, S>

  type ProductsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface ProductsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Products'], meta: { name: 'Products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {ProductsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductsFindUniqueArgs>(args: SelectSubset<T, ProductsFindUniqueArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductsFindFirstArgs>(args?: SelectSubset<T, ProductsFindFirstArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const productsWithNameOnly = await prisma.products.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends ProductsFindManyArgs>(args?: SelectSubset<T, ProductsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Products.
     * @param {ProductsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends ProductsCreateArgs>(args: SelectSubset<T, ProductsCreateArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductsCreateManyArgs>(args?: SelectSubset<T, ProductsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductsCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `name`
     * const productsWithNameOnly = await prisma.products.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductsCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Products.
     * @param {ProductsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends ProductsDeleteArgs>(args: SelectSubset<T, ProductsDeleteArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Products.
     * @param {ProductsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductsUpdateArgs>(args: SelectSubset<T, ProductsUpdateArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductsDeleteManyArgs>(args?: SelectSubset<T, ProductsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductsUpdateManyArgs>(args: SelectSubset<T, ProductsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductsUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `name`
     * const productsWithNameOnly = await prisma.products.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductsUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Products.
     * @param {ProductsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends ProductsUpsertArgs>(args: SelectSubset<T, ProductsUpsertArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductsCountArgs>(
      args?: Subset<T, ProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductsGroupByArgs['orderBy'] }
        : { orderBy?: ProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Products model
   */
  readonly fields: ProductsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate_business<T extends Products$affiliate_businessArgs<ExtArgs> = {}>(args?: Subset<T, Products$affiliate_businessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Products$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Products$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pipelines<T extends Products$pipelinesArgs<ExtArgs> = {}>(args?: Subset<T, Products$pipelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    business<T extends Products$businessArgs<ExtArgs> = {}>(args?: Subset<T, Products$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Products model
   */
  interface ProductsFieldRefs {
    readonly name: FieldRef<"Products", 'String'>
    readonly description: FieldRef<"Products", 'String'>
    readonly html_description: FieldRef<"Products", 'String'>
    readonly image_url: FieldRef<"Products", 'String'>
    readonly price: FieldRef<"Products", 'Float'>
    readonly price_currency: FieldRef<"Products", 'String'>
    readonly is_shippable: FieldRef<"Products", 'Boolean'>
    readonly price_type: FieldRef<"Products", 'PriceType'>
    readonly created_at: FieldRef<"Products", 'DateTime'>
    readonly updated_at: FieldRef<"Products", 'DateTime'>
    readonly status: FieldRef<"Products", 'String'>
    readonly business_id: FieldRef<"Products", 'String'>
    readonly metadata: FieldRef<"Products", 'Json'>
    readonly id: FieldRef<"Products", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Products findUnique
   */
  export type ProductsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findUniqueOrThrow
   */
  export type ProductsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findFirst
   */
  export type ProductsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products findFirstOrThrow
   */
  export type ProductsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products findMany
   */
  export type ProductsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products create
   */
  export type ProductsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The data needed to create a Products.
     */
    data: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
  }

  /**
   * Products createMany
   */
  export type ProductsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductsCreateManyInput | ProductsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Products createManyAndReturn
   */
  export type ProductsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductsCreateManyInput | ProductsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Products update
   */
  export type ProductsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The data needed to update a Products.
     */
    data: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
    /**
     * Choose, which Products to update.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products updateMany
   */
  export type ProductsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductsWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Products updateManyAndReturn
   */
  export type ProductsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductsWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Products upsert
   */
  export type ProductsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The filter to search for the Products to update in case it exists.
     */
    where: ProductsWhereUniqueInput
    /**
     * In case the Products found by the `where` argument doesn't exist, create a new Products with this data.
     */
    create: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
    /**
     * In case the Products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
  }

  /**
   * Products delete
   */
  export type ProductsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter which Products to delete.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products deleteMany
   */
  export type ProductsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductsWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Products.affiliate_business
   */
  export type Products$affiliate_businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    where?: Affiliate_BusinessWhereInput
    orderBy?: Affiliate_BusinessOrderByWithRelationInput | Affiliate_BusinessOrderByWithRelationInput[]
    cursor?: Affiliate_BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Affiliate_BusinessScalarFieldEnum | Affiliate_BusinessScalarFieldEnum[]
  }

  /**
   * Products.orders
   */
  export type Products$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Products.pipelines
   */
  export type Products$pipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    where?: PipelinesWhereInput
    orderBy?: PipelinesOrderByWithRelationInput | PipelinesOrderByWithRelationInput[]
    cursor?: PipelinesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelinesScalarFieldEnum | PipelinesScalarFieldEnum[]
  }

  /**
   * Products.business
   */
  export type Products$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * Products without action
   */
  export type ProductsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
  }


  /**
   * Model Pipelines
   */

  export type AggregatePipelines = {
    _count: PipelinesCountAggregateOutputType | null
    _avg: PipelinesAvgAggregateOutputType | null
    _sum: PipelinesSumAggregateOutputType | null
    _min: PipelinesMinAggregateOutputType | null
    _max: PipelinesMaxAggregateOutputType | null
  }

  export type PipelinesAvgAggregateOutputType = {
    id: number | null
    affiliate_count: number | null
    product_id: number | null
  }

  export type PipelinesSumAggregateOutputType = {
    id: number | null
    affiliate_count: number | null
    product_id: number | null
  }

  export type PipelinesMinAggregateOutputType = {
    id: number | null
    prompt: string | null
    remark: string | null
    status: string | null
    affiliate_count: number | null
    business_id: string | null
    product_id: number | null
    format: string | null
    location: string | null
    heygen_video_id: string | null
    ig_post_id: string | null
    ig_post_url: string | null
    run_mode: $Enums.RunMode | null
    workflow: string | null
    created_at: Date | null
  }

  export type PipelinesMaxAggregateOutputType = {
    id: number | null
    prompt: string | null
    remark: string | null
    status: string | null
    affiliate_count: number | null
    business_id: string | null
    product_id: number | null
    format: string | null
    location: string | null
    heygen_video_id: string | null
    ig_post_id: string | null
    ig_post_url: string | null
    run_mode: $Enums.RunMode | null
    workflow: string | null
    created_at: Date | null
  }

  export type PipelinesCountAggregateOutputType = {
    id: number
    prompt: number
    remark: number
    status: number
    affiliate_count: number
    business_id: number
    product_id: number
    format: number
    location: number
    heygen_video_id: number
    ig_post_id: number
    ig_post_url: number
    run_mode: number
    workflow: number
    created_at: number
    _all: number
  }


  export type PipelinesAvgAggregateInputType = {
    id?: true
    affiliate_count?: true
    product_id?: true
  }

  export type PipelinesSumAggregateInputType = {
    id?: true
    affiliate_count?: true
    product_id?: true
  }

  export type PipelinesMinAggregateInputType = {
    id?: true
    prompt?: true
    remark?: true
    status?: true
    affiliate_count?: true
    business_id?: true
    product_id?: true
    format?: true
    location?: true
    heygen_video_id?: true
    ig_post_id?: true
    ig_post_url?: true
    run_mode?: true
    workflow?: true
    created_at?: true
  }

  export type PipelinesMaxAggregateInputType = {
    id?: true
    prompt?: true
    remark?: true
    status?: true
    affiliate_count?: true
    business_id?: true
    product_id?: true
    format?: true
    location?: true
    heygen_video_id?: true
    ig_post_id?: true
    ig_post_url?: true
    run_mode?: true
    workflow?: true
    created_at?: true
  }

  export type PipelinesCountAggregateInputType = {
    id?: true
    prompt?: true
    remark?: true
    status?: true
    affiliate_count?: true
    business_id?: true
    product_id?: true
    format?: true
    location?: true
    heygen_video_id?: true
    ig_post_id?: true
    ig_post_url?: true
    run_mode?: true
    workflow?: true
    created_at?: true
    _all?: true
  }

  export type PipelinesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipelines to aggregate.
     */
    where?: PipelinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelinesOrderByWithRelationInput | PipelinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PipelinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pipelines
    **/
    _count?: true | PipelinesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PipelinesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PipelinesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PipelinesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PipelinesMaxAggregateInputType
  }

  export type GetPipelinesAggregateType<T extends PipelinesAggregateArgs> = {
        [P in keyof T & keyof AggregatePipelines]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePipelines[P]>
      : GetScalarType<T[P], AggregatePipelines[P]>
  }




  export type PipelinesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelinesWhereInput
    orderBy?: PipelinesOrderByWithAggregationInput | PipelinesOrderByWithAggregationInput[]
    by: PipelinesScalarFieldEnum[] | PipelinesScalarFieldEnum
    having?: PipelinesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PipelinesCountAggregateInputType | true
    _avg?: PipelinesAvgAggregateInputType
    _sum?: PipelinesSumAggregateInputType
    _min?: PipelinesMinAggregateInputType
    _max?: PipelinesMaxAggregateInputType
  }

  export type PipelinesGroupByOutputType = {
    id: number
    prompt: string | null
    remark: string | null
    status: string
    affiliate_count: number | null
    business_id: string | null
    product_id: number | null
    format: string | null
    location: string | null
    heygen_video_id: string | null
    ig_post_id: string | null
    ig_post_url: string | null
    run_mode: $Enums.RunMode | null
    workflow: string | null
    created_at: Date
    _count: PipelinesCountAggregateOutputType | null
    _avg: PipelinesAvgAggregateOutputType | null
    _sum: PipelinesSumAggregateOutputType | null
    _min: PipelinesMinAggregateOutputType | null
    _max: PipelinesMaxAggregateOutputType | null
  }

  type GetPipelinesGroupByPayload<T extends PipelinesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PipelinesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PipelinesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PipelinesGroupByOutputType[P]>
            : GetScalarType<T[P], PipelinesGroupByOutputType[P]>
        }
      >
    >


  export type PipelinesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    remark?: boolean
    status?: boolean
    affiliate_count?: boolean
    business_id?: boolean
    product_id?: boolean
    format?: boolean
    location?: boolean
    heygen_video_id?: boolean
    ig_post_id?: boolean
    ig_post_url?: boolean
    run_mode?: boolean
    workflow?: boolean
    created_at?: boolean
    business?: boolean | Pipelines$businessArgs<ExtArgs>
    products?: boolean | Pipelines$productsArgs<ExtArgs>
    affiliate_business?: boolean | Pipelines$affiliate_businessArgs<ExtArgs>
    ChatMessage?: boolean | Pipelines$ChatMessageArgs<ExtArgs>
    _count?: boolean | PipelinesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipelines"]>

  export type PipelinesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    remark?: boolean
    status?: boolean
    affiliate_count?: boolean
    business_id?: boolean
    product_id?: boolean
    format?: boolean
    location?: boolean
    heygen_video_id?: boolean
    ig_post_id?: boolean
    ig_post_url?: boolean
    run_mode?: boolean
    workflow?: boolean
    created_at?: boolean
    business?: boolean | Pipelines$businessArgs<ExtArgs>
    products?: boolean | Pipelines$productsArgs<ExtArgs>
  }, ExtArgs["result"]["pipelines"]>

  export type PipelinesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    remark?: boolean
    status?: boolean
    affiliate_count?: boolean
    business_id?: boolean
    product_id?: boolean
    format?: boolean
    location?: boolean
    heygen_video_id?: boolean
    ig_post_id?: boolean
    ig_post_url?: boolean
    run_mode?: boolean
    workflow?: boolean
    created_at?: boolean
    business?: boolean | Pipelines$businessArgs<ExtArgs>
    products?: boolean | Pipelines$productsArgs<ExtArgs>
  }, ExtArgs["result"]["pipelines"]>

  export type PipelinesSelectScalar = {
    id?: boolean
    prompt?: boolean
    remark?: boolean
    status?: boolean
    affiliate_count?: boolean
    business_id?: boolean
    product_id?: boolean
    format?: boolean
    location?: boolean
    heygen_video_id?: boolean
    ig_post_id?: boolean
    ig_post_url?: boolean
    run_mode?: boolean
    workflow?: boolean
    created_at?: boolean
  }

  export type PipelinesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prompt" | "remark" | "status" | "affiliate_count" | "business_id" | "product_id" | "format" | "location" | "heygen_video_id" | "ig_post_id" | "ig_post_url" | "run_mode" | "workflow" | "created_at", ExtArgs["result"]["pipelines"]>
  export type PipelinesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | Pipelines$businessArgs<ExtArgs>
    products?: boolean | Pipelines$productsArgs<ExtArgs>
    affiliate_business?: boolean | Pipelines$affiliate_businessArgs<ExtArgs>
    ChatMessage?: boolean | Pipelines$ChatMessageArgs<ExtArgs>
    _count?: boolean | PipelinesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PipelinesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | Pipelines$businessArgs<ExtArgs>
    products?: boolean | Pipelines$productsArgs<ExtArgs>
  }
  export type PipelinesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | Pipelines$businessArgs<ExtArgs>
    products?: boolean | Pipelines$productsArgs<ExtArgs>
  }

  export type $PipelinesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pipelines"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs> | null
      products: Prisma.$ProductsPayload<ExtArgs> | null
      affiliate_business: Prisma.$Affiliate_BusinessPayload<ExtArgs>[]
      ChatMessage: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      prompt: string | null
      remark: string | null
      status: string
      affiliate_count: number | null
      business_id: string | null
      product_id: number | null
      format: string | null
      location: string | null
      heygen_video_id: string | null
      ig_post_id: string | null
      ig_post_url: string | null
      run_mode: $Enums.RunMode | null
      workflow: string | null
      created_at: Date
    }, ExtArgs["result"]["pipelines"]>
    composites: {}
  }

  type PipelinesGetPayload<S extends boolean | null | undefined | PipelinesDefaultArgs> = $Result.GetResult<Prisma.$PipelinesPayload, S>

  type PipelinesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PipelinesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PipelinesCountAggregateInputType | true
    }

  export interface PipelinesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pipelines'], meta: { name: 'Pipelines' } }
    /**
     * Find zero or one Pipelines that matches the filter.
     * @param {PipelinesFindUniqueArgs} args - Arguments to find a Pipelines
     * @example
     * // Get one Pipelines
     * const pipelines = await prisma.pipelines.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PipelinesFindUniqueArgs>(args: SelectSubset<T, PipelinesFindUniqueArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pipelines that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PipelinesFindUniqueOrThrowArgs} args - Arguments to find a Pipelines
     * @example
     * // Get one Pipelines
     * const pipelines = await prisma.pipelines.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PipelinesFindUniqueOrThrowArgs>(args: SelectSubset<T, PipelinesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesFindFirstArgs} args - Arguments to find a Pipelines
     * @example
     * // Get one Pipelines
     * const pipelines = await prisma.pipelines.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PipelinesFindFirstArgs>(args?: SelectSubset<T, PipelinesFindFirstArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipelines that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesFindFirstOrThrowArgs} args - Arguments to find a Pipelines
     * @example
     * // Get one Pipelines
     * const pipelines = await prisma.pipelines.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PipelinesFindFirstOrThrowArgs>(args?: SelectSubset<T, PipelinesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pipelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pipelines
     * const pipelines = await prisma.pipelines.findMany()
     * 
     * // Get first 10 Pipelines
     * const pipelines = await prisma.pipelines.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pipelinesWithIdOnly = await prisma.pipelines.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PipelinesFindManyArgs>(args?: SelectSubset<T, PipelinesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pipelines.
     * @param {PipelinesCreateArgs} args - Arguments to create a Pipelines.
     * @example
     * // Create one Pipelines
     * const Pipelines = await prisma.pipelines.create({
     *   data: {
     *     // ... data to create a Pipelines
     *   }
     * })
     * 
     */
    create<T extends PipelinesCreateArgs>(args: SelectSubset<T, PipelinesCreateArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pipelines.
     * @param {PipelinesCreateManyArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipelines = await prisma.pipelines.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PipelinesCreateManyArgs>(args?: SelectSubset<T, PipelinesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pipelines and returns the data saved in the database.
     * @param {PipelinesCreateManyAndReturnArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipelines = await prisma.pipelines.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pipelines and only return the `id`
     * const pipelinesWithIdOnly = await prisma.pipelines.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PipelinesCreateManyAndReturnArgs>(args?: SelectSubset<T, PipelinesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pipelines.
     * @param {PipelinesDeleteArgs} args - Arguments to delete one Pipelines.
     * @example
     * // Delete one Pipelines
     * const Pipelines = await prisma.pipelines.delete({
     *   where: {
     *     // ... filter to delete one Pipelines
     *   }
     * })
     * 
     */
    delete<T extends PipelinesDeleteArgs>(args: SelectSubset<T, PipelinesDeleteArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pipelines.
     * @param {PipelinesUpdateArgs} args - Arguments to update one Pipelines.
     * @example
     * // Update one Pipelines
     * const pipelines = await prisma.pipelines.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PipelinesUpdateArgs>(args: SelectSubset<T, PipelinesUpdateArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pipelines.
     * @param {PipelinesDeleteManyArgs} args - Arguments to filter Pipelines to delete.
     * @example
     * // Delete a few Pipelines
     * const { count } = await prisma.pipelines.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PipelinesDeleteManyArgs>(args?: SelectSubset<T, PipelinesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pipelines
     * const pipelines = await prisma.pipelines.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PipelinesUpdateManyArgs>(args: SelectSubset<T, PipelinesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines and returns the data updated in the database.
     * @param {PipelinesUpdateManyAndReturnArgs} args - Arguments to update many Pipelines.
     * @example
     * // Update many Pipelines
     * const pipelines = await prisma.pipelines.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pipelines and only return the `id`
     * const pipelinesWithIdOnly = await prisma.pipelines.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PipelinesUpdateManyAndReturnArgs>(args: SelectSubset<T, PipelinesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pipelines.
     * @param {PipelinesUpsertArgs} args - Arguments to update or create a Pipelines.
     * @example
     * // Update or create a Pipelines
     * const pipelines = await prisma.pipelines.upsert({
     *   create: {
     *     // ... data to create a Pipelines
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pipelines we want to update
     *   }
     * })
     */
    upsert<T extends PipelinesUpsertArgs>(args: SelectSubset<T, PipelinesUpsertArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesCountArgs} args - Arguments to filter Pipelines to count.
     * @example
     * // Count the number of Pipelines
     * const count = await prisma.pipelines.count({
     *   where: {
     *     // ... the filter for the Pipelines we want to count
     *   }
     * })
    **/
    count<T extends PipelinesCountArgs>(
      args?: Subset<T, PipelinesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PipelinesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PipelinesAggregateArgs>(args: Subset<T, PipelinesAggregateArgs>): Prisma.PrismaPromise<GetPipelinesAggregateType<T>>

    /**
     * Group by Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PipelinesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PipelinesGroupByArgs['orderBy'] }
        : { orderBy?: PipelinesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PipelinesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPipelinesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pipelines model
   */
  readonly fields: PipelinesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pipelines.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PipelinesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends Pipelines$businessArgs<ExtArgs> = {}>(args?: Subset<T, Pipelines$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends Pipelines$productsArgs<ExtArgs> = {}>(args?: Subset<T, Pipelines$productsArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    affiliate_business<T extends Pipelines$affiliate_businessArgs<ExtArgs> = {}>(args?: Subset<T, Pipelines$affiliate_businessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ChatMessage<T extends Pipelines$ChatMessageArgs<ExtArgs> = {}>(args?: Subset<T, Pipelines$ChatMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pipelines model
   */
  interface PipelinesFieldRefs {
    readonly id: FieldRef<"Pipelines", 'Int'>
    readonly prompt: FieldRef<"Pipelines", 'String'>
    readonly remark: FieldRef<"Pipelines", 'String'>
    readonly status: FieldRef<"Pipelines", 'String'>
    readonly affiliate_count: FieldRef<"Pipelines", 'Int'>
    readonly business_id: FieldRef<"Pipelines", 'String'>
    readonly product_id: FieldRef<"Pipelines", 'Int'>
    readonly format: FieldRef<"Pipelines", 'String'>
    readonly location: FieldRef<"Pipelines", 'String'>
    readonly heygen_video_id: FieldRef<"Pipelines", 'String'>
    readonly ig_post_id: FieldRef<"Pipelines", 'String'>
    readonly ig_post_url: FieldRef<"Pipelines", 'String'>
    readonly run_mode: FieldRef<"Pipelines", 'RunMode'>
    readonly workflow: FieldRef<"Pipelines", 'String'>
    readonly created_at: FieldRef<"Pipelines", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pipelines findUnique
   */
  export type PipelinesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where: PipelinesWhereUniqueInput
  }

  /**
   * Pipelines findUniqueOrThrow
   */
  export type PipelinesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where: PipelinesWhereUniqueInput
  }

  /**
   * Pipelines findFirst
   */
  export type PipelinesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where?: PipelinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelinesOrderByWithRelationInput | PipelinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelinesScalarFieldEnum | PipelinesScalarFieldEnum[]
  }

  /**
   * Pipelines findFirstOrThrow
   */
  export type PipelinesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where?: PipelinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelinesOrderByWithRelationInput | PipelinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelinesScalarFieldEnum | PipelinesScalarFieldEnum[]
  }

  /**
   * Pipelines findMany
   */
  export type PipelinesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where?: PipelinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelinesOrderByWithRelationInput | PipelinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pipelines.
     */
    cursor?: PipelinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    distinct?: PipelinesScalarFieldEnum | PipelinesScalarFieldEnum[]
  }

  /**
   * Pipelines create
   */
  export type PipelinesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * The data needed to create a Pipelines.
     */
    data?: XOR<PipelinesCreateInput, PipelinesUncheckedCreateInput>
  }

  /**
   * Pipelines createMany
   */
  export type PipelinesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pipelines.
     */
    data: PipelinesCreateManyInput | PipelinesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pipelines createManyAndReturn
   */
  export type PipelinesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * The data used to create many Pipelines.
     */
    data: PipelinesCreateManyInput | PipelinesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pipelines update
   */
  export type PipelinesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * The data needed to update a Pipelines.
     */
    data: XOR<PipelinesUpdateInput, PipelinesUncheckedUpdateInput>
    /**
     * Choose, which Pipelines to update.
     */
    where: PipelinesWhereUniqueInput
  }

  /**
   * Pipelines updateMany
   */
  export type PipelinesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelinesUpdateManyMutationInput, PipelinesUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelinesWhereInput
    /**
     * Limit how many Pipelines to update.
     */
    limit?: number
  }

  /**
   * Pipelines updateManyAndReturn
   */
  export type PipelinesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelinesUpdateManyMutationInput, PipelinesUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelinesWhereInput
    /**
     * Limit how many Pipelines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pipelines upsert
   */
  export type PipelinesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * The filter to search for the Pipelines to update in case it exists.
     */
    where: PipelinesWhereUniqueInput
    /**
     * In case the Pipelines found by the `where` argument doesn't exist, create a new Pipelines with this data.
     */
    create: XOR<PipelinesCreateInput, PipelinesUncheckedCreateInput>
    /**
     * In case the Pipelines was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PipelinesUpdateInput, PipelinesUncheckedUpdateInput>
  }

  /**
   * Pipelines delete
   */
  export type PipelinesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * Filter which Pipelines to delete.
     */
    where: PipelinesWhereUniqueInput
  }

  /**
   * Pipelines deleteMany
   */
  export type PipelinesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipelines to delete
     */
    where?: PipelinesWhereInput
    /**
     * Limit how many Pipelines to delete.
     */
    limit?: number
  }

  /**
   * Pipelines.business
   */
  export type Pipelines$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * Pipelines.products
   */
  export type Pipelines$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
  }

  /**
   * Pipelines.affiliate_business
   */
  export type Pipelines$affiliate_businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    where?: Affiliate_BusinessWhereInput
    orderBy?: Affiliate_BusinessOrderByWithRelationInput | Affiliate_BusinessOrderByWithRelationInput[]
    cursor?: Affiliate_BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Affiliate_BusinessScalarFieldEnum | Affiliate_BusinessScalarFieldEnum[]
  }

  /**
   * Pipelines.ChatMessage
   */
  export type Pipelines$ChatMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * Pipelines without action
   */
  export type PipelinesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageAvgAggregateOutputType = {
    id: number | null
    pipeline_id: number | null
  }

  export type ChatMessageSumAggregateOutputType = {
    id: number | null
    pipeline_id: number | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: number | null
    sender: string | null
    receiver: string | null
    text: string | null
    pipeline_id: number | null
    chat_message_status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: number | null
    sender: string | null
    receiver: string | null
    text: string | null
    pipeline_id: number | null
    chat_message_status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    sender: number
    receiver: number
    text: number
    pipeline_id: number
    chat_message_status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChatMessageAvgAggregateInputType = {
    id?: true
    pipeline_id?: true
  }

  export type ChatMessageSumAggregateInputType = {
    id?: true
    pipeline_id?: true
  }

  export type ChatMessageMinAggregateInputType = {
    id?: true
    sender?: true
    receiver?: true
    text?: true
    pipeline_id?: true
    chat_message_status?: true
    created_at?: true
    updated_at?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    sender?: true
    receiver?: true
    text?: true
    pipeline_id?: true
    chat_message_status?: true
    created_at?: true
    updated_at?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    sender?: true
    receiver?: true
    text?: true
    pipeline_id?: true
    chat_message_status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _avg?: ChatMessageAvgAggregateInputType
    _sum?: ChatMessageSumAggregateInputType
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: number
    sender: string
    receiver: string
    text: string
    pipeline_id: number
    chat_message_status: string | null
    created_at: Date
    updated_at: Date
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender?: boolean
    receiver?: boolean
    text?: boolean
    pipeline_id?: boolean
    chat_message_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    pipeline?: boolean | PipelinesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender?: boolean
    receiver?: boolean
    text?: boolean
    pipeline_id?: boolean
    chat_message_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    pipeline?: boolean | PipelinesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender?: boolean
    receiver?: boolean
    text?: boolean
    pipeline_id?: boolean
    chat_message_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    pipeline?: boolean | PipelinesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    sender?: boolean
    receiver?: boolean
    text?: boolean
    pipeline_id?: boolean
    chat_message_status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sender" | "receiver" | "text" | "pipeline_id" | "chat_message_status" | "created_at" | "updated_at", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | PipelinesDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | PipelinesDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | PipelinesDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      pipeline: Prisma.$PipelinesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sender: string
      receiver: string
      text: string
      pipeline_id: number
      chat_message_status: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pipeline<T extends PipelinesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PipelinesDefaultArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'Int'>
    readonly sender: FieldRef<"ChatMessage", 'String'>
    readonly receiver: FieldRef<"ChatMessage", 'String'>
    readonly text: FieldRef<"ChatMessage", 'String'>
    readonly pipeline_id: FieldRef<"ChatMessage", 'Int'>
    readonly chat_message_status: FieldRef<"ChatMessage", 'String'>
    readonly created_at: FieldRef<"ChatMessage", 'DateTime'>
    readonly updated_at: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model Waitlist
   */

  export type AggregateWaitlist = {
    _count: WaitlistCountAggregateOutputType | null
    _min: WaitlistMinAggregateOutputType | null
    _max: WaitlistMaxAggregateOutputType | null
  }

  export type WaitlistMinAggregateOutputType = {
    id: string | null
    email: string | null
    created_at: Date | null
  }

  export type WaitlistMaxAggregateOutputType = {
    id: string | null
    email: string | null
    created_at: Date | null
  }

  export type WaitlistCountAggregateOutputType = {
    id: number
    email: number
    created_at: number
    _all: number
  }


  export type WaitlistMinAggregateInputType = {
    id?: true
    email?: true
    created_at?: true
  }

  export type WaitlistMaxAggregateInputType = {
    id?: true
    email?: true
    created_at?: true
  }

  export type WaitlistCountAggregateInputType = {
    id?: true
    email?: true
    created_at?: true
    _all?: true
  }

  export type WaitlistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Waitlist to aggregate.
     */
    where?: WaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Waitlists to fetch.
     */
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Waitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Waitlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Waitlists
    **/
    _count?: true | WaitlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WaitlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WaitlistMaxAggregateInputType
  }

  export type GetWaitlistAggregateType<T extends WaitlistAggregateArgs> = {
        [P in keyof T & keyof AggregateWaitlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWaitlist[P]>
      : GetScalarType<T[P], AggregateWaitlist[P]>
  }




  export type WaitlistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitlistWhereInput
    orderBy?: WaitlistOrderByWithAggregationInput | WaitlistOrderByWithAggregationInput[]
    by: WaitlistScalarFieldEnum[] | WaitlistScalarFieldEnum
    having?: WaitlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WaitlistCountAggregateInputType | true
    _min?: WaitlistMinAggregateInputType
    _max?: WaitlistMaxAggregateInputType
  }

  export type WaitlistGroupByOutputType = {
    id: string
    email: string
    created_at: Date
    _count: WaitlistCountAggregateOutputType | null
    _min: WaitlistMinAggregateOutputType | null
    _max: WaitlistMaxAggregateOutputType | null
  }

  type GetWaitlistGroupByPayload<T extends WaitlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WaitlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WaitlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WaitlistGroupByOutputType[P]>
            : GetScalarType<T[P], WaitlistGroupByOutputType[P]>
        }
      >
    >


  export type WaitlistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["waitlist"]>

  export type WaitlistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["waitlist"]>

  export type WaitlistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["waitlist"]>

  export type WaitlistSelectScalar = {
    id?: boolean
    email?: boolean
    created_at?: boolean
  }

  export type WaitlistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "created_at", ExtArgs["result"]["waitlist"]>

  export type $WaitlistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Waitlist"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      created_at: Date
    }, ExtArgs["result"]["waitlist"]>
    composites: {}
  }

  type WaitlistGetPayload<S extends boolean | null | undefined | WaitlistDefaultArgs> = $Result.GetResult<Prisma.$WaitlistPayload, S>

  type WaitlistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WaitlistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WaitlistCountAggregateInputType | true
    }

  export interface WaitlistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Waitlist'], meta: { name: 'Waitlist' } }
    /**
     * Find zero or one Waitlist that matches the filter.
     * @param {WaitlistFindUniqueArgs} args - Arguments to find a Waitlist
     * @example
     * // Get one Waitlist
     * const waitlist = await prisma.waitlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WaitlistFindUniqueArgs>(args: SelectSubset<T, WaitlistFindUniqueArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Waitlist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WaitlistFindUniqueOrThrowArgs} args - Arguments to find a Waitlist
     * @example
     * // Get one Waitlist
     * const waitlist = await prisma.waitlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WaitlistFindUniqueOrThrowArgs>(args: SelectSubset<T, WaitlistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Waitlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistFindFirstArgs} args - Arguments to find a Waitlist
     * @example
     * // Get one Waitlist
     * const waitlist = await prisma.waitlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WaitlistFindFirstArgs>(args?: SelectSubset<T, WaitlistFindFirstArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Waitlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistFindFirstOrThrowArgs} args - Arguments to find a Waitlist
     * @example
     * // Get one Waitlist
     * const waitlist = await prisma.waitlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WaitlistFindFirstOrThrowArgs>(args?: SelectSubset<T, WaitlistFindFirstOrThrowArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Waitlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Waitlists
     * const waitlists = await prisma.waitlist.findMany()
     * 
     * // Get first 10 Waitlists
     * const waitlists = await prisma.waitlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const waitlistWithIdOnly = await prisma.waitlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WaitlistFindManyArgs>(args?: SelectSubset<T, WaitlistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Waitlist.
     * @param {WaitlistCreateArgs} args - Arguments to create a Waitlist.
     * @example
     * // Create one Waitlist
     * const Waitlist = await prisma.waitlist.create({
     *   data: {
     *     // ... data to create a Waitlist
     *   }
     * })
     * 
     */
    create<T extends WaitlistCreateArgs>(args: SelectSubset<T, WaitlistCreateArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Waitlists.
     * @param {WaitlistCreateManyArgs} args - Arguments to create many Waitlists.
     * @example
     * // Create many Waitlists
     * const waitlist = await prisma.waitlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WaitlistCreateManyArgs>(args?: SelectSubset<T, WaitlistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Waitlists and returns the data saved in the database.
     * @param {WaitlistCreateManyAndReturnArgs} args - Arguments to create many Waitlists.
     * @example
     * // Create many Waitlists
     * const waitlist = await prisma.waitlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Waitlists and only return the `id`
     * const waitlistWithIdOnly = await prisma.waitlist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WaitlistCreateManyAndReturnArgs>(args?: SelectSubset<T, WaitlistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Waitlist.
     * @param {WaitlistDeleteArgs} args - Arguments to delete one Waitlist.
     * @example
     * // Delete one Waitlist
     * const Waitlist = await prisma.waitlist.delete({
     *   where: {
     *     // ... filter to delete one Waitlist
     *   }
     * })
     * 
     */
    delete<T extends WaitlistDeleteArgs>(args: SelectSubset<T, WaitlistDeleteArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Waitlist.
     * @param {WaitlistUpdateArgs} args - Arguments to update one Waitlist.
     * @example
     * // Update one Waitlist
     * const waitlist = await prisma.waitlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WaitlistUpdateArgs>(args: SelectSubset<T, WaitlistUpdateArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Waitlists.
     * @param {WaitlistDeleteManyArgs} args - Arguments to filter Waitlists to delete.
     * @example
     * // Delete a few Waitlists
     * const { count } = await prisma.waitlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WaitlistDeleteManyArgs>(args?: SelectSubset<T, WaitlistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Waitlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Waitlists
     * const waitlist = await prisma.waitlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WaitlistUpdateManyArgs>(args: SelectSubset<T, WaitlistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Waitlists and returns the data updated in the database.
     * @param {WaitlistUpdateManyAndReturnArgs} args - Arguments to update many Waitlists.
     * @example
     * // Update many Waitlists
     * const waitlist = await prisma.waitlist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Waitlists and only return the `id`
     * const waitlistWithIdOnly = await prisma.waitlist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WaitlistUpdateManyAndReturnArgs>(args: SelectSubset<T, WaitlistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Waitlist.
     * @param {WaitlistUpsertArgs} args - Arguments to update or create a Waitlist.
     * @example
     * // Update or create a Waitlist
     * const waitlist = await prisma.waitlist.upsert({
     *   create: {
     *     // ... data to create a Waitlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Waitlist we want to update
     *   }
     * })
     */
    upsert<T extends WaitlistUpsertArgs>(args: SelectSubset<T, WaitlistUpsertArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Waitlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistCountArgs} args - Arguments to filter Waitlists to count.
     * @example
     * // Count the number of Waitlists
     * const count = await prisma.waitlist.count({
     *   where: {
     *     // ... the filter for the Waitlists we want to count
     *   }
     * })
    **/
    count<T extends WaitlistCountArgs>(
      args?: Subset<T, WaitlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WaitlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Waitlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WaitlistAggregateArgs>(args: Subset<T, WaitlistAggregateArgs>): Prisma.PrismaPromise<GetWaitlistAggregateType<T>>

    /**
     * Group by Waitlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WaitlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WaitlistGroupByArgs['orderBy'] }
        : { orderBy?: WaitlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WaitlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWaitlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Waitlist model
   */
  readonly fields: WaitlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Waitlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WaitlistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Waitlist model
   */
  interface WaitlistFieldRefs {
    readonly id: FieldRef<"Waitlist", 'String'>
    readonly email: FieldRef<"Waitlist", 'String'>
    readonly created_at: FieldRef<"Waitlist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Waitlist findUnique
   */
  export type WaitlistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Filter, which Waitlist to fetch.
     */
    where: WaitlistWhereUniqueInput
  }

  /**
   * Waitlist findUniqueOrThrow
   */
  export type WaitlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Filter, which Waitlist to fetch.
     */
    where: WaitlistWhereUniqueInput
  }

  /**
   * Waitlist findFirst
   */
  export type WaitlistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Filter, which Waitlist to fetch.
     */
    where?: WaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Waitlists to fetch.
     */
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Waitlists.
     */
    cursor?: WaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Waitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Waitlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Waitlists.
     */
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * Waitlist findFirstOrThrow
   */
  export type WaitlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Filter, which Waitlist to fetch.
     */
    where?: WaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Waitlists to fetch.
     */
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Waitlists.
     */
    cursor?: WaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Waitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Waitlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Waitlists.
     */
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * Waitlist findMany
   */
  export type WaitlistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Filter, which Waitlists to fetch.
     */
    where?: WaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Waitlists to fetch.
     */
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Waitlists.
     */
    cursor?: WaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Waitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Waitlists.
     */
    skip?: number
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * Waitlist create
   */
  export type WaitlistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * The data needed to create a Waitlist.
     */
    data: XOR<WaitlistCreateInput, WaitlistUncheckedCreateInput>
  }

  /**
   * Waitlist createMany
   */
  export type WaitlistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Waitlists.
     */
    data: WaitlistCreateManyInput | WaitlistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Waitlist createManyAndReturn
   */
  export type WaitlistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * The data used to create many Waitlists.
     */
    data: WaitlistCreateManyInput | WaitlistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Waitlist update
   */
  export type WaitlistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * The data needed to update a Waitlist.
     */
    data: XOR<WaitlistUpdateInput, WaitlistUncheckedUpdateInput>
    /**
     * Choose, which Waitlist to update.
     */
    where: WaitlistWhereUniqueInput
  }

  /**
   * Waitlist updateMany
   */
  export type WaitlistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Waitlists.
     */
    data: XOR<WaitlistUpdateManyMutationInput, WaitlistUncheckedUpdateManyInput>
    /**
     * Filter which Waitlists to update
     */
    where?: WaitlistWhereInput
    /**
     * Limit how many Waitlists to update.
     */
    limit?: number
  }

  /**
   * Waitlist updateManyAndReturn
   */
  export type WaitlistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * The data used to update Waitlists.
     */
    data: XOR<WaitlistUpdateManyMutationInput, WaitlistUncheckedUpdateManyInput>
    /**
     * Filter which Waitlists to update
     */
    where?: WaitlistWhereInput
    /**
     * Limit how many Waitlists to update.
     */
    limit?: number
  }

  /**
   * Waitlist upsert
   */
  export type WaitlistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * The filter to search for the Waitlist to update in case it exists.
     */
    where: WaitlistWhereUniqueInput
    /**
     * In case the Waitlist found by the `where` argument doesn't exist, create a new Waitlist with this data.
     */
    create: XOR<WaitlistCreateInput, WaitlistUncheckedCreateInput>
    /**
     * In case the Waitlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WaitlistUpdateInput, WaitlistUncheckedUpdateInput>
  }

  /**
   * Waitlist delete
   */
  export type WaitlistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Filter which Waitlist to delete.
     */
    where: WaitlistWhereUniqueInput
  }

  /**
   * Waitlist deleteMany
   */
  export type WaitlistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Waitlists to delete
     */
    where?: WaitlistWhereInput
    /**
     * Limit how many Waitlists to delete.
     */
    limit?: number
  }

  /**
   * Waitlist without action
   */
  export type WaitlistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
  }


  /**
   * Model Pending_Payments
   */

  export type AggregatePending_Payments = {
    _count: Pending_PaymentsCountAggregateOutputType | null
    _avg: Pending_PaymentsAvgAggregateOutputType | null
    _sum: Pending_PaymentsSumAggregateOutputType | null
    _min: Pending_PaymentsMinAggregateOutputType | null
    _max: Pending_PaymentsMaxAggregateOutputType | null
  }

  export type Pending_PaymentsAvgAggregateOutputType = {
    product_id: number | null
    full_amount: Decimal | null
    fiat_amount: Decimal | null
    crypto_amount: Decimal | null
  }

  export type Pending_PaymentsSumAggregateOutputType = {
    product_id: number | null
    full_amount: Decimal | null
    fiat_amount: Decimal | null
    crypto_amount: Decimal | null
  }

  export type Pending_PaymentsMinAggregateOutputType = {
    id: string | null
    business_id: string | null
    product_id: number | null
    full_amount: Decimal | null
    fiat_amount: Decimal | null
    crypto_amount: Decimal | null
    payout_date: Date | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Pending_PaymentsMaxAggregateOutputType = {
    id: string | null
    business_id: string | null
    product_id: number | null
    full_amount: Decimal | null
    fiat_amount: Decimal | null
    crypto_amount: Decimal | null
    payout_date: Date | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Pending_PaymentsCountAggregateOutputType = {
    id: number
    business_id: number
    product_id: number
    full_amount: number
    fiat_amount: number
    crypto_amount: number
    payout_date: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Pending_PaymentsAvgAggregateInputType = {
    product_id?: true
    full_amount?: true
    fiat_amount?: true
    crypto_amount?: true
  }

  export type Pending_PaymentsSumAggregateInputType = {
    product_id?: true
    full_amount?: true
    fiat_amount?: true
    crypto_amount?: true
  }

  export type Pending_PaymentsMinAggregateInputType = {
    id?: true
    business_id?: true
    product_id?: true
    full_amount?: true
    fiat_amount?: true
    crypto_amount?: true
    payout_date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Pending_PaymentsMaxAggregateInputType = {
    id?: true
    business_id?: true
    product_id?: true
    full_amount?: true
    fiat_amount?: true
    crypto_amount?: true
    payout_date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Pending_PaymentsCountAggregateInputType = {
    id?: true
    business_id?: true
    product_id?: true
    full_amount?: true
    fiat_amount?: true
    crypto_amount?: true
    payout_date?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Pending_PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pending_Payments to aggregate.
     */
    where?: Pending_PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pending_Payments to fetch.
     */
    orderBy?: Pending_PaymentsOrderByWithRelationInput | Pending_PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Pending_PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pending_Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pending_Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pending_Payments
    **/
    _count?: true | Pending_PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pending_PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pending_PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pending_PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pending_PaymentsMaxAggregateInputType
  }

  export type GetPending_PaymentsAggregateType<T extends Pending_PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePending_Payments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePending_Payments[P]>
      : GetScalarType<T[P], AggregatePending_Payments[P]>
  }




  export type Pending_PaymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Pending_PaymentsWhereInput
    orderBy?: Pending_PaymentsOrderByWithAggregationInput | Pending_PaymentsOrderByWithAggregationInput[]
    by: Pending_PaymentsScalarFieldEnum[] | Pending_PaymentsScalarFieldEnum
    having?: Pending_PaymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pending_PaymentsCountAggregateInputType | true
    _avg?: Pending_PaymentsAvgAggregateInputType
    _sum?: Pending_PaymentsSumAggregateInputType
    _min?: Pending_PaymentsMinAggregateInputType
    _max?: Pending_PaymentsMaxAggregateInputType
  }

  export type Pending_PaymentsGroupByOutputType = {
    id: string
    business_id: string
    product_id: number
    full_amount: Decimal | null
    fiat_amount: Decimal | null
    crypto_amount: Decimal | null
    payout_date: Date | null
    status: string
    created_at: Date
    updated_at: Date
    _count: Pending_PaymentsCountAggregateOutputType | null
    _avg: Pending_PaymentsAvgAggregateOutputType | null
    _sum: Pending_PaymentsSumAggregateOutputType | null
    _min: Pending_PaymentsMinAggregateOutputType | null
    _max: Pending_PaymentsMaxAggregateOutputType | null
  }

  type GetPending_PaymentsGroupByPayload<T extends Pending_PaymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pending_PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pending_PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pending_PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], Pending_PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type Pending_PaymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    business_id?: boolean
    product_id?: boolean
    full_amount?: boolean
    fiat_amount?: boolean
    crypto_amount?: boolean
    payout_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pending_Payments"]>

  export type Pending_PaymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    business_id?: boolean
    product_id?: boolean
    full_amount?: boolean
    fiat_amount?: boolean
    crypto_amount?: boolean
    payout_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pending_Payments"]>

  export type Pending_PaymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    business_id?: boolean
    product_id?: boolean
    full_amount?: boolean
    fiat_amount?: boolean
    crypto_amount?: boolean
    payout_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pending_Payments"]>

  export type Pending_PaymentsSelectScalar = {
    id?: boolean
    business_id?: boolean
    product_id?: boolean
    full_amount?: boolean
    fiat_amount?: boolean
    crypto_amount?: boolean
    payout_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type Pending_PaymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "business_id" | "product_id" | "full_amount" | "fiat_amount" | "crypto_amount" | "payout_date" | "status" | "created_at" | "updated_at", ExtArgs["result"]["pending_Payments"]>
  export type Pending_PaymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type Pending_PaymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type Pending_PaymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $Pending_PaymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pending_Payments"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      business_id: string
      product_id: number
      full_amount: Prisma.Decimal | null
      fiat_amount: Prisma.Decimal | null
      crypto_amount: Prisma.Decimal | null
      payout_date: Date | null
      status: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["pending_Payments"]>
    composites: {}
  }

  type Pending_PaymentsGetPayload<S extends boolean | null | undefined | Pending_PaymentsDefaultArgs> = $Result.GetResult<Prisma.$Pending_PaymentsPayload, S>

  type Pending_PaymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Pending_PaymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pending_PaymentsCountAggregateInputType | true
    }

  export interface Pending_PaymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pending_Payments'], meta: { name: 'Pending_Payments' } }
    /**
     * Find zero or one Pending_Payments that matches the filter.
     * @param {Pending_PaymentsFindUniqueArgs} args - Arguments to find a Pending_Payments
     * @example
     * // Get one Pending_Payments
     * const pending_Payments = await prisma.pending_Payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Pending_PaymentsFindUniqueArgs>(args: SelectSubset<T, Pending_PaymentsFindUniqueArgs<ExtArgs>>): Prisma__Pending_PaymentsClient<$Result.GetResult<Prisma.$Pending_PaymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pending_Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Pending_PaymentsFindUniqueOrThrowArgs} args - Arguments to find a Pending_Payments
     * @example
     * // Get one Pending_Payments
     * const pending_Payments = await prisma.pending_Payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Pending_PaymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, Pending_PaymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Pending_PaymentsClient<$Result.GetResult<Prisma.$Pending_PaymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pending_Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pending_PaymentsFindFirstArgs} args - Arguments to find a Pending_Payments
     * @example
     * // Get one Pending_Payments
     * const pending_Payments = await prisma.pending_Payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Pending_PaymentsFindFirstArgs>(args?: SelectSubset<T, Pending_PaymentsFindFirstArgs<ExtArgs>>): Prisma__Pending_PaymentsClient<$Result.GetResult<Prisma.$Pending_PaymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pending_Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pending_PaymentsFindFirstOrThrowArgs} args - Arguments to find a Pending_Payments
     * @example
     * // Get one Pending_Payments
     * const pending_Payments = await prisma.pending_Payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Pending_PaymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, Pending_PaymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Pending_PaymentsClient<$Result.GetResult<Prisma.$Pending_PaymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pending_Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pending_PaymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pending_Payments
     * const pending_Payments = await prisma.pending_Payments.findMany()
     * 
     * // Get first 10 Pending_Payments
     * const pending_Payments = await prisma.pending_Payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pending_PaymentsWithIdOnly = await prisma.pending_Payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Pending_PaymentsFindManyArgs>(args?: SelectSubset<T, Pending_PaymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Pending_PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pending_Payments.
     * @param {Pending_PaymentsCreateArgs} args - Arguments to create a Pending_Payments.
     * @example
     * // Create one Pending_Payments
     * const Pending_Payments = await prisma.pending_Payments.create({
     *   data: {
     *     // ... data to create a Pending_Payments
     *   }
     * })
     * 
     */
    create<T extends Pending_PaymentsCreateArgs>(args: SelectSubset<T, Pending_PaymentsCreateArgs<ExtArgs>>): Prisma__Pending_PaymentsClient<$Result.GetResult<Prisma.$Pending_PaymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pending_Payments.
     * @param {Pending_PaymentsCreateManyArgs} args - Arguments to create many Pending_Payments.
     * @example
     * // Create many Pending_Payments
     * const pending_Payments = await prisma.pending_Payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Pending_PaymentsCreateManyArgs>(args?: SelectSubset<T, Pending_PaymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pending_Payments and returns the data saved in the database.
     * @param {Pending_PaymentsCreateManyAndReturnArgs} args - Arguments to create many Pending_Payments.
     * @example
     * // Create many Pending_Payments
     * const pending_Payments = await prisma.pending_Payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pending_Payments and only return the `id`
     * const pending_PaymentsWithIdOnly = await prisma.pending_Payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Pending_PaymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, Pending_PaymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Pending_PaymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pending_Payments.
     * @param {Pending_PaymentsDeleteArgs} args - Arguments to delete one Pending_Payments.
     * @example
     * // Delete one Pending_Payments
     * const Pending_Payments = await prisma.pending_Payments.delete({
     *   where: {
     *     // ... filter to delete one Pending_Payments
     *   }
     * })
     * 
     */
    delete<T extends Pending_PaymentsDeleteArgs>(args: SelectSubset<T, Pending_PaymentsDeleteArgs<ExtArgs>>): Prisma__Pending_PaymentsClient<$Result.GetResult<Prisma.$Pending_PaymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pending_Payments.
     * @param {Pending_PaymentsUpdateArgs} args - Arguments to update one Pending_Payments.
     * @example
     * // Update one Pending_Payments
     * const pending_Payments = await prisma.pending_Payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Pending_PaymentsUpdateArgs>(args: SelectSubset<T, Pending_PaymentsUpdateArgs<ExtArgs>>): Prisma__Pending_PaymentsClient<$Result.GetResult<Prisma.$Pending_PaymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pending_Payments.
     * @param {Pending_PaymentsDeleteManyArgs} args - Arguments to filter Pending_Payments to delete.
     * @example
     * // Delete a few Pending_Payments
     * const { count } = await prisma.pending_Payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Pending_PaymentsDeleteManyArgs>(args?: SelectSubset<T, Pending_PaymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pending_Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pending_PaymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pending_Payments
     * const pending_Payments = await prisma.pending_Payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Pending_PaymentsUpdateManyArgs>(args: SelectSubset<T, Pending_PaymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pending_Payments and returns the data updated in the database.
     * @param {Pending_PaymentsUpdateManyAndReturnArgs} args - Arguments to update many Pending_Payments.
     * @example
     * // Update many Pending_Payments
     * const pending_Payments = await prisma.pending_Payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pending_Payments and only return the `id`
     * const pending_PaymentsWithIdOnly = await prisma.pending_Payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Pending_PaymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, Pending_PaymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Pending_PaymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pending_Payments.
     * @param {Pending_PaymentsUpsertArgs} args - Arguments to update or create a Pending_Payments.
     * @example
     * // Update or create a Pending_Payments
     * const pending_Payments = await prisma.pending_Payments.upsert({
     *   create: {
     *     // ... data to create a Pending_Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pending_Payments we want to update
     *   }
     * })
     */
    upsert<T extends Pending_PaymentsUpsertArgs>(args: SelectSubset<T, Pending_PaymentsUpsertArgs<ExtArgs>>): Prisma__Pending_PaymentsClient<$Result.GetResult<Prisma.$Pending_PaymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pending_Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pending_PaymentsCountArgs} args - Arguments to filter Pending_Payments to count.
     * @example
     * // Count the number of Pending_Payments
     * const count = await prisma.pending_Payments.count({
     *   where: {
     *     // ... the filter for the Pending_Payments we want to count
     *   }
     * })
    **/
    count<T extends Pending_PaymentsCountArgs>(
      args?: Subset<T, Pending_PaymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pending_PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pending_Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pending_PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pending_PaymentsAggregateArgs>(args: Subset<T, Pending_PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPending_PaymentsAggregateType<T>>

    /**
     * Group by Pending_Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pending_PaymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Pending_PaymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Pending_PaymentsGroupByArgs['orderBy'] }
        : { orderBy?: Pending_PaymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Pending_PaymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPending_PaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pending_Payments model
   */
  readonly fields: Pending_PaymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pending_Payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Pending_PaymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pending_Payments model
   */
  interface Pending_PaymentsFieldRefs {
    readonly id: FieldRef<"Pending_Payments", 'String'>
    readonly business_id: FieldRef<"Pending_Payments", 'String'>
    readonly product_id: FieldRef<"Pending_Payments", 'Int'>
    readonly full_amount: FieldRef<"Pending_Payments", 'Decimal'>
    readonly fiat_amount: FieldRef<"Pending_Payments", 'Decimal'>
    readonly crypto_amount: FieldRef<"Pending_Payments", 'Decimal'>
    readonly payout_date: FieldRef<"Pending_Payments", 'DateTime'>
    readonly status: FieldRef<"Pending_Payments", 'String'>
    readonly created_at: FieldRef<"Pending_Payments", 'DateTime'>
    readonly updated_at: FieldRef<"Pending_Payments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pending_Payments findUnique
   */
  export type Pending_PaymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Pending_Payments to fetch.
     */
    where: Pending_PaymentsWhereUniqueInput
  }

  /**
   * Pending_Payments findUniqueOrThrow
   */
  export type Pending_PaymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Pending_Payments to fetch.
     */
    where: Pending_PaymentsWhereUniqueInput
  }

  /**
   * Pending_Payments findFirst
   */
  export type Pending_PaymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Pending_Payments to fetch.
     */
    where?: Pending_PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pending_Payments to fetch.
     */
    orderBy?: Pending_PaymentsOrderByWithRelationInput | Pending_PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pending_Payments.
     */
    cursor?: Pending_PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pending_Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pending_Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pending_Payments.
     */
    distinct?: Pending_PaymentsScalarFieldEnum | Pending_PaymentsScalarFieldEnum[]
  }

  /**
   * Pending_Payments findFirstOrThrow
   */
  export type Pending_PaymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Pending_Payments to fetch.
     */
    where?: Pending_PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pending_Payments to fetch.
     */
    orderBy?: Pending_PaymentsOrderByWithRelationInput | Pending_PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pending_Payments.
     */
    cursor?: Pending_PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pending_Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pending_Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pending_Payments.
     */
    distinct?: Pending_PaymentsScalarFieldEnum | Pending_PaymentsScalarFieldEnum[]
  }

  /**
   * Pending_Payments findMany
   */
  export type Pending_PaymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Pending_Payments to fetch.
     */
    where?: Pending_PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pending_Payments to fetch.
     */
    orderBy?: Pending_PaymentsOrderByWithRelationInput | Pending_PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pending_Payments.
     */
    cursor?: Pending_PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pending_Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pending_Payments.
     */
    skip?: number
    distinct?: Pending_PaymentsScalarFieldEnum | Pending_PaymentsScalarFieldEnum[]
  }

  /**
   * Pending_Payments create
   */
  export type Pending_PaymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Pending_Payments.
     */
    data: XOR<Pending_PaymentsCreateInput, Pending_PaymentsUncheckedCreateInput>
  }

  /**
   * Pending_Payments createMany
   */
  export type Pending_PaymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pending_Payments.
     */
    data: Pending_PaymentsCreateManyInput | Pending_PaymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pending_Payments createManyAndReturn
   */
  export type Pending_PaymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * The data used to create many Pending_Payments.
     */
    data: Pending_PaymentsCreateManyInput | Pending_PaymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pending_Payments update
   */
  export type Pending_PaymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Pending_Payments.
     */
    data: XOR<Pending_PaymentsUpdateInput, Pending_PaymentsUncheckedUpdateInput>
    /**
     * Choose, which Pending_Payments to update.
     */
    where: Pending_PaymentsWhereUniqueInput
  }

  /**
   * Pending_Payments updateMany
   */
  export type Pending_PaymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pending_Payments.
     */
    data: XOR<Pending_PaymentsUpdateManyMutationInput, Pending_PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Pending_Payments to update
     */
    where?: Pending_PaymentsWhereInput
    /**
     * Limit how many Pending_Payments to update.
     */
    limit?: number
  }

  /**
   * Pending_Payments updateManyAndReturn
   */
  export type Pending_PaymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * The data used to update Pending_Payments.
     */
    data: XOR<Pending_PaymentsUpdateManyMutationInput, Pending_PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Pending_Payments to update
     */
    where?: Pending_PaymentsWhereInput
    /**
     * Limit how many Pending_Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pending_Payments upsert
   */
  export type Pending_PaymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Pending_Payments to update in case it exists.
     */
    where: Pending_PaymentsWhereUniqueInput
    /**
     * In case the Pending_Payments found by the `where` argument doesn't exist, create a new Pending_Payments with this data.
     */
    create: XOR<Pending_PaymentsCreateInput, Pending_PaymentsUncheckedCreateInput>
    /**
     * In case the Pending_Payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Pending_PaymentsUpdateInput, Pending_PaymentsUncheckedUpdateInput>
  }

  /**
   * Pending_Payments delete
   */
  export type Pending_PaymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsInclude<ExtArgs> | null
    /**
     * Filter which Pending_Payments to delete.
     */
    where: Pending_PaymentsWhereUniqueInput
  }

  /**
   * Pending_Payments deleteMany
   */
  export type Pending_PaymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pending_Payments to delete
     */
    where?: Pending_PaymentsWhereInput
    /**
     * Limit how many Pending_Payments to delete.
     */
    limit?: number
  }

  /**
   * Pending_Payments without action
   */
  export type Pending_PaymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending_Payments
     */
    select?: Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pending_Payments
     */
    omit?: Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Pending_PaymentsInclude<ExtArgs> | null
  }


  /**
   * Model Affiliate_Pending_Payments
   */

  export type AggregateAffiliate_Pending_Payments = {
    _count: Affiliate_Pending_PaymentsCountAggregateOutputType | null
    _avg: Affiliate_Pending_PaymentsAvgAggregateOutputType | null
    _sum: Affiliate_Pending_PaymentsSumAggregateOutputType | null
    _min: Affiliate_Pending_PaymentsMinAggregateOutputType | null
    _max: Affiliate_Pending_PaymentsMaxAggregateOutputType | null
  }

  export type Affiliate_Pending_PaymentsAvgAggregateOutputType = {
    affiliate_id: number | null
    product_id: number | null
    full_amount: Decimal | null
    fiat_amount: Decimal | null
    crypto_amount: Decimal | null
  }

  export type Affiliate_Pending_PaymentsSumAggregateOutputType = {
    affiliate_id: number | null
    product_id: number | null
    full_amount: Decimal | null
    fiat_amount: Decimal | null
    crypto_amount: Decimal | null
  }

  export type Affiliate_Pending_PaymentsMinAggregateOutputType = {
    id: string | null
    affiliate_id: number | null
    product_id: number | null
    full_amount: Decimal | null
    fiat_amount: Decimal | null
    crypto_amount: Decimal | null
    payout_date: Date | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Affiliate_Pending_PaymentsMaxAggregateOutputType = {
    id: string | null
    affiliate_id: number | null
    product_id: number | null
    full_amount: Decimal | null
    fiat_amount: Decimal | null
    crypto_amount: Decimal | null
    payout_date: Date | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Affiliate_Pending_PaymentsCountAggregateOutputType = {
    id: number
    affiliate_id: number
    product_id: number
    full_amount: number
    fiat_amount: number
    crypto_amount: number
    payout_date: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Affiliate_Pending_PaymentsAvgAggregateInputType = {
    affiliate_id?: true
    product_id?: true
    full_amount?: true
    fiat_amount?: true
    crypto_amount?: true
  }

  export type Affiliate_Pending_PaymentsSumAggregateInputType = {
    affiliate_id?: true
    product_id?: true
    full_amount?: true
    fiat_amount?: true
    crypto_amount?: true
  }

  export type Affiliate_Pending_PaymentsMinAggregateInputType = {
    id?: true
    affiliate_id?: true
    product_id?: true
    full_amount?: true
    fiat_amount?: true
    crypto_amount?: true
    payout_date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Affiliate_Pending_PaymentsMaxAggregateInputType = {
    id?: true
    affiliate_id?: true
    product_id?: true
    full_amount?: true
    fiat_amount?: true
    crypto_amount?: true
    payout_date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Affiliate_Pending_PaymentsCountAggregateInputType = {
    id?: true
    affiliate_id?: true
    product_id?: true
    full_amount?: true
    fiat_amount?: true
    crypto_amount?: true
    payout_date?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Affiliate_Pending_PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Affiliate_Pending_Payments to aggregate.
     */
    where?: Affiliate_Pending_PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliate_Pending_Payments to fetch.
     */
    orderBy?: Affiliate_Pending_PaymentsOrderByWithRelationInput | Affiliate_Pending_PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Affiliate_Pending_PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliate_Pending_Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliate_Pending_Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Affiliate_Pending_Payments
    **/
    _count?: true | Affiliate_Pending_PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Affiliate_Pending_PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Affiliate_Pending_PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Affiliate_Pending_PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Affiliate_Pending_PaymentsMaxAggregateInputType
  }

  export type GetAffiliate_Pending_PaymentsAggregateType<T extends Affiliate_Pending_PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliate_Pending_Payments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliate_Pending_Payments[P]>
      : GetScalarType<T[P], AggregateAffiliate_Pending_Payments[P]>
  }




  export type Affiliate_Pending_PaymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Affiliate_Pending_PaymentsWhereInput
    orderBy?: Affiliate_Pending_PaymentsOrderByWithAggregationInput | Affiliate_Pending_PaymentsOrderByWithAggregationInput[]
    by: Affiliate_Pending_PaymentsScalarFieldEnum[] | Affiliate_Pending_PaymentsScalarFieldEnum
    having?: Affiliate_Pending_PaymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Affiliate_Pending_PaymentsCountAggregateInputType | true
    _avg?: Affiliate_Pending_PaymentsAvgAggregateInputType
    _sum?: Affiliate_Pending_PaymentsSumAggregateInputType
    _min?: Affiliate_Pending_PaymentsMinAggregateInputType
    _max?: Affiliate_Pending_PaymentsMaxAggregateInputType
  }

  export type Affiliate_Pending_PaymentsGroupByOutputType = {
    id: string
    affiliate_id: number
    product_id: number
    full_amount: Decimal | null
    fiat_amount: Decimal | null
    crypto_amount: Decimal | null
    payout_date: Date | null
    status: string
    created_at: Date
    updated_at: Date
    _count: Affiliate_Pending_PaymentsCountAggregateOutputType | null
    _avg: Affiliate_Pending_PaymentsAvgAggregateOutputType | null
    _sum: Affiliate_Pending_PaymentsSumAggregateOutputType | null
    _min: Affiliate_Pending_PaymentsMinAggregateOutputType | null
    _max: Affiliate_Pending_PaymentsMaxAggregateOutputType | null
  }

  type GetAffiliate_Pending_PaymentsGroupByPayload<T extends Affiliate_Pending_PaymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Affiliate_Pending_PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Affiliate_Pending_PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Affiliate_Pending_PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], Affiliate_Pending_PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type Affiliate_Pending_PaymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliate_id?: boolean
    product_id?: boolean
    full_amount?: boolean
    fiat_amount?: boolean
    crypto_amount?: boolean
    payout_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliate?: boolean | AffiliatesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliate_Pending_Payments"]>

  export type Affiliate_Pending_PaymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliate_id?: boolean
    product_id?: boolean
    full_amount?: boolean
    fiat_amount?: boolean
    crypto_amount?: boolean
    payout_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliate?: boolean | AffiliatesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliate_Pending_Payments"]>

  export type Affiliate_Pending_PaymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliate_id?: boolean
    product_id?: boolean
    full_amount?: boolean
    fiat_amount?: boolean
    crypto_amount?: boolean
    payout_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliate?: boolean | AffiliatesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliate_Pending_Payments"]>

  export type Affiliate_Pending_PaymentsSelectScalar = {
    id?: boolean
    affiliate_id?: boolean
    product_id?: boolean
    full_amount?: boolean
    fiat_amount?: boolean
    crypto_amount?: boolean
    payout_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type Affiliate_Pending_PaymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "affiliate_id" | "product_id" | "full_amount" | "fiat_amount" | "crypto_amount" | "payout_date" | "status" | "created_at" | "updated_at", ExtArgs["result"]["affiliate_Pending_Payments"]>
  export type Affiliate_Pending_PaymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliatesDefaultArgs<ExtArgs>
  }
  export type Affiliate_Pending_PaymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliatesDefaultArgs<ExtArgs>
  }
  export type Affiliate_Pending_PaymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliatesDefaultArgs<ExtArgs>
  }

  export type $Affiliate_Pending_PaymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Affiliate_Pending_Payments"
    objects: {
      affiliate: Prisma.$AffiliatesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      affiliate_id: number
      product_id: number
      full_amount: Prisma.Decimal | null
      fiat_amount: Prisma.Decimal | null
      crypto_amount: Prisma.Decimal | null
      payout_date: Date | null
      status: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["affiliate_Pending_Payments"]>
    composites: {}
  }

  type Affiliate_Pending_PaymentsGetPayload<S extends boolean | null | undefined | Affiliate_Pending_PaymentsDefaultArgs> = $Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload, S>

  type Affiliate_Pending_PaymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Affiliate_Pending_PaymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Affiliate_Pending_PaymentsCountAggregateInputType | true
    }

  export interface Affiliate_Pending_PaymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Affiliate_Pending_Payments'], meta: { name: 'Affiliate_Pending_Payments' } }
    /**
     * Find zero or one Affiliate_Pending_Payments that matches the filter.
     * @param {Affiliate_Pending_PaymentsFindUniqueArgs} args - Arguments to find a Affiliate_Pending_Payments
     * @example
     * // Get one Affiliate_Pending_Payments
     * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Affiliate_Pending_PaymentsFindUniqueArgs>(args: SelectSubset<T, Affiliate_Pending_PaymentsFindUniqueArgs<ExtArgs>>): Prisma__Affiliate_Pending_PaymentsClient<$Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Affiliate_Pending_Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Affiliate_Pending_PaymentsFindUniqueOrThrowArgs} args - Arguments to find a Affiliate_Pending_Payments
     * @example
     * // Get one Affiliate_Pending_Payments
     * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Affiliate_Pending_PaymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, Affiliate_Pending_PaymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Affiliate_Pending_PaymentsClient<$Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Affiliate_Pending_Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_Pending_PaymentsFindFirstArgs} args - Arguments to find a Affiliate_Pending_Payments
     * @example
     * // Get one Affiliate_Pending_Payments
     * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Affiliate_Pending_PaymentsFindFirstArgs>(args?: SelectSubset<T, Affiliate_Pending_PaymentsFindFirstArgs<ExtArgs>>): Prisma__Affiliate_Pending_PaymentsClient<$Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Affiliate_Pending_Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_Pending_PaymentsFindFirstOrThrowArgs} args - Arguments to find a Affiliate_Pending_Payments
     * @example
     * // Get one Affiliate_Pending_Payments
     * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Affiliate_Pending_PaymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, Affiliate_Pending_PaymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Affiliate_Pending_PaymentsClient<$Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Affiliate_Pending_Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_Pending_PaymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Affiliate_Pending_Payments
     * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.findMany()
     * 
     * // Get first 10 Affiliate_Pending_Payments
     * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliate_Pending_PaymentsWithIdOnly = await prisma.affiliate_Pending_Payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Affiliate_Pending_PaymentsFindManyArgs>(args?: SelectSubset<T, Affiliate_Pending_PaymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Affiliate_Pending_Payments.
     * @param {Affiliate_Pending_PaymentsCreateArgs} args - Arguments to create a Affiliate_Pending_Payments.
     * @example
     * // Create one Affiliate_Pending_Payments
     * const Affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.create({
     *   data: {
     *     // ... data to create a Affiliate_Pending_Payments
     *   }
     * })
     * 
     */
    create<T extends Affiliate_Pending_PaymentsCreateArgs>(args: SelectSubset<T, Affiliate_Pending_PaymentsCreateArgs<ExtArgs>>): Prisma__Affiliate_Pending_PaymentsClient<$Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Affiliate_Pending_Payments.
     * @param {Affiliate_Pending_PaymentsCreateManyArgs} args - Arguments to create many Affiliate_Pending_Payments.
     * @example
     * // Create many Affiliate_Pending_Payments
     * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Affiliate_Pending_PaymentsCreateManyArgs>(args?: SelectSubset<T, Affiliate_Pending_PaymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Affiliate_Pending_Payments and returns the data saved in the database.
     * @param {Affiliate_Pending_PaymentsCreateManyAndReturnArgs} args - Arguments to create many Affiliate_Pending_Payments.
     * @example
     * // Create many Affiliate_Pending_Payments
     * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Affiliate_Pending_Payments and only return the `id`
     * const affiliate_Pending_PaymentsWithIdOnly = await prisma.affiliate_Pending_Payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Affiliate_Pending_PaymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, Affiliate_Pending_PaymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Affiliate_Pending_Payments.
     * @param {Affiliate_Pending_PaymentsDeleteArgs} args - Arguments to delete one Affiliate_Pending_Payments.
     * @example
     * // Delete one Affiliate_Pending_Payments
     * const Affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.delete({
     *   where: {
     *     // ... filter to delete one Affiliate_Pending_Payments
     *   }
     * })
     * 
     */
    delete<T extends Affiliate_Pending_PaymentsDeleteArgs>(args: SelectSubset<T, Affiliate_Pending_PaymentsDeleteArgs<ExtArgs>>): Prisma__Affiliate_Pending_PaymentsClient<$Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Affiliate_Pending_Payments.
     * @param {Affiliate_Pending_PaymentsUpdateArgs} args - Arguments to update one Affiliate_Pending_Payments.
     * @example
     * // Update one Affiliate_Pending_Payments
     * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Affiliate_Pending_PaymentsUpdateArgs>(args: SelectSubset<T, Affiliate_Pending_PaymentsUpdateArgs<ExtArgs>>): Prisma__Affiliate_Pending_PaymentsClient<$Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Affiliate_Pending_Payments.
     * @param {Affiliate_Pending_PaymentsDeleteManyArgs} args - Arguments to filter Affiliate_Pending_Payments to delete.
     * @example
     * // Delete a few Affiliate_Pending_Payments
     * const { count } = await prisma.affiliate_Pending_Payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Affiliate_Pending_PaymentsDeleteManyArgs>(args?: SelectSubset<T, Affiliate_Pending_PaymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affiliate_Pending_Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_Pending_PaymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Affiliate_Pending_Payments
     * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Affiliate_Pending_PaymentsUpdateManyArgs>(args: SelectSubset<T, Affiliate_Pending_PaymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affiliate_Pending_Payments and returns the data updated in the database.
     * @param {Affiliate_Pending_PaymentsUpdateManyAndReturnArgs} args - Arguments to update many Affiliate_Pending_Payments.
     * @example
     * // Update many Affiliate_Pending_Payments
     * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Affiliate_Pending_Payments and only return the `id`
     * const affiliate_Pending_PaymentsWithIdOnly = await prisma.affiliate_Pending_Payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Affiliate_Pending_PaymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, Affiliate_Pending_PaymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Affiliate_Pending_Payments.
     * @param {Affiliate_Pending_PaymentsUpsertArgs} args - Arguments to update or create a Affiliate_Pending_Payments.
     * @example
     * // Update or create a Affiliate_Pending_Payments
     * const affiliate_Pending_Payments = await prisma.affiliate_Pending_Payments.upsert({
     *   create: {
     *     // ... data to create a Affiliate_Pending_Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Affiliate_Pending_Payments we want to update
     *   }
     * })
     */
    upsert<T extends Affiliate_Pending_PaymentsUpsertArgs>(args: SelectSubset<T, Affiliate_Pending_PaymentsUpsertArgs<ExtArgs>>): Prisma__Affiliate_Pending_PaymentsClient<$Result.GetResult<Prisma.$Affiliate_Pending_PaymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Affiliate_Pending_Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_Pending_PaymentsCountArgs} args - Arguments to filter Affiliate_Pending_Payments to count.
     * @example
     * // Count the number of Affiliate_Pending_Payments
     * const count = await prisma.affiliate_Pending_Payments.count({
     *   where: {
     *     // ... the filter for the Affiliate_Pending_Payments we want to count
     *   }
     * })
    **/
    count<T extends Affiliate_Pending_PaymentsCountArgs>(
      args?: Subset<T, Affiliate_Pending_PaymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Affiliate_Pending_PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Affiliate_Pending_Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_Pending_PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Affiliate_Pending_PaymentsAggregateArgs>(args: Subset<T, Affiliate_Pending_PaymentsAggregateArgs>): Prisma.PrismaPromise<GetAffiliate_Pending_PaymentsAggregateType<T>>

    /**
     * Group by Affiliate_Pending_Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliate_Pending_PaymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Affiliate_Pending_PaymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Affiliate_Pending_PaymentsGroupByArgs['orderBy'] }
        : { orderBy?: Affiliate_Pending_PaymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Affiliate_Pending_PaymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliate_Pending_PaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Affiliate_Pending_Payments model
   */
  readonly fields: Affiliate_Pending_PaymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Affiliate_Pending_Payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Affiliate_Pending_PaymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Affiliate_Pending_Payments model
   */
  interface Affiliate_Pending_PaymentsFieldRefs {
    readonly id: FieldRef<"Affiliate_Pending_Payments", 'String'>
    readonly affiliate_id: FieldRef<"Affiliate_Pending_Payments", 'Int'>
    readonly product_id: FieldRef<"Affiliate_Pending_Payments", 'Int'>
    readonly full_amount: FieldRef<"Affiliate_Pending_Payments", 'Decimal'>
    readonly fiat_amount: FieldRef<"Affiliate_Pending_Payments", 'Decimal'>
    readonly crypto_amount: FieldRef<"Affiliate_Pending_Payments", 'Decimal'>
    readonly payout_date: FieldRef<"Affiliate_Pending_Payments", 'DateTime'>
    readonly status: FieldRef<"Affiliate_Pending_Payments", 'String'>
    readonly created_at: FieldRef<"Affiliate_Pending_Payments", 'DateTime'>
    readonly updated_at: FieldRef<"Affiliate_Pending_Payments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Affiliate_Pending_Payments findUnique
   */
  export type Affiliate_Pending_PaymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate_Pending_Payments to fetch.
     */
    where: Affiliate_Pending_PaymentsWhereUniqueInput
  }

  /**
   * Affiliate_Pending_Payments findUniqueOrThrow
   */
  export type Affiliate_Pending_PaymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate_Pending_Payments to fetch.
     */
    where: Affiliate_Pending_PaymentsWhereUniqueInput
  }

  /**
   * Affiliate_Pending_Payments findFirst
   */
  export type Affiliate_Pending_PaymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate_Pending_Payments to fetch.
     */
    where?: Affiliate_Pending_PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliate_Pending_Payments to fetch.
     */
    orderBy?: Affiliate_Pending_PaymentsOrderByWithRelationInput | Affiliate_Pending_PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Affiliate_Pending_Payments.
     */
    cursor?: Affiliate_Pending_PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliate_Pending_Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliate_Pending_Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Affiliate_Pending_Payments.
     */
    distinct?: Affiliate_Pending_PaymentsScalarFieldEnum | Affiliate_Pending_PaymentsScalarFieldEnum[]
  }

  /**
   * Affiliate_Pending_Payments findFirstOrThrow
   */
  export type Affiliate_Pending_PaymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate_Pending_Payments to fetch.
     */
    where?: Affiliate_Pending_PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliate_Pending_Payments to fetch.
     */
    orderBy?: Affiliate_Pending_PaymentsOrderByWithRelationInput | Affiliate_Pending_PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Affiliate_Pending_Payments.
     */
    cursor?: Affiliate_Pending_PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliate_Pending_Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliate_Pending_Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Affiliate_Pending_Payments.
     */
    distinct?: Affiliate_Pending_PaymentsScalarFieldEnum | Affiliate_Pending_PaymentsScalarFieldEnum[]
  }

  /**
   * Affiliate_Pending_Payments findMany
   */
  export type Affiliate_Pending_PaymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate_Pending_Payments to fetch.
     */
    where?: Affiliate_Pending_PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliate_Pending_Payments to fetch.
     */
    orderBy?: Affiliate_Pending_PaymentsOrderByWithRelationInput | Affiliate_Pending_PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Affiliate_Pending_Payments.
     */
    cursor?: Affiliate_Pending_PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliate_Pending_Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliate_Pending_Payments.
     */
    skip?: number
    distinct?: Affiliate_Pending_PaymentsScalarFieldEnum | Affiliate_Pending_PaymentsScalarFieldEnum[]
  }

  /**
   * Affiliate_Pending_Payments create
   */
  export type Affiliate_Pending_PaymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Affiliate_Pending_Payments.
     */
    data: XOR<Affiliate_Pending_PaymentsCreateInput, Affiliate_Pending_PaymentsUncheckedCreateInput>
  }

  /**
   * Affiliate_Pending_Payments createMany
   */
  export type Affiliate_Pending_PaymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Affiliate_Pending_Payments.
     */
    data: Affiliate_Pending_PaymentsCreateManyInput | Affiliate_Pending_PaymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Affiliate_Pending_Payments createManyAndReturn
   */
  export type Affiliate_Pending_PaymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * The data used to create many Affiliate_Pending_Payments.
     */
    data: Affiliate_Pending_PaymentsCreateManyInput | Affiliate_Pending_PaymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Affiliate_Pending_Payments update
   */
  export type Affiliate_Pending_PaymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Affiliate_Pending_Payments.
     */
    data: XOR<Affiliate_Pending_PaymentsUpdateInput, Affiliate_Pending_PaymentsUncheckedUpdateInput>
    /**
     * Choose, which Affiliate_Pending_Payments to update.
     */
    where: Affiliate_Pending_PaymentsWhereUniqueInput
  }

  /**
   * Affiliate_Pending_Payments updateMany
   */
  export type Affiliate_Pending_PaymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Affiliate_Pending_Payments.
     */
    data: XOR<Affiliate_Pending_PaymentsUpdateManyMutationInput, Affiliate_Pending_PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Affiliate_Pending_Payments to update
     */
    where?: Affiliate_Pending_PaymentsWhereInput
    /**
     * Limit how many Affiliate_Pending_Payments to update.
     */
    limit?: number
  }

  /**
   * Affiliate_Pending_Payments updateManyAndReturn
   */
  export type Affiliate_Pending_PaymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * The data used to update Affiliate_Pending_Payments.
     */
    data: XOR<Affiliate_Pending_PaymentsUpdateManyMutationInput, Affiliate_Pending_PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Affiliate_Pending_Payments to update
     */
    where?: Affiliate_Pending_PaymentsWhereInput
    /**
     * Limit how many Affiliate_Pending_Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Affiliate_Pending_Payments upsert
   */
  export type Affiliate_Pending_PaymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Affiliate_Pending_Payments to update in case it exists.
     */
    where: Affiliate_Pending_PaymentsWhereUniqueInput
    /**
     * In case the Affiliate_Pending_Payments found by the `where` argument doesn't exist, create a new Affiliate_Pending_Payments with this data.
     */
    create: XOR<Affiliate_Pending_PaymentsCreateInput, Affiliate_Pending_PaymentsUncheckedCreateInput>
    /**
     * In case the Affiliate_Pending_Payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Affiliate_Pending_PaymentsUpdateInput, Affiliate_Pending_PaymentsUncheckedUpdateInput>
  }

  /**
   * Affiliate_Pending_Payments delete
   */
  export type Affiliate_Pending_PaymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsInclude<ExtArgs> | null
    /**
     * Filter which Affiliate_Pending_Payments to delete.
     */
    where: Affiliate_Pending_PaymentsWhereUniqueInput
  }

  /**
   * Affiliate_Pending_Payments deleteMany
   */
  export type Affiliate_Pending_PaymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Affiliate_Pending_Payments to delete
     */
    where?: Affiliate_Pending_PaymentsWhereInput
    /**
     * Limit how many Affiliate_Pending_Payments to delete.
     */
    limit?: number
  }

  /**
   * Affiliate_Pending_Payments without action
   */
  export type Affiliate_Pending_PaymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Pending_Payments
     */
    select?: Affiliate_Pending_PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Pending_Payments
     */
    omit?: Affiliate_Pending_PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_Pending_PaymentsInclude<ExtArgs> | null
  }


  /**
   * Model embeddings
   */

  export type AggregateEmbeddings = {
    _count: EmbeddingsCountAggregateOutputType | null
    _avg: EmbeddingsAvgAggregateOutputType | null
    _sum: EmbeddingsSumAggregateOutputType | null
    _min: EmbeddingsMinAggregateOutputType | null
    _max: EmbeddingsMaxAggregateOutputType | null
  }

  export type EmbeddingsAvgAggregateOutputType = {
    id: number | null
    resource_id: number | null
  }

  export type EmbeddingsSumAggregateOutputType = {
    id: bigint | null
    resource_id: bigint | null
  }

  export type EmbeddingsMinAggregateOutputType = {
    id: bigint | null
    created_at: Date | null
    content: string | null
    resource_id: bigint | null
  }

  export type EmbeddingsMaxAggregateOutputType = {
    id: bigint | null
    created_at: Date | null
    content: string | null
    resource_id: bigint | null
  }

  export type EmbeddingsCountAggregateOutputType = {
    id: number
    created_at: number
    content: number
    resource_id: number
    _all: number
  }


  export type EmbeddingsAvgAggregateInputType = {
    id?: true
    resource_id?: true
  }

  export type EmbeddingsSumAggregateInputType = {
    id?: true
    resource_id?: true
  }

  export type EmbeddingsMinAggregateInputType = {
    id?: true
    created_at?: true
    content?: true
    resource_id?: true
  }

  export type EmbeddingsMaxAggregateInputType = {
    id?: true
    created_at?: true
    content?: true
    resource_id?: true
  }

  export type EmbeddingsCountAggregateInputType = {
    id?: true
    created_at?: true
    content?: true
    resource_id?: true
    _all?: true
  }

  export type EmbeddingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which embeddings to aggregate.
     */
    where?: embeddingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of embeddings to fetch.
     */
    orderBy?: embeddingsOrderByWithRelationInput | embeddingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: embeddingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` embeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned embeddings
    **/
    _count?: true | EmbeddingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmbeddingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmbeddingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmbeddingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmbeddingsMaxAggregateInputType
  }

  export type GetEmbeddingsAggregateType<T extends EmbeddingsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmbeddings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmbeddings[P]>
      : GetScalarType<T[P], AggregateEmbeddings[P]>
  }




  export type embeddingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: embeddingsWhereInput
    orderBy?: embeddingsOrderByWithAggregationInput | embeddingsOrderByWithAggregationInput[]
    by: EmbeddingsScalarFieldEnum[] | EmbeddingsScalarFieldEnum
    having?: embeddingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmbeddingsCountAggregateInputType | true
    _avg?: EmbeddingsAvgAggregateInputType
    _sum?: EmbeddingsSumAggregateInputType
    _min?: EmbeddingsMinAggregateInputType
    _max?: EmbeddingsMaxAggregateInputType
  }

  export type EmbeddingsGroupByOutputType = {
    id: bigint
    created_at: Date
    content: string | null
    resource_id: bigint | null
    _count: EmbeddingsCountAggregateOutputType | null
    _avg: EmbeddingsAvgAggregateOutputType | null
    _sum: EmbeddingsSumAggregateOutputType | null
    _min: EmbeddingsMinAggregateOutputType | null
    _max: EmbeddingsMaxAggregateOutputType | null
  }

  type GetEmbeddingsGroupByPayload<T extends embeddingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmbeddingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmbeddingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmbeddingsGroupByOutputType[P]>
            : GetScalarType<T[P], EmbeddingsGroupByOutputType[P]>
        }
      >
    >


  export type embeddingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    content?: boolean
    resource_id?: boolean
    resources?: boolean | embeddings$resourcesArgs<ExtArgs>
  }, ExtArgs["result"]["embeddings"]>

  export type embeddingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    content?: boolean
    resource_id?: boolean
    resources?: boolean | embeddings$resourcesArgs<ExtArgs>
  }, ExtArgs["result"]["embeddings"]>

  export type embeddingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    content?: boolean
    resource_id?: boolean
    resources?: boolean | embeddings$resourcesArgs<ExtArgs>
  }, ExtArgs["result"]["embeddings"]>

  export type embeddingsSelectScalar = {
    id?: boolean
    created_at?: boolean
    content?: boolean
    resource_id?: boolean
  }

  export type embeddingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "content" | "resource_id", ExtArgs["result"]["embeddings"]>
  export type embeddingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resources?: boolean | embeddings$resourcesArgs<ExtArgs>
  }
  export type embeddingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resources?: boolean | embeddings$resourcesArgs<ExtArgs>
  }
  export type embeddingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resources?: boolean | embeddings$resourcesArgs<ExtArgs>
  }

  export type $embeddingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "embeddings"
    objects: {
      resources: Prisma.$resourcesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      created_at: Date
      content: string | null
      resource_id: bigint | null
    }, ExtArgs["result"]["embeddings"]>
    composites: {}
  }

  type embeddingsGetPayload<S extends boolean | null | undefined | embeddingsDefaultArgs> = $Result.GetResult<Prisma.$embeddingsPayload, S>

  type embeddingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<embeddingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmbeddingsCountAggregateInputType | true
    }

  export interface embeddingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['embeddings'], meta: { name: 'embeddings' } }
    /**
     * Find zero or one Embeddings that matches the filter.
     * @param {embeddingsFindUniqueArgs} args - Arguments to find a Embeddings
     * @example
     * // Get one Embeddings
     * const embeddings = await prisma.embeddings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends embeddingsFindUniqueArgs>(args: SelectSubset<T, embeddingsFindUniqueArgs<ExtArgs>>): Prisma__embeddingsClient<$Result.GetResult<Prisma.$embeddingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Embeddings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {embeddingsFindUniqueOrThrowArgs} args - Arguments to find a Embeddings
     * @example
     * // Get one Embeddings
     * const embeddings = await prisma.embeddings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends embeddingsFindUniqueOrThrowArgs>(args: SelectSubset<T, embeddingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__embeddingsClient<$Result.GetResult<Prisma.$embeddingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Embeddings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {embeddingsFindFirstArgs} args - Arguments to find a Embeddings
     * @example
     * // Get one Embeddings
     * const embeddings = await prisma.embeddings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends embeddingsFindFirstArgs>(args?: SelectSubset<T, embeddingsFindFirstArgs<ExtArgs>>): Prisma__embeddingsClient<$Result.GetResult<Prisma.$embeddingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Embeddings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {embeddingsFindFirstOrThrowArgs} args - Arguments to find a Embeddings
     * @example
     * // Get one Embeddings
     * const embeddings = await prisma.embeddings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends embeddingsFindFirstOrThrowArgs>(args?: SelectSubset<T, embeddingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__embeddingsClient<$Result.GetResult<Prisma.$embeddingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Embeddings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {embeddingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Embeddings
     * const embeddings = await prisma.embeddings.findMany()
     * 
     * // Get first 10 Embeddings
     * const embeddings = await prisma.embeddings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const embeddingsWithIdOnly = await prisma.embeddings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends embeddingsFindManyArgs>(args?: SelectSubset<T, embeddingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$embeddingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Embeddings.
     * @param {embeddingsCreateArgs} args - Arguments to create a Embeddings.
     * @example
     * // Create one Embeddings
     * const Embeddings = await prisma.embeddings.create({
     *   data: {
     *     // ... data to create a Embeddings
     *   }
     * })
     * 
     */
    create<T extends embeddingsCreateArgs>(args: SelectSubset<T, embeddingsCreateArgs<ExtArgs>>): Prisma__embeddingsClient<$Result.GetResult<Prisma.$embeddingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Embeddings.
     * @param {embeddingsCreateManyArgs} args - Arguments to create many Embeddings.
     * @example
     * // Create many Embeddings
     * const embeddings = await prisma.embeddings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends embeddingsCreateManyArgs>(args?: SelectSubset<T, embeddingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Embeddings and returns the data saved in the database.
     * @param {embeddingsCreateManyAndReturnArgs} args - Arguments to create many Embeddings.
     * @example
     * // Create many Embeddings
     * const embeddings = await prisma.embeddings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Embeddings and only return the `id`
     * const embeddingsWithIdOnly = await prisma.embeddings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends embeddingsCreateManyAndReturnArgs>(args?: SelectSubset<T, embeddingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$embeddingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Embeddings.
     * @param {embeddingsDeleteArgs} args - Arguments to delete one Embeddings.
     * @example
     * // Delete one Embeddings
     * const Embeddings = await prisma.embeddings.delete({
     *   where: {
     *     // ... filter to delete one Embeddings
     *   }
     * })
     * 
     */
    delete<T extends embeddingsDeleteArgs>(args: SelectSubset<T, embeddingsDeleteArgs<ExtArgs>>): Prisma__embeddingsClient<$Result.GetResult<Prisma.$embeddingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Embeddings.
     * @param {embeddingsUpdateArgs} args - Arguments to update one Embeddings.
     * @example
     * // Update one Embeddings
     * const embeddings = await prisma.embeddings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends embeddingsUpdateArgs>(args: SelectSubset<T, embeddingsUpdateArgs<ExtArgs>>): Prisma__embeddingsClient<$Result.GetResult<Prisma.$embeddingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Embeddings.
     * @param {embeddingsDeleteManyArgs} args - Arguments to filter Embeddings to delete.
     * @example
     * // Delete a few Embeddings
     * const { count } = await prisma.embeddings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends embeddingsDeleteManyArgs>(args?: SelectSubset<T, embeddingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Embeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {embeddingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Embeddings
     * const embeddings = await prisma.embeddings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends embeddingsUpdateManyArgs>(args: SelectSubset<T, embeddingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Embeddings and returns the data updated in the database.
     * @param {embeddingsUpdateManyAndReturnArgs} args - Arguments to update many Embeddings.
     * @example
     * // Update many Embeddings
     * const embeddings = await prisma.embeddings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Embeddings and only return the `id`
     * const embeddingsWithIdOnly = await prisma.embeddings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends embeddingsUpdateManyAndReturnArgs>(args: SelectSubset<T, embeddingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$embeddingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Embeddings.
     * @param {embeddingsUpsertArgs} args - Arguments to update or create a Embeddings.
     * @example
     * // Update or create a Embeddings
     * const embeddings = await prisma.embeddings.upsert({
     *   create: {
     *     // ... data to create a Embeddings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Embeddings we want to update
     *   }
     * })
     */
    upsert<T extends embeddingsUpsertArgs>(args: SelectSubset<T, embeddingsUpsertArgs<ExtArgs>>): Prisma__embeddingsClient<$Result.GetResult<Prisma.$embeddingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Embeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {embeddingsCountArgs} args - Arguments to filter Embeddings to count.
     * @example
     * // Count the number of Embeddings
     * const count = await prisma.embeddings.count({
     *   where: {
     *     // ... the filter for the Embeddings we want to count
     *   }
     * })
    **/
    count<T extends embeddingsCountArgs>(
      args?: Subset<T, embeddingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmbeddingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Embeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmbeddingsAggregateArgs>(args: Subset<T, EmbeddingsAggregateArgs>): Prisma.PrismaPromise<GetEmbeddingsAggregateType<T>>

    /**
     * Group by Embeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {embeddingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends embeddingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: embeddingsGroupByArgs['orderBy'] }
        : { orderBy?: embeddingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, embeddingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmbeddingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the embeddings model
   */
  readonly fields: embeddingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for embeddings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__embeddingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resources<T extends embeddings$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, embeddings$resourcesArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the embeddings model
   */
  interface embeddingsFieldRefs {
    readonly id: FieldRef<"embeddings", 'BigInt'>
    readonly created_at: FieldRef<"embeddings", 'DateTime'>
    readonly content: FieldRef<"embeddings", 'String'>
    readonly resource_id: FieldRef<"embeddings", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * embeddings findUnique
   */
  export type embeddingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsInclude<ExtArgs> | null
    /**
     * Filter, which embeddings to fetch.
     */
    where: embeddingsWhereUniqueInput
  }

  /**
   * embeddings findUniqueOrThrow
   */
  export type embeddingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsInclude<ExtArgs> | null
    /**
     * Filter, which embeddings to fetch.
     */
    where: embeddingsWhereUniqueInput
  }

  /**
   * embeddings findFirst
   */
  export type embeddingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsInclude<ExtArgs> | null
    /**
     * Filter, which embeddings to fetch.
     */
    where?: embeddingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of embeddings to fetch.
     */
    orderBy?: embeddingsOrderByWithRelationInput | embeddingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for embeddings.
     */
    cursor?: embeddingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` embeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of embeddings.
     */
    distinct?: EmbeddingsScalarFieldEnum | EmbeddingsScalarFieldEnum[]
  }

  /**
   * embeddings findFirstOrThrow
   */
  export type embeddingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsInclude<ExtArgs> | null
    /**
     * Filter, which embeddings to fetch.
     */
    where?: embeddingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of embeddings to fetch.
     */
    orderBy?: embeddingsOrderByWithRelationInput | embeddingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for embeddings.
     */
    cursor?: embeddingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` embeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of embeddings.
     */
    distinct?: EmbeddingsScalarFieldEnum | EmbeddingsScalarFieldEnum[]
  }

  /**
   * embeddings findMany
   */
  export type embeddingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsInclude<ExtArgs> | null
    /**
     * Filter, which embeddings to fetch.
     */
    where?: embeddingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of embeddings to fetch.
     */
    orderBy?: embeddingsOrderByWithRelationInput | embeddingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing embeddings.
     */
    cursor?: embeddingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` embeddings.
     */
    skip?: number
    distinct?: EmbeddingsScalarFieldEnum | EmbeddingsScalarFieldEnum[]
  }

  /**
   * embeddings create
   */
  export type embeddingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsInclude<ExtArgs> | null
    /**
     * The data needed to create a embeddings.
     */
    data?: XOR<embeddingsCreateInput, embeddingsUncheckedCreateInput>
  }

  /**
   * embeddings createMany
   */
  export type embeddingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many embeddings.
     */
    data: embeddingsCreateManyInput | embeddingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * embeddings createManyAndReturn
   */
  export type embeddingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * The data used to create many embeddings.
     */
    data: embeddingsCreateManyInput | embeddingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * embeddings update
   */
  export type embeddingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsInclude<ExtArgs> | null
    /**
     * The data needed to update a embeddings.
     */
    data: XOR<embeddingsUpdateInput, embeddingsUncheckedUpdateInput>
    /**
     * Choose, which embeddings to update.
     */
    where: embeddingsWhereUniqueInput
  }

  /**
   * embeddings updateMany
   */
  export type embeddingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update embeddings.
     */
    data: XOR<embeddingsUpdateManyMutationInput, embeddingsUncheckedUpdateManyInput>
    /**
     * Filter which embeddings to update
     */
    where?: embeddingsWhereInput
    /**
     * Limit how many embeddings to update.
     */
    limit?: number
  }

  /**
   * embeddings updateManyAndReturn
   */
  export type embeddingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * The data used to update embeddings.
     */
    data: XOR<embeddingsUpdateManyMutationInput, embeddingsUncheckedUpdateManyInput>
    /**
     * Filter which embeddings to update
     */
    where?: embeddingsWhereInput
    /**
     * Limit how many embeddings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * embeddings upsert
   */
  export type embeddingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsInclude<ExtArgs> | null
    /**
     * The filter to search for the embeddings to update in case it exists.
     */
    where: embeddingsWhereUniqueInput
    /**
     * In case the embeddings found by the `where` argument doesn't exist, create a new embeddings with this data.
     */
    create: XOR<embeddingsCreateInput, embeddingsUncheckedCreateInput>
    /**
     * In case the embeddings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<embeddingsUpdateInput, embeddingsUncheckedUpdateInput>
  }

  /**
   * embeddings delete
   */
  export type embeddingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsInclude<ExtArgs> | null
    /**
     * Filter which embeddings to delete.
     */
    where: embeddingsWhereUniqueInput
  }

  /**
   * embeddings deleteMany
   */
  export type embeddingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which embeddings to delete
     */
    where?: embeddingsWhereInput
    /**
     * Limit how many embeddings to delete.
     */
    limit?: number
  }

  /**
   * embeddings.resources
   */
  export type embeddings$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    where?: resourcesWhereInput
  }

  /**
   * embeddings without action
   */
  export type embeddingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsInclude<ExtArgs> | null
  }


  /**
   * Model ig_chat_history
   */

  export type AggregateIg_chat_history = {
    _count: Ig_chat_historyCountAggregateOutputType | null
    _avg: Ig_chat_historyAvgAggregateOutputType | null
    _sum: Ig_chat_historySumAggregateOutputType | null
    _min: Ig_chat_historyMinAggregateOutputType | null
    _max: Ig_chat_historyMaxAggregateOutputType | null
  }

  export type Ig_chat_historyAvgAggregateOutputType = {
    id: number | null
  }

  export type Ig_chat_historySumAggregateOutputType = {
    id: bigint | null
  }

  export type Ig_chat_historyMinAggregateOutputType = {
    id: bigint | null
    created_at: Date | null
    ig_recipient_id: string | null
    message: string | null
    role: string | null
  }

  export type Ig_chat_historyMaxAggregateOutputType = {
    id: bigint | null
    created_at: Date | null
    ig_recipient_id: string | null
    message: string | null
    role: string | null
  }

  export type Ig_chat_historyCountAggregateOutputType = {
    id: number
    created_at: number
    ig_recipient_id: number
    message: number
    role: number
    _all: number
  }


  export type Ig_chat_historyAvgAggregateInputType = {
    id?: true
  }

  export type Ig_chat_historySumAggregateInputType = {
    id?: true
  }

  export type Ig_chat_historyMinAggregateInputType = {
    id?: true
    created_at?: true
    ig_recipient_id?: true
    message?: true
    role?: true
  }

  export type Ig_chat_historyMaxAggregateInputType = {
    id?: true
    created_at?: true
    ig_recipient_id?: true
    message?: true
    role?: true
  }

  export type Ig_chat_historyCountAggregateInputType = {
    id?: true
    created_at?: true
    ig_recipient_id?: true
    message?: true
    role?: true
    _all?: true
  }

  export type Ig_chat_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ig_chat_history to aggregate.
     */
    where?: ig_chat_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ig_chat_histories to fetch.
     */
    orderBy?: ig_chat_historyOrderByWithRelationInput | ig_chat_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ig_chat_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ig_chat_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ig_chat_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ig_chat_histories
    **/
    _count?: true | Ig_chat_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ig_chat_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ig_chat_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ig_chat_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ig_chat_historyMaxAggregateInputType
  }

  export type GetIg_chat_historyAggregateType<T extends Ig_chat_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateIg_chat_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIg_chat_history[P]>
      : GetScalarType<T[P], AggregateIg_chat_history[P]>
  }




  export type ig_chat_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ig_chat_historyWhereInput
    orderBy?: ig_chat_historyOrderByWithAggregationInput | ig_chat_historyOrderByWithAggregationInput[]
    by: Ig_chat_historyScalarFieldEnum[] | Ig_chat_historyScalarFieldEnum
    having?: ig_chat_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ig_chat_historyCountAggregateInputType | true
    _avg?: Ig_chat_historyAvgAggregateInputType
    _sum?: Ig_chat_historySumAggregateInputType
    _min?: Ig_chat_historyMinAggregateInputType
    _max?: Ig_chat_historyMaxAggregateInputType
  }

  export type Ig_chat_historyGroupByOutputType = {
    id: bigint
    created_at: Date
    ig_recipient_id: string | null
    message: string | null
    role: string | null
    _count: Ig_chat_historyCountAggregateOutputType | null
    _avg: Ig_chat_historyAvgAggregateOutputType | null
    _sum: Ig_chat_historySumAggregateOutputType | null
    _min: Ig_chat_historyMinAggregateOutputType | null
    _max: Ig_chat_historyMaxAggregateOutputType | null
  }

  type GetIg_chat_historyGroupByPayload<T extends ig_chat_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ig_chat_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ig_chat_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ig_chat_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Ig_chat_historyGroupByOutputType[P]>
        }
      >
    >


  export type ig_chat_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    ig_recipient_id?: boolean
    message?: boolean
    role?: boolean
  }, ExtArgs["result"]["ig_chat_history"]>

  export type ig_chat_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    ig_recipient_id?: boolean
    message?: boolean
    role?: boolean
  }, ExtArgs["result"]["ig_chat_history"]>

  export type ig_chat_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    ig_recipient_id?: boolean
    message?: boolean
    role?: boolean
  }, ExtArgs["result"]["ig_chat_history"]>

  export type ig_chat_historySelectScalar = {
    id?: boolean
    created_at?: boolean
    ig_recipient_id?: boolean
    message?: boolean
    role?: boolean
  }

  export type ig_chat_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "ig_recipient_id" | "message" | "role", ExtArgs["result"]["ig_chat_history"]>

  export type $ig_chat_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ig_chat_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      created_at: Date
      ig_recipient_id: string | null
      message: string | null
      role: string | null
    }, ExtArgs["result"]["ig_chat_history"]>
    composites: {}
  }

  type ig_chat_historyGetPayload<S extends boolean | null | undefined | ig_chat_historyDefaultArgs> = $Result.GetResult<Prisma.$ig_chat_historyPayload, S>

  type ig_chat_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ig_chat_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ig_chat_historyCountAggregateInputType | true
    }

  export interface ig_chat_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ig_chat_history'], meta: { name: 'ig_chat_history' } }
    /**
     * Find zero or one Ig_chat_history that matches the filter.
     * @param {ig_chat_historyFindUniqueArgs} args - Arguments to find a Ig_chat_history
     * @example
     * // Get one Ig_chat_history
     * const ig_chat_history = await prisma.ig_chat_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ig_chat_historyFindUniqueArgs>(args: SelectSubset<T, ig_chat_historyFindUniqueArgs<ExtArgs>>): Prisma__ig_chat_historyClient<$Result.GetResult<Prisma.$ig_chat_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ig_chat_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ig_chat_historyFindUniqueOrThrowArgs} args - Arguments to find a Ig_chat_history
     * @example
     * // Get one Ig_chat_history
     * const ig_chat_history = await prisma.ig_chat_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ig_chat_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, ig_chat_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ig_chat_historyClient<$Result.GetResult<Prisma.$ig_chat_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ig_chat_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_chat_historyFindFirstArgs} args - Arguments to find a Ig_chat_history
     * @example
     * // Get one Ig_chat_history
     * const ig_chat_history = await prisma.ig_chat_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ig_chat_historyFindFirstArgs>(args?: SelectSubset<T, ig_chat_historyFindFirstArgs<ExtArgs>>): Prisma__ig_chat_historyClient<$Result.GetResult<Prisma.$ig_chat_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ig_chat_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_chat_historyFindFirstOrThrowArgs} args - Arguments to find a Ig_chat_history
     * @example
     * // Get one Ig_chat_history
     * const ig_chat_history = await prisma.ig_chat_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ig_chat_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, ig_chat_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ig_chat_historyClient<$Result.GetResult<Prisma.$ig_chat_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ig_chat_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_chat_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ig_chat_histories
     * const ig_chat_histories = await prisma.ig_chat_history.findMany()
     * 
     * // Get first 10 Ig_chat_histories
     * const ig_chat_histories = await prisma.ig_chat_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ig_chat_historyWithIdOnly = await prisma.ig_chat_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ig_chat_historyFindManyArgs>(args?: SelectSubset<T, ig_chat_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ig_chat_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ig_chat_history.
     * @param {ig_chat_historyCreateArgs} args - Arguments to create a Ig_chat_history.
     * @example
     * // Create one Ig_chat_history
     * const Ig_chat_history = await prisma.ig_chat_history.create({
     *   data: {
     *     // ... data to create a Ig_chat_history
     *   }
     * })
     * 
     */
    create<T extends ig_chat_historyCreateArgs>(args: SelectSubset<T, ig_chat_historyCreateArgs<ExtArgs>>): Prisma__ig_chat_historyClient<$Result.GetResult<Prisma.$ig_chat_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ig_chat_histories.
     * @param {ig_chat_historyCreateManyArgs} args - Arguments to create many Ig_chat_histories.
     * @example
     * // Create many Ig_chat_histories
     * const ig_chat_history = await prisma.ig_chat_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ig_chat_historyCreateManyArgs>(args?: SelectSubset<T, ig_chat_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ig_chat_histories and returns the data saved in the database.
     * @param {ig_chat_historyCreateManyAndReturnArgs} args - Arguments to create many Ig_chat_histories.
     * @example
     * // Create many Ig_chat_histories
     * const ig_chat_history = await prisma.ig_chat_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ig_chat_histories and only return the `id`
     * const ig_chat_historyWithIdOnly = await prisma.ig_chat_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ig_chat_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, ig_chat_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ig_chat_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ig_chat_history.
     * @param {ig_chat_historyDeleteArgs} args - Arguments to delete one Ig_chat_history.
     * @example
     * // Delete one Ig_chat_history
     * const Ig_chat_history = await prisma.ig_chat_history.delete({
     *   where: {
     *     // ... filter to delete one Ig_chat_history
     *   }
     * })
     * 
     */
    delete<T extends ig_chat_historyDeleteArgs>(args: SelectSubset<T, ig_chat_historyDeleteArgs<ExtArgs>>): Prisma__ig_chat_historyClient<$Result.GetResult<Prisma.$ig_chat_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ig_chat_history.
     * @param {ig_chat_historyUpdateArgs} args - Arguments to update one Ig_chat_history.
     * @example
     * // Update one Ig_chat_history
     * const ig_chat_history = await prisma.ig_chat_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ig_chat_historyUpdateArgs>(args: SelectSubset<T, ig_chat_historyUpdateArgs<ExtArgs>>): Prisma__ig_chat_historyClient<$Result.GetResult<Prisma.$ig_chat_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ig_chat_histories.
     * @param {ig_chat_historyDeleteManyArgs} args - Arguments to filter Ig_chat_histories to delete.
     * @example
     * // Delete a few Ig_chat_histories
     * const { count } = await prisma.ig_chat_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ig_chat_historyDeleteManyArgs>(args?: SelectSubset<T, ig_chat_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ig_chat_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_chat_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ig_chat_histories
     * const ig_chat_history = await prisma.ig_chat_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ig_chat_historyUpdateManyArgs>(args: SelectSubset<T, ig_chat_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ig_chat_histories and returns the data updated in the database.
     * @param {ig_chat_historyUpdateManyAndReturnArgs} args - Arguments to update many Ig_chat_histories.
     * @example
     * // Update many Ig_chat_histories
     * const ig_chat_history = await prisma.ig_chat_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ig_chat_histories and only return the `id`
     * const ig_chat_historyWithIdOnly = await prisma.ig_chat_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ig_chat_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, ig_chat_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ig_chat_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ig_chat_history.
     * @param {ig_chat_historyUpsertArgs} args - Arguments to update or create a Ig_chat_history.
     * @example
     * // Update or create a Ig_chat_history
     * const ig_chat_history = await prisma.ig_chat_history.upsert({
     *   create: {
     *     // ... data to create a Ig_chat_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ig_chat_history we want to update
     *   }
     * })
     */
    upsert<T extends ig_chat_historyUpsertArgs>(args: SelectSubset<T, ig_chat_historyUpsertArgs<ExtArgs>>): Prisma__ig_chat_historyClient<$Result.GetResult<Prisma.$ig_chat_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ig_chat_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_chat_historyCountArgs} args - Arguments to filter Ig_chat_histories to count.
     * @example
     * // Count the number of Ig_chat_histories
     * const count = await prisma.ig_chat_history.count({
     *   where: {
     *     // ... the filter for the Ig_chat_histories we want to count
     *   }
     * })
    **/
    count<T extends ig_chat_historyCountArgs>(
      args?: Subset<T, ig_chat_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ig_chat_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ig_chat_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ig_chat_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ig_chat_historyAggregateArgs>(args: Subset<T, Ig_chat_historyAggregateArgs>): Prisma.PrismaPromise<GetIg_chat_historyAggregateType<T>>

    /**
     * Group by Ig_chat_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_chat_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ig_chat_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ig_chat_historyGroupByArgs['orderBy'] }
        : { orderBy?: ig_chat_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ig_chat_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIg_chat_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ig_chat_history model
   */
  readonly fields: ig_chat_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ig_chat_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ig_chat_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ig_chat_history model
   */
  interface ig_chat_historyFieldRefs {
    readonly id: FieldRef<"ig_chat_history", 'BigInt'>
    readonly created_at: FieldRef<"ig_chat_history", 'DateTime'>
    readonly ig_recipient_id: FieldRef<"ig_chat_history", 'String'>
    readonly message: FieldRef<"ig_chat_history", 'String'>
    readonly role: FieldRef<"ig_chat_history", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ig_chat_history findUnique
   */
  export type ig_chat_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_chat_history
     */
    select?: ig_chat_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_chat_history
     */
    omit?: ig_chat_historyOmit<ExtArgs> | null
    /**
     * Filter, which ig_chat_history to fetch.
     */
    where: ig_chat_historyWhereUniqueInput
  }

  /**
   * ig_chat_history findUniqueOrThrow
   */
  export type ig_chat_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_chat_history
     */
    select?: ig_chat_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_chat_history
     */
    omit?: ig_chat_historyOmit<ExtArgs> | null
    /**
     * Filter, which ig_chat_history to fetch.
     */
    where: ig_chat_historyWhereUniqueInput
  }

  /**
   * ig_chat_history findFirst
   */
  export type ig_chat_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_chat_history
     */
    select?: ig_chat_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_chat_history
     */
    omit?: ig_chat_historyOmit<ExtArgs> | null
    /**
     * Filter, which ig_chat_history to fetch.
     */
    where?: ig_chat_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ig_chat_histories to fetch.
     */
    orderBy?: ig_chat_historyOrderByWithRelationInput | ig_chat_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ig_chat_histories.
     */
    cursor?: ig_chat_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ig_chat_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ig_chat_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ig_chat_histories.
     */
    distinct?: Ig_chat_historyScalarFieldEnum | Ig_chat_historyScalarFieldEnum[]
  }

  /**
   * ig_chat_history findFirstOrThrow
   */
  export type ig_chat_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_chat_history
     */
    select?: ig_chat_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_chat_history
     */
    omit?: ig_chat_historyOmit<ExtArgs> | null
    /**
     * Filter, which ig_chat_history to fetch.
     */
    where?: ig_chat_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ig_chat_histories to fetch.
     */
    orderBy?: ig_chat_historyOrderByWithRelationInput | ig_chat_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ig_chat_histories.
     */
    cursor?: ig_chat_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ig_chat_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ig_chat_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ig_chat_histories.
     */
    distinct?: Ig_chat_historyScalarFieldEnum | Ig_chat_historyScalarFieldEnum[]
  }

  /**
   * ig_chat_history findMany
   */
  export type ig_chat_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_chat_history
     */
    select?: ig_chat_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_chat_history
     */
    omit?: ig_chat_historyOmit<ExtArgs> | null
    /**
     * Filter, which ig_chat_histories to fetch.
     */
    where?: ig_chat_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ig_chat_histories to fetch.
     */
    orderBy?: ig_chat_historyOrderByWithRelationInput | ig_chat_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ig_chat_histories.
     */
    cursor?: ig_chat_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ig_chat_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ig_chat_histories.
     */
    skip?: number
    distinct?: Ig_chat_historyScalarFieldEnum | Ig_chat_historyScalarFieldEnum[]
  }

  /**
   * ig_chat_history create
   */
  export type ig_chat_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_chat_history
     */
    select?: ig_chat_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_chat_history
     */
    omit?: ig_chat_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a ig_chat_history.
     */
    data?: XOR<ig_chat_historyCreateInput, ig_chat_historyUncheckedCreateInput>
  }

  /**
   * ig_chat_history createMany
   */
  export type ig_chat_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ig_chat_histories.
     */
    data: ig_chat_historyCreateManyInput | ig_chat_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ig_chat_history createManyAndReturn
   */
  export type ig_chat_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_chat_history
     */
    select?: ig_chat_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ig_chat_history
     */
    omit?: ig_chat_historyOmit<ExtArgs> | null
    /**
     * The data used to create many ig_chat_histories.
     */
    data: ig_chat_historyCreateManyInput | ig_chat_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ig_chat_history update
   */
  export type ig_chat_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_chat_history
     */
    select?: ig_chat_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_chat_history
     */
    omit?: ig_chat_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a ig_chat_history.
     */
    data: XOR<ig_chat_historyUpdateInput, ig_chat_historyUncheckedUpdateInput>
    /**
     * Choose, which ig_chat_history to update.
     */
    where: ig_chat_historyWhereUniqueInput
  }

  /**
   * ig_chat_history updateMany
   */
  export type ig_chat_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ig_chat_histories.
     */
    data: XOR<ig_chat_historyUpdateManyMutationInput, ig_chat_historyUncheckedUpdateManyInput>
    /**
     * Filter which ig_chat_histories to update
     */
    where?: ig_chat_historyWhereInput
    /**
     * Limit how many ig_chat_histories to update.
     */
    limit?: number
  }

  /**
   * ig_chat_history updateManyAndReturn
   */
  export type ig_chat_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_chat_history
     */
    select?: ig_chat_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ig_chat_history
     */
    omit?: ig_chat_historyOmit<ExtArgs> | null
    /**
     * The data used to update ig_chat_histories.
     */
    data: XOR<ig_chat_historyUpdateManyMutationInput, ig_chat_historyUncheckedUpdateManyInput>
    /**
     * Filter which ig_chat_histories to update
     */
    where?: ig_chat_historyWhereInput
    /**
     * Limit how many ig_chat_histories to update.
     */
    limit?: number
  }

  /**
   * ig_chat_history upsert
   */
  export type ig_chat_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_chat_history
     */
    select?: ig_chat_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_chat_history
     */
    omit?: ig_chat_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the ig_chat_history to update in case it exists.
     */
    where: ig_chat_historyWhereUniqueInput
    /**
     * In case the ig_chat_history found by the `where` argument doesn't exist, create a new ig_chat_history with this data.
     */
    create: XOR<ig_chat_historyCreateInput, ig_chat_historyUncheckedCreateInput>
    /**
     * In case the ig_chat_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ig_chat_historyUpdateInput, ig_chat_historyUncheckedUpdateInput>
  }

  /**
   * ig_chat_history delete
   */
  export type ig_chat_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_chat_history
     */
    select?: ig_chat_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_chat_history
     */
    omit?: ig_chat_historyOmit<ExtArgs> | null
    /**
     * Filter which ig_chat_history to delete.
     */
    where: ig_chat_historyWhereUniqueInput
  }

  /**
   * ig_chat_history deleteMany
   */
  export type ig_chat_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ig_chat_histories to delete
     */
    where?: ig_chat_historyWhereInput
    /**
     * Limit how many ig_chat_histories to delete.
     */
    limit?: number
  }

  /**
   * ig_chat_history without action
   */
  export type ig_chat_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_chat_history
     */
    select?: ig_chat_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_chat_history
     */
    omit?: ig_chat_historyOmit<ExtArgs> | null
  }


  /**
   * Model resources
   */

  export type AggregateResources = {
    _count: ResourcesCountAggregateOutputType | null
    _avg: ResourcesAvgAggregateOutputType | null
    _sum: ResourcesSumAggregateOutputType | null
    _min: ResourcesMinAggregateOutputType | null
    _max: ResourcesMaxAggregateOutputType | null
  }

  export type ResourcesAvgAggregateOutputType = {
    id: number | null
  }

  export type ResourcesSumAggregateOutputType = {
    id: bigint | null
  }

  export type ResourcesMinAggregateOutputType = {
    id: bigint | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ResourcesMaxAggregateOutputType = {
    id: bigint | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ResourcesCountAggregateOutputType = {
    id: number
    content: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ResourcesAvgAggregateInputType = {
    id?: true
  }

  export type ResourcesSumAggregateInputType = {
    id?: true
  }

  export type ResourcesMinAggregateInputType = {
    id?: true
    content?: true
    created_at?: true
    updated_at?: true
  }

  export type ResourcesMaxAggregateInputType = {
    id?: true
    content?: true
    created_at?: true
    updated_at?: true
  }

  export type ResourcesCountAggregateInputType = {
    id?: true
    content?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ResourcesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resources to aggregate.
     */
    where?: resourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourcesOrderByWithRelationInput | resourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: resourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned resources
    **/
    _count?: true | ResourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourcesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourcesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourcesMaxAggregateInputType
  }

  export type GetResourcesAggregateType<T extends ResourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateResources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResources[P]>
      : GetScalarType<T[P], AggregateResources[P]>
  }




  export type resourcesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resourcesWhereInput
    orderBy?: resourcesOrderByWithAggregationInput | resourcesOrderByWithAggregationInput[]
    by: ResourcesScalarFieldEnum[] | ResourcesScalarFieldEnum
    having?: resourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourcesCountAggregateInputType | true
    _avg?: ResourcesAvgAggregateInputType
    _sum?: ResourcesSumAggregateInputType
    _min?: ResourcesMinAggregateInputType
    _max?: ResourcesMaxAggregateInputType
  }

  export type ResourcesGroupByOutputType = {
    id: bigint
    content: string | null
    created_at: Date
    updated_at: Date | null
    _count: ResourcesCountAggregateOutputType | null
    _avg: ResourcesAvgAggregateOutputType | null
    _sum: ResourcesSumAggregateOutputType | null
    _min: ResourcesMinAggregateOutputType | null
    _max: ResourcesMaxAggregateOutputType | null
  }

  type GetResourcesGroupByPayload<T extends resourcesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourcesGroupByOutputType[P]>
            : GetScalarType<T[P], ResourcesGroupByOutputType[P]>
        }
      >
    >


  export type resourcesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    embeddings?: boolean | resources$embeddingsArgs<ExtArgs>
    _count?: boolean | ResourcesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resources"]>

  export type resourcesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["resources"]>

  export type resourcesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["resources"]>

  export type resourcesSelectScalar = {
    id?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type resourcesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "created_at" | "updated_at", ExtArgs["result"]["resources"]>
  export type resourcesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    embeddings?: boolean | resources$embeddingsArgs<ExtArgs>
    _count?: boolean | ResourcesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type resourcesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type resourcesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $resourcesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "resources"
    objects: {
      embeddings: Prisma.$embeddingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      content: string | null
      created_at: Date
      updated_at: Date | null
    }, ExtArgs["result"]["resources"]>
    composites: {}
  }

  type resourcesGetPayload<S extends boolean | null | undefined | resourcesDefaultArgs> = $Result.GetResult<Prisma.$resourcesPayload, S>

  type resourcesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<resourcesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourcesCountAggregateInputType | true
    }

  export interface resourcesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['resources'], meta: { name: 'resources' } }
    /**
     * Find zero or one Resources that matches the filter.
     * @param {resourcesFindUniqueArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends resourcesFindUniqueArgs>(args: SelectSubset<T, resourcesFindUniqueArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resources that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {resourcesFindUniqueOrThrowArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends resourcesFindUniqueOrThrowArgs>(args: SelectSubset<T, resourcesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourcesFindFirstArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends resourcesFindFirstArgs>(args?: SelectSubset<T, resourcesFindFirstArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resources that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourcesFindFirstOrThrowArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends resourcesFindFirstOrThrowArgs>(args?: SelectSubset<T, resourcesFindFirstOrThrowArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourcesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resources.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resources.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourcesWithIdOnly = await prisma.resources.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends resourcesFindManyArgs>(args?: SelectSubset<T, resourcesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resources.
     * @param {resourcesCreateArgs} args - Arguments to create a Resources.
     * @example
     * // Create one Resources
     * const Resources = await prisma.resources.create({
     *   data: {
     *     // ... data to create a Resources
     *   }
     * })
     * 
     */
    create<T extends resourcesCreateArgs>(args: SelectSubset<T, resourcesCreateArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {resourcesCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resources = await prisma.resources.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends resourcesCreateManyArgs>(args?: SelectSubset<T, resourcesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {resourcesCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resources = await prisma.resources.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourcesWithIdOnly = await prisma.resources.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends resourcesCreateManyAndReturnArgs>(args?: SelectSubset<T, resourcesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resources.
     * @param {resourcesDeleteArgs} args - Arguments to delete one Resources.
     * @example
     * // Delete one Resources
     * const Resources = await prisma.resources.delete({
     *   where: {
     *     // ... filter to delete one Resources
     *   }
     * })
     * 
     */
    delete<T extends resourcesDeleteArgs>(args: SelectSubset<T, resourcesDeleteArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resources.
     * @param {resourcesUpdateArgs} args - Arguments to update one Resources.
     * @example
     * // Update one Resources
     * const resources = await prisma.resources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends resourcesUpdateArgs>(args: SelectSubset<T, resourcesUpdateArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {resourcesDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends resourcesDeleteManyArgs>(args?: SelectSubset<T, resourcesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resources = await prisma.resources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends resourcesUpdateManyArgs>(args: SelectSubset<T, resourcesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {resourcesUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resources = await prisma.resources.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourcesWithIdOnly = await prisma.resources.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends resourcesUpdateManyAndReturnArgs>(args: SelectSubset<T, resourcesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resources.
     * @param {resourcesUpsertArgs} args - Arguments to update or create a Resources.
     * @example
     * // Update or create a Resources
     * const resources = await prisma.resources.upsert({
     *   create: {
     *     // ... data to create a Resources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resources we want to update
     *   }
     * })
     */
    upsert<T extends resourcesUpsertArgs>(args: SelectSubset<T, resourcesUpsertArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourcesCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resources.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends resourcesCountArgs>(
      args?: Subset<T, resourcesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourcesAggregateArgs>(args: Subset<T, ResourcesAggregateArgs>): Prisma.PrismaPromise<GetResourcesAggregateType<T>>

    /**
     * Group by Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends resourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: resourcesGroupByArgs['orderBy'] }
        : { orderBy?: resourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, resourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourcesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the resources model
   */
  readonly fields: resourcesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for resources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__resourcesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    embeddings<T extends resources$embeddingsArgs<ExtArgs> = {}>(args?: Subset<T, resources$embeddingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$embeddingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the resources model
   */
  interface resourcesFieldRefs {
    readonly id: FieldRef<"resources", 'BigInt'>
    readonly content: FieldRef<"resources", 'String'>
    readonly created_at: FieldRef<"resources", 'DateTime'>
    readonly updated_at: FieldRef<"resources", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * resources findUnique
   */
  export type resourcesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * Filter, which resources to fetch.
     */
    where: resourcesWhereUniqueInput
  }

  /**
   * resources findUniqueOrThrow
   */
  export type resourcesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * Filter, which resources to fetch.
     */
    where: resourcesWhereUniqueInput
  }

  /**
   * resources findFirst
   */
  export type resourcesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * Filter, which resources to fetch.
     */
    where?: resourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourcesOrderByWithRelationInput | resourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resources.
     */
    cursor?: resourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resources.
     */
    distinct?: ResourcesScalarFieldEnum | ResourcesScalarFieldEnum[]
  }

  /**
   * resources findFirstOrThrow
   */
  export type resourcesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * Filter, which resources to fetch.
     */
    where?: resourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourcesOrderByWithRelationInput | resourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resources.
     */
    cursor?: resourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resources.
     */
    distinct?: ResourcesScalarFieldEnum | ResourcesScalarFieldEnum[]
  }

  /**
   * resources findMany
   */
  export type resourcesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * Filter, which resources to fetch.
     */
    where?: resourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourcesOrderByWithRelationInput | resourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing resources.
     */
    cursor?: resourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    distinct?: ResourcesScalarFieldEnum | ResourcesScalarFieldEnum[]
  }

  /**
   * resources create
   */
  export type resourcesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * The data needed to create a resources.
     */
    data?: XOR<resourcesCreateInput, resourcesUncheckedCreateInput>
  }

  /**
   * resources createMany
   */
  export type resourcesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many resources.
     */
    data: resourcesCreateManyInput | resourcesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * resources createManyAndReturn
   */
  export type resourcesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * The data used to create many resources.
     */
    data: resourcesCreateManyInput | resourcesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * resources update
   */
  export type resourcesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * The data needed to update a resources.
     */
    data: XOR<resourcesUpdateInput, resourcesUncheckedUpdateInput>
    /**
     * Choose, which resources to update.
     */
    where: resourcesWhereUniqueInput
  }

  /**
   * resources updateMany
   */
  export type resourcesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update resources.
     */
    data: XOR<resourcesUpdateManyMutationInput, resourcesUncheckedUpdateManyInput>
    /**
     * Filter which resources to update
     */
    where?: resourcesWhereInput
    /**
     * Limit how many resources to update.
     */
    limit?: number
  }

  /**
   * resources updateManyAndReturn
   */
  export type resourcesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * The data used to update resources.
     */
    data: XOR<resourcesUpdateManyMutationInput, resourcesUncheckedUpdateManyInput>
    /**
     * Filter which resources to update
     */
    where?: resourcesWhereInput
    /**
     * Limit how many resources to update.
     */
    limit?: number
  }

  /**
   * resources upsert
   */
  export type resourcesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * The filter to search for the resources to update in case it exists.
     */
    where: resourcesWhereUniqueInput
    /**
     * In case the resources found by the `where` argument doesn't exist, create a new resources with this data.
     */
    create: XOR<resourcesCreateInput, resourcesUncheckedCreateInput>
    /**
     * In case the resources was found with the provided `where` argument, update it with this data.
     */
    update: XOR<resourcesUpdateInput, resourcesUncheckedUpdateInput>
  }

  /**
   * resources delete
   */
  export type resourcesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * Filter which resources to delete.
     */
    where: resourcesWhereUniqueInput
  }

  /**
   * resources deleteMany
   */
  export type resourcesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resources to delete
     */
    where?: resourcesWhereInput
    /**
     * Limit how many resources to delete.
     */
    limit?: number
  }

  /**
   * resources.embeddings
   */
  export type resources$embeddingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the embeddings
     */
    select?: embeddingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the embeddings
     */
    omit?: embeddingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: embeddingsInclude<ExtArgs> | null
    where?: embeddingsWhereInput
    orderBy?: embeddingsOrderByWithRelationInput | embeddingsOrderByWithRelationInput[]
    cursor?: embeddingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmbeddingsScalarFieldEnum | EmbeddingsScalarFieldEnum[]
  }

  /**
   * resources without action
   */
  export type resourcesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
  }


  /**
   * Model ig_access_token
   */

  export type AggregateIg_access_token = {
    _count: Ig_access_tokenCountAggregateOutputType | null
    _min: Ig_access_tokenMinAggregateOutputType | null
    _max: Ig_access_tokenMaxAggregateOutputType | null
  }

  export type Ig_access_tokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    encryption_iv: string | null
    expires_at: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ig_access_tokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    encryption_iv: string | null
    expires_at: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ig_access_tokenCountAggregateOutputType = {
    id: number
    token: number
    encryption_iv: number
    expires_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ig_access_tokenMinAggregateInputType = {
    id?: true
    token?: true
    encryption_iv?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Ig_access_tokenMaxAggregateInputType = {
    id?: true
    token?: true
    encryption_iv?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Ig_access_tokenCountAggregateInputType = {
    id?: true
    token?: true
    encryption_iv?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ig_access_tokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ig_access_token to aggregate.
     */
    where?: ig_access_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ig_access_tokens to fetch.
     */
    orderBy?: ig_access_tokenOrderByWithRelationInput | ig_access_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ig_access_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ig_access_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ig_access_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ig_access_tokens
    **/
    _count?: true | Ig_access_tokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ig_access_tokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ig_access_tokenMaxAggregateInputType
  }

  export type GetIg_access_tokenAggregateType<T extends Ig_access_tokenAggregateArgs> = {
        [P in keyof T & keyof AggregateIg_access_token]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIg_access_token[P]>
      : GetScalarType<T[P], AggregateIg_access_token[P]>
  }




  export type ig_access_tokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ig_access_tokenWhereInput
    orderBy?: ig_access_tokenOrderByWithAggregationInput | ig_access_tokenOrderByWithAggregationInput[]
    by: Ig_access_tokenScalarFieldEnum[] | Ig_access_tokenScalarFieldEnum
    having?: ig_access_tokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ig_access_tokenCountAggregateInputType | true
    _min?: Ig_access_tokenMinAggregateInputType
    _max?: Ig_access_tokenMaxAggregateInputType
  }

  export type Ig_access_tokenGroupByOutputType = {
    id: string
    token: string
    encryption_iv: string
    expires_at: string
    created_at: Date
    updated_at: Date
    _count: Ig_access_tokenCountAggregateOutputType | null
    _min: Ig_access_tokenMinAggregateOutputType | null
    _max: Ig_access_tokenMaxAggregateOutputType | null
  }

  type GetIg_access_tokenGroupByPayload<T extends ig_access_tokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ig_access_tokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ig_access_tokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ig_access_tokenGroupByOutputType[P]>
            : GetScalarType<T[P], Ig_access_tokenGroupByOutputType[P]>
        }
      >
    >


  export type ig_access_tokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    encryption_iv?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ig_access_token"]>

  export type ig_access_tokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    encryption_iv?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ig_access_token"]>

  export type ig_access_tokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    encryption_iv?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ig_access_token"]>

  export type ig_access_tokenSelectScalar = {
    id?: boolean
    token?: boolean
    encryption_iv?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ig_access_tokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "encryption_iv" | "expires_at" | "created_at" | "updated_at", ExtArgs["result"]["ig_access_token"]>

  export type $ig_access_tokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ig_access_token"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      encryption_iv: string
      expires_at: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["ig_access_token"]>
    composites: {}
  }

  type ig_access_tokenGetPayload<S extends boolean | null | undefined | ig_access_tokenDefaultArgs> = $Result.GetResult<Prisma.$ig_access_tokenPayload, S>

  type ig_access_tokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ig_access_tokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ig_access_tokenCountAggregateInputType | true
    }

  export interface ig_access_tokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ig_access_token'], meta: { name: 'ig_access_token' } }
    /**
     * Find zero or one Ig_access_token that matches the filter.
     * @param {ig_access_tokenFindUniqueArgs} args - Arguments to find a Ig_access_token
     * @example
     * // Get one Ig_access_token
     * const ig_access_token = await prisma.ig_access_token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ig_access_tokenFindUniqueArgs>(args: SelectSubset<T, ig_access_tokenFindUniqueArgs<ExtArgs>>): Prisma__ig_access_tokenClient<$Result.GetResult<Prisma.$ig_access_tokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ig_access_token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ig_access_tokenFindUniqueOrThrowArgs} args - Arguments to find a Ig_access_token
     * @example
     * // Get one Ig_access_token
     * const ig_access_token = await prisma.ig_access_token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ig_access_tokenFindUniqueOrThrowArgs>(args: SelectSubset<T, ig_access_tokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ig_access_tokenClient<$Result.GetResult<Prisma.$ig_access_tokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ig_access_token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_access_tokenFindFirstArgs} args - Arguments to find a Ig_access_token
     * @example
     * // Get one Ig_access_token
     * const ig_access_token = await prisma.ig_access_token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ig_access_tokenFindFirstArgs>(args?: SelectSubset<T, ig_access_tokenFindFirstArgs<ExtArgs>>): Prisma__ig_access_tokenClient<$Result.GetResult<Prisma.$ig_access_tokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ig_access_token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_access_tokenFindFirstOrThrowArgs} args - Arguments to find a Ig_access_token
     * @example
     * // Get one Ig_access_token
     * const ig_access_token = await prisma.ig_access_token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ig_access_tokenFindFirstOrThrowArgs>(args?: SelectSubset<T, ig_access_tokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__ig_access_tokenClient<$Result.GetResult<Prisma.$ig_access_tokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ig_access_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_access_tokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ig_access_tokens
     * const ig_access_tokens = await prisma.ig_access_token.findMany()
     * 
     * // Get first 10 Ig_access_tokens
     * const ig_access_tokens = await prisma.ig_access_token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ig_access_tokenWithIdOnly = await prisma.ig_access_token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ig_access_tokenFindManyArgs>(args?: SelectSubset<T, ig_access_tokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ig_access_tokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ig_access_token.
     * @param {ig_access_tokenCreateArgs} args - Arguments to create a Ig_access_token.
     * @example
     * // Create one Ig_access_token
     * const Ig_access_token = await prisma.ig_access_token.create({
     *   data: {
     *     // ... data to create a Ig_access_token
     *   }
     * })
     * 
     */
    create<T extends ig_access_tokenCreateArgs>(args: SelectSubset<T, ig_access_tokenCreateArgs<ExtArgs>>): Prisma__ig_access_tokenClient<$Result.GetResult<Prisma.$ig_access_tokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ig_access_tokens.
     * @param {ig_access_tokenCreateManyArgs} args - Arguments to create many Ig_access_tokens.
     * @example
     * // Create many Ig_access_tokens
     * const ig_access_token = await prisma.ig_access_token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ig_access_tokenCreateManyArgs>(args?: SelectSubset<T, ig_access_tokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ig_access_tokens and returns the data saved in the database.
     * @param {ig_access_tokenCreateManyAndReturnArgs} args - Arguments to create many Ig_access_tokens.
     * @example
     * // Create many Ig_access_tokens
     * const ig_access_token = await prisma.ig_access_token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ig_access_tokens and only return the `id`
     * const ig_access_tokenWithIdOnly = await prisma.ig_access_token.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ig_access_tokenCreateManyAndReturnArgs>(args?: SelectSubset<T, ig_access_tokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ig_access_tokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ig_access_token.
     * @param {ig_access_tokenDeleteArgs} args - Arguments to delete one Ig_access_token.
     * @example
     * // Delete one Ig_access_token
     * const Ig_access_token = await prisma.ig_access_token.delete({
     *   where: {
     *     // ... filter to delete one Ig_access_token
     *   }
     * })
     * 
     */
    delete<T extends ig_access_tokenDeleteArgs>(args: SelectSubset<T, ig_access_tokenDeleteArgs<ExtArgs>>): Prisma__ig_access_tokenClient<$Result.GetResult<Prisma.$ig_access_tokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ig_access_token.
     * @param {ig_access_tokenUpdateArgs} args - Arguments to update one Ig_access_token.
     * @example
     * // Update one Ig_access_token
     * const ig_access_token = await prisma.ig_access_token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ig_access_tokenUpdateArgs>(args: SelectSubset<T, ig_access_tokenUpdateArgs<ExtArgs>>): Prisma__ig_access_tokenClient<$Result.GetResult<Prisma.$ig_access_tokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ig_access_tokens.
     * @param {ig_access_tokenDeleteManyArgs} args - Arguments to filter Ig_access_tokens to delete.
     * @example
     * // Delete a few Ig_access_tokens
     * const { count } = await prisma.ig_access_token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ig_access_tokenDeleteManyArgs>(args?: SelectSubset<T, ig_access_tokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ig_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_access_tokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ig_access_tokens
     * const ig_access_token = await prisma.ig_access_token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ig_access_tokenUpdateManyArgs>(args: SelectSubset<T, ig_access_tokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ig_access_tokens and returns the data updated in the database.
     * @param {ig_access_tokenUpdateManyAndReturnArgs} args - Arguments to update many Ig_access_tokens.
     * @example
     * // Update many Ig_access_tokens
     * const ig_access_token = await prisma.ig_access_token.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ig_access_tokens and only return the `id`
     * const ig_access_tokenWithIdOnly = await prisma.ig_access_token.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ig_access_tokenUpdateManyAndReturnArgs>(args: SelectSubset<T, ig_access_tokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ig_access_tokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ig_access_token.
     * @param {ig_access_tokenUpsertArgs} args - Arguments to update or create a Ig_access_token.
     * @example
     * // Update or create a Ig_access_token
     * const ig_access_token = await prisma.ig_access_token.upsert({
     *   create: {
     *     // ... data to create a Ig_access_token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ig_access_token we want to update
     *   }
     * })
     */
    upsert<T extends ig_access_tokenUpsertArgs>(args: SelectSubset<T, ig_access_tokenUpsertArgs<ExtArgs>>): Prisma__ig_access_tokenClient<$Result.GetResult<Prisma.$ig_access_tokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ig_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_access_tokenCountArgs} args - Arguments to filter Ig_access_tokens to count.
     * @example
     * // Count the number of Ig_access_tokens
     * const count = await prisma.ig_access_token.count({
     *   where: {
     *     // ... the filter for the Ig_access_tokens we want to count
     *   }
     * })
    **/
    count<T extends ig_access_tokenCountArgs>(
      args?: Subset<T, ig_access_tokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ig_access_tokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ig_access_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ig_access_tokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ig_access_tokenAggregateArgs>(args: Subset<T, Ig_access_tokenAggregateArgs>): Prisma.PrismaPromise<GetIg_access_tokenAggregateType<T>>

    /**
     * Group by Ig_access_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_access_tokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ig_access_tokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ig_access_tokenGroupByArgs['orderBy'] }
        : { orderBy?: ig_access_tokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ig_access_tokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIg_access_tokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ig_access_token model
   */
  readonly fields: ig_access_tokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ig_access_token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ig_access_tokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ig_access_token model
   */
  interface ig_access_tokenFieldRefs {
    readonly id: FieldRef<"ig_access_token", 'String'>
    readonly token: FieldRef<"ig_access_token", 'String'>
    readonly encryption_iv: FieldRef<"ig_access_token", 'String'>
    readonly expires_at: FieldRef<"ig_access_token", 'String'>
    readonly created_at: FieldRef<"ig_access_token", 'DateTime'>
    readonly updated_at: FieldRef<"ig_access_token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ig_access_token findUnique
   */
  export type ig_access_tokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_access_token
     */
    select?: ig_access_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_access_token
     */
    omit?: ig_access_tokenOmit<ExtArgs> | null
    /**
     * Filter, which ig_access_token to fetch.
     */
    where: ig_access_tokenWhereUniqueInput
  }

  /**
   * ig_access_token findUniqueOrThrow
   */
  export type ig_access_tokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_access_token
     */
    select?: ig_access_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_access_token
     */
    omit?: ig_access_tokenOmit<ExtArgs> | null
    /**
     * Filter, which ig_access_token to fetch.
     */
    where: ig_access_tokenWhereUniqueInput
  }

  /**
   * ig_access_token findFirst
   */
  export type ig_access_tokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_access_token
     */
    select?: ig_access_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_access_token
     */
    omit?: ig_access_tokenOmit<ExtArgs> | null
    /**
     * Filter, which ig_access_token to fetch.
     */
    where?: ig_access_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ig_access_tokens to fetch.
     */
    orderBy?: ig_access_tokenOrderByWithRelationInput | ig_access_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ig_access_tokens.
     */
    cursor?: ig_access_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ig_access_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ig_access_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ig_access_tokens.
     */
    distinct?: Ig_access_tokenScalarFieldEnum | Ig_access_tokenScalarFieldEnum[]
  }

  /**
   * ig_access_token findFirstOrThrow
   */
  export type ig_access_tokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_access_token
     */
    select?: ig_access_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_access_token
     */
    omit?: ig_access_tokenOmit<ExtArgs> | null
    /**
     * Filter, which ig_access_token to fetch.
     */
    where?: ig_access_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ig_access_tokens to fetch.
     */
    orderBy?: ig_access_tokenOrderByWithRelationInput | ig_access_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ig_access_tokens.
     */
    cursor?: ig_access_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ig_access_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ig_access_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ig_access_tokens.
     */
    distinct?: Ig_access_tokenScalarFieldEnum | Ig_access_tokenScalarFieldEnum[]
  }

  /**
   * ig_access_token findMany
   */
  export type ig_access_tokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_access_token
     */
    select?: ig_access_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_access_token
     */
    omit?: ig_access_tokenOmit<ExtArgs> | null
    /**
     * Filter, which ig_access_tokens to fetch.
     */
    where?: ig_access_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ig_access_tokens to fetch.
     */
    orderBy?: ig_access_tokenOrderByWithRelationInput | ig_access_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ig_access_tokens.
     */
    cursor?: ig_access_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ig_access_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ig_access_tokens.
     */
    skip?: number
    distinct?: Ig_access_tokenScalarFieldEnum | Ig_access_tokenScalarFieldEnum[]
  }

  /**
   * ig_access_token create
   */
  export type ig_access_tokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_access_token
     */
    select?: ig_access_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_access_token
     */
    omit?: ig_access_tokenOmit<ExtArgs> | null
    /**
     * The data needed to create a ig_access_token.
     */
    data: XOR<ig_access_tokenCreateInput, ig_access_tokenUncheckedCreateInput>
  }

  /**
   * ig_access_token createMany
   */
  export type ig_access_tokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ig_access_tokens.
     */
    data: ig_access_tokenCreateManyInput | ig_access_tokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ig_access_token createManyAndReturn
   */
  export type ig_access_tokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_access_token
     */
    select?: ig_access_tokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ig_access_token
     */
    omit?: ig_access_tokenOmit<ExtArgs> | null
    /**
     * The data used to create many ig_access_tokens.
     */
    data: ig_access_tokenCreateManyInput | ig_access_tokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ig_access_token update
   */
  export type ig_access_tokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_access_token
     */
    select?: ig_access_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_access_token
     */
    omit?: ig_access_tokenOmit<ExtArgs> | null
    /**
     * The data needed to update a ig_access_token.
     */
    data: XOR<ig_access_tokenUpdateInput, ig_access_tokenUncheckedUpdateInput>
    /**
     * Choose, which ig_access_token to update.
     */
    where: ig_access_tokenWhereUniqueInput
  }

  /**
   * ig_access_token updateMany
   */
  export type ig_access_tokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ig_access_tokens.
     */
    data: XOR<ig_access_tokenUpdateManyMutationInput, ig_access_tokenUncheckedUpdateManyInput>
    /**
     * Filter which ig_access_tokens to update
     */
    where?: ig_access_tokenWhereInput
    /**
     * Limit how many ig_access_tokens to update.
     */
    limit?: number
  }

  /**
   * ig_access_token updateManyAndReturn
   */
  export type ig_access_tokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_access_token
     */
    select?: ig_access_tokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ig_access_token
     */
    omit?: ig_access_tokenOmit<ExtArgs> | null
    /**
     * The data used to update ig_access_tokens.
     */
    data: XOR<ig_access_tokenUpdateManyMutationInput, ig_access_tokenUncheckedUpdateManyInput>
    /**
     * Filter which ig_access_tokens to update
     */
    where?: ig_access_tokenWhereInput
    /**
     * Limit how many ig_access_tokens to update.
     */
    limit?: number
  }

  /**
   * ig_access_token upsert
   */
  export type ig_access_tokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_access_token
     */
    select?: ig_access_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_access_token
     */
    omit?: ig_access_tokenOmit<ExtArgs> | null
    /**
     * The filter to search for the ig_access_token to update in case it exists.
     */
    where: ig_access_tokenWhereUniqueInput
    /**
     * In case the ig_access_token found by the `where` argument doesn't exist, create a new ig_access_token with this data.
     */
    create: XOR<ig_access_tokenCreateInput, ig_access_tokenUncheckedCreateInput>
    /**
     * In case the ig_access_token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ig_access_tokenUpdateInput, ig_access_tokenUncheckedUpdateInput>
  }

  /**
   * ig_access_token delete
   */
  export type ig_access_tokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_access_token
     */
    select?: ig_access_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_access_token
     */
    omit?: ig_access_tokenOmit<ExtArgs> | null
    /**
     * Filter which ig_access_token to delete.
     */
    where: ig_access_tokenWhereUniqueInput
  }

  /**
   * ig_access_token deleteMany
   */
  export type ig_access_tokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ig_access_tokens to delete
     */
    where?: ig_access_tokenWhereInput
    /**
     * Limit how many ig_access_tokens to delete.
     */
    limit?: number
  }

  /**
   * ig_access_token without action
   */
  export type ig_access_tokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_access_token
     */
    select?: ig_access_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_access_token
     */
    omit?: ig_access_tokenOmit<ExtArgs> | null
  }


  /**
   * Model ig_scope_identifiers
   */

  export type AggregateIg_scope_identifiers = {
    _count: Ig_scope_identifiersCountAggregateOutputType | null
    _min: Ig_scope_identifiersMinAggregateOutputType | null
    _max: Ig_scope_identifiersMaxAggregateOutputType | null
  }

  export type Ig_scope_identifiersMinAggregateOutputType = {
    id: string | null
    ig_username: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ig_scope_identifiersMaxAggregateOutputType = {
    id: string | null
    ig_username: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ig_scope_identifiersCountAggregateOutputType = {
    id: number
    ig_username: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ig_scope_identifiersMinAggregateInputType = {
    id?: true
    ig_username?: true
    created_at?: true
    updated_at?: true
  }

  export type Ig_scope_identifiersMaxAggregateInputType = {
    id?: true
    ig_username?: true
    created_at?: true
    updated_at?: true
  }

  export type Ig_scope_identifiersCountAggregateInputType = {
    id?: true
    ig_username?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ig_scope_identifiersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ig_scope_identifiers to aggregate.
     */
    where?: ig_scope_identifiersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ig_scope_identifiers to fetch.
     */
    orderBy?: ig_scope_identifiersOrderByWithRelationInput | ig_scope_identifiersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ig_scope_identifiersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ig_scope_identifiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ig_scope_identifiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ig_scope_identifiers
    **/
    _count?: true | Ig_scope_identifiersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ig_scope_identifiersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ig_scope_identifiersMaxAggregateInputType
  }

  export type GetIg_scope_identifiersAggregateType<T extends Ig_scope_identifiersAggregateArgs> = {
        [P in keyof T & keyof AggregateIg_scope_identifiers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIg_scope_identifiers[P]>
      : GetScalarType<T[P], AggregateIg_scope_identifiers[P]>
  }




  export type ig_scope_identifiersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ig_scope_identifiersWhereInput
    orderBy?: ig_scope_identifiersOrderByWithAggregationInput | ig_scope_identifiersOrderByWithAggregationInput[]
    by: Ig_scope_identifiersScalarFieldEnum[] | Ig_scope_identifiersScalarFieldEnum
    having?: ig_scope_identifiersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ig_scope_identifiersCountAggregateInputType | true
    _min?: Ig_scope_identifiersMinAggregateInputType
    _max?: Ig_scope_identifiersMaxAggregateInputType
  }

  export type Ig_scope_identifiersGroupByOutputType = {
    id: string
    ig_username: string
    created_at: Date
    updated_at: Date
    _count: Ig_scope_identifiersCountAggregateOutputType | null
    _min: Ig_scope_identifiersMinAggregateOutputType | null
    _max: Ig_scope_identifiersMaxAggregateOutputType | null
  }

  type GetIg_scope_identifiersGroupByPayload<T extends ig_scope_identifiersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ig_scope_identifiersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ig_scope_identifiersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ig_scope_identifiersGroupByOutputType[P]>
            : GetScalarType<T[P], Ig_scope_identifiersGroupByOutputType[P]>
        }
      >
    >


  export type ig_scope_identifiersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ig_username?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliate_business?: boolean | ig_scope_identifiers$affiliate_businessArgs<ExtArgs>
    _count?: boolean | Ig_scope_identifiersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ig_scope_identifiers"]>

  export type ig_scope_identifiersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ig_username?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ig_scope_identifiers"]>

  export type ig_scope_identifiersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ig_username?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ig_scope_identifiers"]>

  export type ig_scope_identifiersSelectScalar = {
    id?: boolean
    ig_username?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ig_scope_identifiersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ig_username" | "created_at" | "updated_at", ExtArgs["result"]["ig_scope_identifiers"]>
  export type ig_scope_identifiersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_business?: boolean | ig_scope_identifiers$affiliate_businessArgs<ExtArgs>
    _count?: boolean | Ig_scope_identifiersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ig_scope_identifiersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ig_scope_identifiersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ig_scope_identifiersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ig_scope_identifiers"
    objects: {
      affiliate_business: Prisma.$Affiliate_BusinessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ig_username: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["ig_scope_identifiers"]>
    composites: {}
  }

  type ig_scope_identifiersGetPayload<S extends boolean | null | undefined | ig_scope_identifiersDefaultArgs> = $Result.GetResult<Prisma.$ig_scope_identifiersPayload, S>

  type ig_scope_identifiersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ig_scope_identifiersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ig_scope_identifiersCountAggregateInputType | true
    }

  export interface ig_scope_identifiersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ig_scope_identifiers'], meta: { name: 'ig_scope_identifiers' } }
    /**
     * Find zero or one Ig_scope_identifiers that matches the filter.
     * @param {ig_scope_identifiersFindUniqueArgs} args - Arguments to find a Ig_scope_identifiers
     * @example
     * // Get one Ig_scope_identifiers
     * const ig_scope_identifiers = await prisma.ig_scope_identifiers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ig_scope_identifiersFindUniqueArgs>(args: SelectSubset<T, ig_scope_identifiersFindUniqueArgs<ExtArgs>>): Prisma__ig_scope_identifiersClient<$Result.GetResult<Prisma.$ig_scope_identifiersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ig_scope_identifiers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ig_scope_identifiersFindUniqueOrThrowArgs} args - Arguments to find a Ig_scope_identifiers
     * @example
     * // Get one Ig_scope_identifiers
     * const ig_scope_identifiers = await prisma.ig_scope_identifiers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ig_scope_identifiersFindUniqueOrThrowArgs>(args: SelectSubset<T, ig_scope_identifiersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ig_scope_identifiersClient<$Result.GetResult<Prisma.$ig_scope_identifiersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ig_scope_identifiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_scope_identifiersFindFirstArgs} args - Arguments to find a Ig_scope_identifiers
     * @example
     * // Get one Ig_scope_identifiers
     * const ig_scope_identifiers = await prisma.ig_scope_identifiers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ig_scope_identifiersFindFirstArgs>(args?: SelectSubset<T, ig_scope_identifiersFindFirstArgs<ExtArgs>>): Prisma__ig_scope_identifiersClient<$Result.GetResult<Prisma.$ig_scope_identifiersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ig_scope_identifiers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_scope_identifiersFindFirstOrThrowArgs} args - Arguments to find a Ig_scope_identifiers
     * @example
     * // Get one Ig_scope_identifiers
     * const ig_scope_identifiers = await prisma.ig_scope_identifiers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ig_scope_identifiersFindFirstOrThrowArgs>(args?: SelectSubset<T, ig_scope_identifiersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ig_scope_identifiersClient<$Result.GetResult<Prisma.$ig_scope_identifiersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ig_scope_identifiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_scope_identifiersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ig_scope_identifiers
     * const ig_scope_identifiers = await prisma.ig_scope_identifiers.findMany()
     * 
     * // Get first 10 Ig_scope_identifiers
     * const ig_scope_identifiers = await prisma.ig_scope_identifiers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ig_scope_identifiersWithIdOnly = await prisma.ig_scope_identifiers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ig_scope_identifiersFindManyArgs>(args?: SelectSubset<T, ig_scope_identifiersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ig_scope_identifiersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ig_scope_identifiers.
     * @param {ig_scope_identifiersCreateArgs} args - Arguments to create a Ig_scope_identifiers.
     * @example
     * // Create one Ig_scope_identifiers
     * const Ig_scope_identifiers = await prisma.ig_scope_identifiers.create({
     *   data: {
     *     // ... data to create a Ig_scope_identifiers
     *   }
     * })
     * 
     */
    create<T extends ig_scope_identifiersCreateArgs>(args: SelectSubset<T, ig_scope_identifiersCreateArgs<ExtArgs>>): Prisma__ig_scope_identifiersClient<$Result.GetResult<Prisma.$ig_scope_identifiersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ig_scope_identifiers.
     * @param {ig_scope_identifiersCreateManyArgs} args - Arguments to create many Ig_scope_identifiers.
     * @example
     * // Create many Ig_scope_identifiers
     * const ig_scope_identifiers = await prisma.ig_scope_identifiers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ig_scope_identifiersCreateManyArgs>(args?: SelectSubset<T, ig_scope_identifiersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ig_scope_identifiers and returns the data saved in the database.
     * @param {ig_scope_identifiersCreateManyAndReturnArgs} args - Arguments to create many Ig_scope_identifiers.
     * @example
     * // Create many Ig_scope_identifiers
     * const ig_scope_identifiers = await prisma.ig_scope_identifiers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ig_scope_identifiers and only return the `id`
     * const ig_scope_identifiersWithIdOnly = await prisma.ig_scope_identifiers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ig_scope_identifiersCreateManyAndReturnArgs>(args?: SelectSubset<T, ig_scope_identifiersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ig_scope_identifiersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ig_scope_identifiers.
     * @param {ig_scope_identifiersDeleteArgs} args - Arguments to delete one Ig_scope_identifiers.
     * @example
     * // Delete one Ig_scope_identifiers
     * const Ig_scope_identifiers = await prisma.ig_scope_identifiers.delete({
     *   where: {
     *     // ... filter to delete one Ig_scope_identifiers
     *   }
     * })
     * 
     */
    delete<T extends ig_scope_identifiersDeleteArgs>(args: SelectSubset<T, ig_scope_identifiersDeleteArgs<ExtArgs>>): Prisma__ig_scope_identifiersClient<$Result.GetResult<Prisma.$ig_scope_identifiersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ig_scope_identifiers.
     * @param {ig_scope_identifiersUpdateArgs} args - Arguments to update one Ig_scope_identifiers.
     * @example
     * // Update one Ig_scope_identifiers
     * const ig_scope_identifiers = await prisma.ig_scope_identifiers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ig_scope_identifiersUpdateArgs>(args: SelectSubset<T, ig_scope_identifiersUpdateArgs<ExtArgs>>): Prisma__ig_scope_identifiersClient<$Result.GetResult<Prisma.$ig_scope_identifiersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ig_scope_identifiers.
     * @param {ig_scope_identifiersDeleteManyArgs} args - Arguments to filter Ig_scope_identifiers to delete.
     * @example
     * // Delete a few Ig_scope_identifiers
     * const { count } = await prisma.ig_scope_identifiers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ig_scope_identifiersDeleteManyArgs>(args?: SelectSubset<T, ig_scope_identifiersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ig_scope_identifiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_scope_identifiersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ig_scope_identifiers
     * const ig_scope_identifiers = await prisma.ig_scope_identifiers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ig_scope_identifiersUpdateManyArgs>(args: SelectSubset<T, ig_scope_identifiersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ig_scope_identifiers and returns the data updated in the database.
     * @param {ig_scope_identifiersUpdateManyAndReturnArgs} args - Arguments to update many Ig_scope_identifiers.
     * @example
     * // Update many Ig_scope_identifiers
     * const ig_scope_identifiers = await prisma.ig_scope_identifiers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ig_scope_identifiers and only return the `id`
     * const ig_scope_identifiersWithIdOnly = await prisma.ig_scope_identifiers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ig_scope_identifiersUpdateManyAndReturnArgs>(args: SelectSubset<T, ig_scope_identifiersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ig_scope_identifiersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ig_scope_identifiers.
     * @param {ig_scope_identifiersUpsertArgs} args - Arguments to update or create a Ig_scope_identifiers.
     * @example
     * // Update or create a Ig_scope_identifiers
     * const ig_scope_identifiers = await prisma.ig_scope_identifiers.upsert({
     *   create: {
     *     // ... data to create a Ig_scope_identifiers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ig_scope_identifiers we want to update
     *   }
     * })
     */
    upsert<T extends ig_scope_identifiersUpsertArgs>(args: SelectSubset<T, ig_scope_identifiersUpsertArgs<ExtArgs>>): Prisma__ig_scope_identifiersClient<$Result.GetResult<Prisma.$ig_scope_identifiersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ig_scope_identifiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_scope_identifiersCountArgs} args - Arguments to filter Ig_scope_identifiers to count.
     * @example
     * // Count the number of Ig_scope_identifiers
     * const count = await prisma.ig_scope_identifiers.count({
     *   where: {
     *     // ... the filter for the Ig_scope_identifiers we want to count
     *   }
     * })
    **/
    count<T extends ig_scope_identifiersCountArgs>(
      args?: Subset<T, ig_scope_identifiersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ig_scope_identifiersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ig_scope_identifiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ig_scope_identifiersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ig_scope_identifiersAggregateArgs>(args: Subset<T, Ig_scope_identifiersAggregateArgs>): Prisma.PrismaPromise<GetIg_scope_identifiersAggregateType<T>>

    /**
     * Group by Ig_scope_identifiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ig_scope_identifiersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ig_scope_identifiersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ig_scope_identifiersGroupByArgs['orderBy'] }
        : { orderBy?: ig_scope_identifiersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ig_scope_identifiersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIg_scope_identifiersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ig_scope_identifiers model
   */
  readonly fields: ig_scope_identifiersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ig_scope_identifiers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ig_scope_identifiersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate_business<T extends ig_scope_identifiers$affiliate_businessArgs<ExtArgs> = {}>(args?: Subset<T, ig_scope_identifiers$affiliate_businessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Affiliate_BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ig_scope_identifiers model
   */
  interface ig_scope_identifiersFieldRefs {
    readonly id: FieldRef<"ig_scope_identifiers", 'String'>
    readonly ig_username: FieldRef<"ig_scope_identifiers", 'String'>
    readonly created_at: FieldRef<"ig_scope_identifiers", 'DateTime'>
    readonly updated_at: FieldRef<"ig_scope_identifiers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ig_scope_identifiers findUnique
   */
  export type ig_scope_identifiersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ig_scope_identifiersInclude<ExtArgs> | null
    /**
     * Filter, which ig_scope_identifiers to fetch.
     */
    where: ig_scope_identifiersWhereUniqueInput
  }

  /**
   * ig_scope_identifiers findUniqueOrThrow
   */
  export type ig_scope_identifiersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ig_scope_identifiersInclude<ExtArgs> | null
    /**
     * Filter, which ig_scope_identifiers to fetch.
     */
    where: ig_scope_identifiersWhereUniqueInput
  }

  /**
   * ig_scope_identifiers findFirst
   */
  export type ig_scope_identifiersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ig_scope_identifiersInclude<ExtArgs> | null
    /**
     * Filter, which ig_scope_identifiers to fetch.
     */
    where?: ig_scope_identifiersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ig_scope_identifiers to fetch.
     */
    orderBy?: ig_scope_identifiersOrderByWithRelationInput | ig_scope_identifiersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ig_scope_identifiers.
     */
    cursor?: ig_scope_identifiersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ig_scope_identifiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ig_scope_identifiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ig_scope_identifiers.
     */
    distinct?: Ig_scope_identifiersScalarFieldEnum | Ig_scope_identifiersScalarFieldEnum[]
  }

  /**
   * ig_scope_identifiers findFirstOrThrow
   */
  export type ig_scope_identifiersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ig_scope_identifiersInclude<ExtArgs> | null
    /**
     * Filter, which ig_scope_identifiers to fetch.
     */
    where?: ig_scope_identifiersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ig_scope_identifiers to fetch.
     */
    orderBy?: ig_scope_identifiersOrderByWithRelationInput | ig_scope_identifiersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ig_scope_identifiers.
     */
    cursor?: ig_scope_identifiersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ig_scope_identifiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ig_scope_identifiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ig_scope_identifiers.
     */
    distinct?: Ig_scope_identifiersScalarFieldEnum | Ig_scope_identifiersScalarFieldEnum[]
  }

  /**
   * ig_scope_identifiers findMany
   */
  export type ig_scope_identifiersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ig_scope_identifiersInclude<ExtArgs> | null
    /**
     * Filter, which ig_scope_identifiers to fetch.
     */
    where?: ig_scope_identifiersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ig_scope_identifiers to fetch.
     */
    orderBy?: ig_scope_identifiersOrderByWithRelationInput | ig_scope_identifiersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ig_scope_identifiers.
     */
    cursor?: ig_scope_identifiersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ig_scope_identifiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ig_scope_identifiers.
     */
    skip?: number
    distinct?: Ig_scope_identifiersScalarFieldEnum | Ig_scope_identifiersScalarFieldEnum[]
  }

  /**
   * ig_scope_identifiers create
   */
  export type ig_scope_identifiersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ig_scope_identifiersInclude<ExtArgs> | null
    /**
     * The data needed to create a ig_scope_identifiers.
     */
    data: XOR<ig_scope_identifiersCreateInput, ig_scope_identifiersUncheckedCreateInput>
  }

  /**
   * ig_scope_identifiers createMany
   */
  export type ig_scope_identifiersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ig_scope_identifiers.
     */
    data: ig_scope_identifiersCreateManyInput | ig_scope_identifiersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ig_scope_identifiers createManyAndReturn
   */
  export type ig_scope_identifiersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * The data used to create many ig_scope_identifiers.
     */
    data: ig_scope_identifiersCreateManyInput | ig_scope_identifiersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ig_scope_identifiers update
   */
  export type ig_scope_identifiersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ig_scope_identifiersInclude<ExtArgs> | null
    /**
     * The data needed to update a ig_scope_identifiers.
     */
    data: XOR<ig_scope_identifiersUpdateInput, ig_scope_identifiersUncheckedUpdateInput>
    /**
     * Choose, which ig_scope_identifiers to update.
     */
    where: ig_scope_identifiersWhereUniqueInput
  }

  /**
   * ig_scope_identifiers updateMany
   */
  export type ig_scope_identifiersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ig_scope_identifiers.
     */
    data: XOR<ig_scope_identifiersUpdateManyMutationInput, ig_scope_identifiersUncheckedUpdateManyInput>
    /**
     * Filter which ig_scope_identifiers to update
     */
    where?: ig_scope_identifiersWhereInput
    /**
     * Limit how many ig_scope_identifiers to update.
     */
    limit?: number
  }

  /**
   * ig_scope_identifiers updateManyAndReturn
   */
  export type ig_scope_identifiersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * The data used to update ig_scope_identifiers.
     */
    data: XOR<ig_scope_identifiersUpdateManyMutationInput, ig_scope_identifiersUncheckedUpdateManyInput>
    /**
     * Filter which ig_scope_identifiers to update
     */
    where?: ig_scope_identifiersWhereInput
    /**
     * Limit how many ig_scope_identifiers to update.
     */
    limit?: number
  }

  /**
   * ig_scope_identifiers upsert
   */
  export type ig_scope_identifiersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ig_scope_identifiersInclude<ExtArgs> | null
    /**
     * The filter to search for the ig_scope_identifiers to update in case it exists.
     */
    where: ig_scope_identifiersWhereUniqueInput
    /**
     * In case the ig_scope_identifiers found by the `where` argument doesn't exist, create a new ig_scope_identifiers with this data.
     */
    create: XOR<ig_scope_identifiersCreateInput, ig_scope_identifiersUncheckedCreateInput>
    /**
     * In case the ig_scope_identifiers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ig_scope_identifiersUpdateInput, ig_scope_identifiersUncheckedUpdateInput>
  }

  /**
   * ig_scope_identifiers delete
   */
  export type ig_scope_identifiersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ig_scope_identifiersInclude<ExtArgs> | null
    /**
     * Filter which ig_scope_identifiers to delete.
     */
    where: ig_scope_identifiersWhereUniqueInput
  }

  /**
   * ig_scope_identifiers deleteMany
   */
  export type ig_scope_identifiersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ig_scope_identifiers to delete
     */
    where?: ig_scope_identifiersWhereInput
    /**
     * Limit how many ig_scope_identifiers to delete.
     */
    limit?: number
  }

  /**
   * ig_scope_identifiers.affiliate_business
   */
  export type ig_scope_identifiers$affiliate_businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate_Business
     */
    select?: Affiliate_BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Affiliate_Business
     */
    omit?: Affiliate_BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Affiliate_BusinessInclude<ExtArgs> | null
    where?: Affiliate_BusinessWhereInput
    orderBy?: Affiliate_BusinessOrderByWithRelationInput | Affiliate_BusinessOrderByWithRelationInput[]
    cursor?: Affiliate_BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Affiliate_BusinessScalarFieldEnum | Affiliate_BusinessScalarFieldEnum[]
  }

  /**
   * ig_scope_identifiers without action
   */
  export type ig_scope_identifiersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ig_scope_identifiers
     */
    select?: ig_scope_identifiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ig_scope_identifiers
     */
    omit?: ig_scope_identifiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ig_scope_identifiersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BusinessScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    store_name: 'store_name',
    slug: 'slug',
    description: 'description',
    url: 'url',
    wallet_address: 'wallet_address',
    commission: 'commission',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    affiliate_hub_description: 'affiliate_hub_description',
    svix_consumer_app_id: 'svix_consumer_app_id',
    stripe_connected_account: 'stripe_connected_account',
    price_plan: 'price_plan',
    trial_ends_at: 'trial_ends_at',
    stripe_customer_id: 'stripe_customer_id',
    stripe_subscription_id: 'stripe_subscription_id',
    payment_preference: 'payment_preference'
  };

  export type BusinessScalarFieldEnum = (typeof BusinessScalarFieldEnum)[keyof typeof BusinessScalarFieldEnum]


  export const MessagesScalarFieldEnum: {
    id: 'id',
    message: 'message',
    type: 'type',
    sent_at: 'sent_at',
    business_id: 'business_id',
    message_id: 'message_id',
    email: 'email',
    name: 'name',
    subject: 'subject',
    parent_id: 'parent_id',
    channel_id: 'channel_id',
    video_id: 'video_id'
  };

  export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


  export const AffiliatesScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at',
    status: 'status',
    wallet_address: 'wallet_address',
    metadata: 'metadata',
    social_media_profiles: 'social_media_profiles'
  };

  export type AffiliatesScalarFieldEnum = (typeof AffiliatesScalarFieldEnum)[keyof typeof AffiliatesScalarFieldEnum]


  export const Affiliate_BusinessScalarFieldEnum: {
    id: 'id',
    business_id: 'business_id',
    affiliate_id: 'affiliate_id',
    affiliate_link: 'affiliate_link',
    affiliate_link_key: 'affiliate_link_key',
    product_id: 'product_id',
    pipeline_id: 'pipeline_id',
    instagram_scope_identifier: 'instagram_scope_identifier'
  };

  export type Affiliate_BusinessScalarFieldEnum = (typeof Affiliate_BusinessScalarFieldEnum)[keyof typeof Affiliate_BusinessScalarFieldEnum]


  export const OrdersScalarFieldEnum: {
    id: 'id',
    customer_name: 'customer_name',
    customer_email: 'customer_email',
    customer_address: 'customer_address',
    invoice_url: 'invoice_url',
    order_quantity: 'order_quantity',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    business_id: 'business_id',
    affiliate_id: 'affiliate_id',
    product_id: 'product_id'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    name: 'name',
    description: 'description',
    html_description: 'html_description',
    image_url: 'image_url',
    price: 'price',
    price_currency: 'price_currency',
    is_shippable: 'is_shippable',
    price_type: 'price_type',
    created_at: 'created_at',
    updated_at: 'updated_at',
    status: 'status',
    business_id: 'business_id',
    metadata: 'metadata',
    id: 'id'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const PipelinesScalarFieldEnum: {
    id: 'id',
    prompt: 'prompt',
    remark: 'remark',
    status: 'status',
    affiliate_count: 'affiliate_count',
    business_id: 'business_id',
    product_id: 'product_id',
    format: 'format',
    location: 'location',
    heygen_video_id: 'heygen_video_id',
    ig_post_id: 'ig_post_id',
    ig_post_url: 'ig_post_url',
    run_mode: 'run_mode',
    workflow: 'workflow',
    created_at: 'created_at'
  };

  export type PipelinesScalarFieldEnum = (typeof PipelinesScalarFieldEnum)[keyof typeof PipelinesScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    sender: 'sender',
    receiver: 'receiver',
    text: 'text',
    pipeline_id: 'pipeline_id',
    chat_message_status: 'chat_message_status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const WaitlistScalarFieldEnum: {
    id: 'id',
    email: 'email',
    created_at: 'created_at'
  };

  export type WaitlistScalarFieldEnum = (typeof WaitlistScalarFieldEnum)[keyof typeof WaitlistScalarFieldEnum]


  export const Pending_PaymentsScalarFieldEnum: {
    id: 'id',
    business_id: 'business_id',
    product_id: 'product_id',
    full_amount: 'full_amount',
    fiat_amount: 'fiat_amount',
    crypto_amount: 'crypto_amount',
    payout_date: 'payout_date',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Pending_PaymentsScalarFieldEnum = (typeof Pending_PaymentsScalarFieldEnum)[keyof typeof Pending_PaymentsScalarFieldEnum]


  export const Affiliate_Pending_PaymentsScalarFieldEnum: {
    id: 'id',
    affiliate_id: 'affiliate_id',
    product_id: 'product_id',
    full_amount: 'full_amount',
    fiat_amount: 'fiat_amount',
    crypto_amount: 'crypto_amount',
    payout_date: 'payout_date',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Affiliate_Pending_PaymentsScalarFieldEnum = (typeof Affiliate_Pending_PaymentsScalarFieldEnum)[keyof typeof Affiliate_Pending_PaymentsScalarFieldEnum]


  export const EmbeddingsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    content: 'content',
    resource_id: 'resource_id'
  };

  export type EmbeddingsScalarFieldEnum = (typeof EmbeddingsScalarFieldEnum)[keyof typeof EmbeddingsScalarFieldEnum]


  export const Ig_chat_historyScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    ig_recipient_id: 'ig_recipient_id',
    message: 'message',
    role: 'role'
  };

  export type Ig_chat_historyScalarFieldEnum = (typeof Ig_chat_historyScalarFieldEnum)[keyof typeof Ig_chat_historyScalarFieldEnum]


  export const ResourcesScalarFieldEnum: {
    id: 'id',
    content: 'content',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ResourcesScalarFieldEnum = (typeof ResourcesScalarFieldEnum)[keyof typeof ResourcesScalarFieldEnum]


  export const Ig_access_tokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    encryption_iv: 'encryption_iv',
    expires_at: 'expires_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ig_access_tokenScalarFieldEnum = (typeof Ig_access_tokenScalarFieldEnum)[keyof typeof Ig_access_tokenScalarFieldEnum]


  export const Ig_scope_identifiersScalarFieldEnum: {
    id: 'id',
    ig_username: 'ig_username',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ig_scope_identifiersScalarFieldEnum = (typeof Ig_scope_identifiersScalarFieldEnum)[keyof typeof Ig_scope_identifiersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PricePlan'
   */
  export type EnumPricePlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricePlan'>
    


  /**
   * Reference to a field of type 'PricePlan[]'
   */
  export type ListEnumPricePlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricePlan[]'>
    


  /**
   * Reference to a field of type 'PaymentPreference'
   */
  export type EnumPaymentPreferenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentPreference'>
    


  /**
   * Reference to a field of type 'PaymentPreference[]'
   */
  export type ListEnumPaymentPreferenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentPreference[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PriceType'
   */
  export type EnumPriceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriceType'>
    


  /**
   * Reference to a field of type 'PriceType[]'
   */
  export type ListEnumPriceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriceType[]'>
    


  /**
   * Reference to a field of type 'RunMode'
   */
  export type EnumRunModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RunMode'>
    


  /**
   * Reference to a field of type 'RunMode[]'
   */
  export type ListEnumRunModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RunMode[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    
  /**
   * Deep Input Types
   */


  export type BusinessWhereInput = {
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    id?: UuidFilter<"Business"> | string
    first_name?: StringNullableFilter<"Business"> | string | null
    last_name?: StringNullableFilter<"Business"> | string | null
    email?: StringFilter<"Business"> | string
    store_name?: StringNullableFilter<"Business"> | string | null
    slug?: StringFilter<"Business"> | string
    description?: StringNullableFilter<"Business"> | string | null
    url?: StringNullableFilter<"Business"> | string | null
    wallet_address?: StringNullableFilter<"Business"> | string | null
    commission?: IntNullableFilter<"Business"> | number | null
    status?: StringFilter<"Business"> | string
    created_at?: DateTimeFilter<"Business"> | Date | string
    updated_at?: DateTimeFilter<"Business"> | Date | string
    affiliate_hub_description?: StringNullableFilter<"Business"> | string | null
    svix_consumer_app_id?: StringNullableFilter<"Business"> | string | null
    stripe_connected_account?: StringNullableFilter<"Business"> | string | null
    price_plan?: EnumPricePlanNullableFilter<"Business"> | $Enums.PricePlan | null
    trial_ends_at?: DateTimeNullableFilter<"Business"> | Date | string | null
    stripe_customer_id?: StringNullableFilter<"Business"> | string | null
    stripe_subscription_id?: StringNullableFilter<"Business"> | string | null
    payment_preference?: EnumPaymentPreferenceFilter<"Business"> | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessListRelationFilter
    messages?: MessagesListRelationFilter
    orders?: OrdersListRelationFilter
    pipelines?: PipelinesListRelationFilter
    products?: ProductsListRelationFilter
    pending_payments?: Pending_PaymentsListRelationFilter
  }

  export type BusinessOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    email?: SortOrder
    store_name?: SortOrderInput | SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    wallet_address?: SortOrderInput | SortOrder
    commission?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliate_hub_description?: SortOrderInput | SortOrder
    svix_consumer_app_id?: SortOrderInput | SortOrder
    stripe_connected_account?: SortOrderInput | SortOrder
    price_plan?: SortOrderInput | SortOrder
    trial_ends_at?: SortOrderInput | SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    stripe_subscription_id?: SortOrderInput | SortOrder
    payment_preference?: SortOrder
    affiliate_business?: Affiliate_BusinessOrderByRelationAggregateInput
    messages?: MessagesOrderByRelationAggregateInput
    orders?: OrdersOrderByRelationAggregateInput
    pipelines?: PipelinesOrderByRelationAggregateInput
    products?: ProductsOrderByRelationAggregateInput
    pending_payments?: Pending_PaymentsOrderByRelationAggregateInput
  }

  export type BusinessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    slug?: string
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    first_name?: StringNullableFilter<"Business"> | string | null
    last_name?: StringNullableFilter<"Business"> | string | null
    store_name?: StringNullableFilter<"Business"> | string | null
    description?: StringNullableFilter<"Business"> | string | null
    url?: StringNullableFilter<"Business"> | string | null
    wallet_address?: StringNullableFilter<"Business"> | string | null
    commission?: IntNullableFilter<"Business"> | number | null
    status?: StringFilter<"Business"> | string
    created_at?: DateTimeFilter<"Business"> | Date | string
    updated_at?: DateTimeFilter<"Business"> | Date | string
    affiliate_hub_description?: StringNullableFilter<"Business"> | string | null
    svix_consumer_app_id?: StringNullableFilter<"Business"> | string | null
    stripe_connected_account?: StringNullableFilter<"Business"> | string | null
    price_plan?: EnumPricePlanNullableFilter<"Business"> | $Enums.PricePlan | null
    trial_ends_at?: DateTimeNullableFilter<"Business"> | Date | string | null
    stripe_customer_id?: StringNullableFilter<"Business"> | string | null
    stripe_subscription_id?: StringNullableFilter<"Business"> | string | null
    payment_preference?: EnumPaymentPreferenceFilter<"Business"> | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessListRelationFilter
    messages?: MessagesListRelationFilter
    orders?: OrdersListRelationFilter
    pipelines?: PipelinesListRelationFilter
    products?: ProductsListRelationFilter
    pending_payments?: Pending_PaymentsListRelationFilter
  }, "id" | "email" | "slug">

  export type BusinessOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    email?: SortOrder
    store_name?: SortOrderInput | SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    wallet_address?: SortOrderInput | SortOrder
    commission?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliate_hub_description?: SortOrderInput | SortOrder
    svix_consumer_app_id?: SortOrderInput | SortOrder
    stripe_connected_account?: SortOrderInput | SortOrder
    price_plan?: SortOrderInput | SortOrder
    trial_ends_at?: SortOrderInput | SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    stripe_subscription_id?: SortOrderInput | SortOrder
    payment_preference?: SortOrder
    _count?: BusinessCountOrderByAggregateInput
    _avg?: BusinessAvgOrderByAggregateInput
    _max?: BusinessMaxOrderByAggregateInput
    _min?: BusinessMinOrderByAggregateInput
    _sum?: BusinessSumOrderByAggregateInput
  }

  export type BusinessScalarWhereWithAggregatesInput = {
    AND?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    OR?: BusinessScalarWhereWithAggregatesInput[]
    NOT?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Business"> | string
    first_name?: StringNullableWithAggregatesFilter<"Business"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"Business"> | string | null
    email?: StringWithAggregatesFilter<"Business"> | string
    store_name?: StringNullableWithAggregatesFilter<"Business"> | string | null
    slug?: StringWithAggregatesFilter<"Business"> | string
    description?: StringNullableWithAggregatesFilter<"Business"> | string | null
    url?: StringNullableWithAggregatesFilter<"Business"> | string | null
    wallet_address?: StringNullableWithAggregatesFilter<"Business"> | string | null
    commission?: IntNullableWithAggregatesFilter<"Business"> | number | null
    status?: StringWithAggregatesFilter<"Business"> | string
    created_at?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    affiliate_hub_description?: StringNullableWithAggregatesFilter<"Business"> | string | null
    svix_consumer_app_id?: StringNullableWithAggregatesFilter<"Business"> | string | null
    stripe_connected_account?: StringNullableWithAggregatesFilter<"Business"> | string | null
    price_plan?: EnumPricePlanNullableWithAggregatesFilter<"Business"> | $Enums.PricePlan | null
    trial_ends_at?: DateTimeNullableWithAggregatesFilter<"Business"> | Date | string | null
    stripe_customer_id?: StringNullableWithAggregatesFilter<"Business"> | string | null
    stripe_subscription_id?: StringNullableWithAggregatesFilter<"Business"> | string | null
    payment_preference?: EnumPaymentPreferenceWithAggregatesFilter<"Business"> | $Enums.PaymentPreference
  }

  export type MessagesWhereInput = {
    AND?: MessagesWhereInput | MessagesWhereInput[]
    OR?: MessagesWhereInput[]
    NOT?: MessagesWhereInput | MessagesWhereInput[]
    id?: UuidFilter<"Messages"> | string
    message?: StringFilter<"Messages"> | string
    type?: StringFilter<"Messages"> | string
    sent_at?: DateTimeFilter<"Messages"> | Date | string
    business_id?: UuidFilter<"Messages"> | string
    message_id?: StringNullableFilter<"Messages"> | string | null
    email?: StringNullableFilter<"Messages"> | string | null
    name?: StringNullableFilter<"Messages"> | string | null
    subject?: StringFilter<"Messages"> | string
    parent_id?: UuidNullableFilter<"Messages"> | string | null
    channel_id?: StringNullableFilter<"Messages"> | string | null
    video_id?: StringNullableFilter<"Messages"> | string | null
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    parent?: XOR<MessagesNullableScalarRelationFilter, MessagesWhereInput> | null
    replies?: MessagesListRelationFilter
  }

  export type MessagesOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    type?: SortOrder
    sent_at?: SortOrder
    business_id?: SortOrder
    message_id?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    subject?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    channel_id?: SortOrderInput | SortOrder
    video_id?: SortOrderInput | SortOrder
    business?: BusinessOrderByWithRelationInput
    parent?: MessagesOrderByWithRelationInput
    replies?: MessagesOrderByRelationAggregateInput
  }

  export type MessagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessagesWhereInput | MessagesWhereInput[]
    OR?: MessagesWhereInput[]
    NOT?: MessagesWhereInput | MessagesWhereInput[]
    message?: StringFilter<"Messages"> | string
    type?: StringFilter<"Messages"> | string
    sent_at?: DateTimeFilter<"Messages"> | Date | string
    business_id?: UuidFilter<"Messages"> | string
    message_id?: StringNullableFilter<"Messages"> | string | null
    email?: StringNullableFilter<"Messages"> | string | null
    name?: StringNullableFilter<"Messages"> | string | null
    subject?: StringFilter<"Messages"> | string
    parent_id?: UuidNullableFilter<"Messages"> | string | null
    channel_id?: StringNullableFilter<"Messages"> | string | null
    video_id?: StringNullableFilter<"Messages"> | string | null
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    parent?: XOR<MessagesNullableScalarRelationFilter, MessagesWhereInput> | null
    replies?: MessagesListRelationFilter
  }, "id">

  export type MessagesOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    type?: SortOrder
    sent_at?: SortOrder
    business_id?: SortOrder
    message_id?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    subject?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    channel_id?: SortOrderInput | SortOrder
    video_id?: SortOrderInput | SortOrder
    _count?: MessagesCountOrderByAggregateInput
    _max?: MessagesMaxOrderByAggregateInput
    _min?: MessagesMinOrderByAggregateInput
  }

  export type MessagesScalarWhereWithAggregatesInput = {
    AND?: MessagesScalarWhereWithAggregatesInput | MessagesScalarWhereWithAggregatesInput[]
    OR?: MessagesScalarWhereWithAggregatesInput[]
    NOT?: MessagesScalarWhereWithAggregatesInput | MessagesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Messages"> | string
    message?: StringWithAggregatesFilter<"Messages"> | string
    type?: StringWithAggregatesFilter<"Messages"> | string
    sent_at?: DateTimeWithAggregatesFilter<"Messages"> | Date | string
    business_id?: UuidWithAggregatesFilter<"Messages"> | string
    message_id?: StringNullableWithAggregatesFilter<"Messages"> | string | null
    email?: StringNullableWithAggregatesFilter<"Messages"> | string | null
    name?: StringNullableWithAggregatesFilter<"Messages"> | string | null
    subject?: StringWithAggregatesFilter<"Messages"> | string
    parent_id?: UuidNullableWithAggregatesFilter<"Messages"> | string | null
    channel_id?: StringNullableWithAggregatesFilter<"Messages"> | string | null
    video_id?: StringNullableWithAggregatesFilter<"Messages"> | string | null
  }

  export type AffiliatesWhereInput = {
    AND?: AffiliatesWhereInput | AffiliatesWhereInput[]
    OR?: AffiliatesWhereInput[]
    NOT?: AffiliatesWhereInput | AffiliatesWhereInput[]
    id?: IntFilter<"Affiliates"> | number
    first_name?: StringNullableFilter<"Affiliates"> | string | null
    last_name?: StringNullableFilter<"Affiliates"> | string | null
    email?: StringFilter<"Affiliates"> | string
    description?: StringNullableFilter<"Affiliates"> | string | null
    created_at?: DateTimeFilter<"Affiliates"> | Date | string
    updated_at?: DateTimeFilter<"Affiliates"> | Date | string
    status?: StringFilter<"Affiliates"> | string
    wallet_address?: StringNullableFilter<"Affiliates"> | string | null
    metadata?: JsonNullableFilter<"Affiliates">
    social_media_profiles?: JsonNullableFilter<"Affiliates">
    affiliate_business?: Affiliate_BusinessListRelationFilter
    orders?: OrdersListRelationFilter
    affiliate_pending_payments?: Affiliate_Pending_PaymentsListRelationFilter
  }

  export type AffiliatesOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    email?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    wallet_address?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    social_media_profiles?: SortOrderInput | SortOrder
    affiliate_business?: Affiliate_BusinessOrderByRelationAggregateInput
    orders?: OrdersOrderByRelationAggregateInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsOrderByRelationAggregateInput
  }

  export type AffiliatesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: AffiliatesWhereInput | AffiliatesWhereInput[]
    OR?: AffiliatesWhereInput[]
    NOT?: AffiliatesWhereInput | AffiliatesWhereInput[]
    first_name?: StringNullableFilter<"Affiliates"> | string | null
    last_name?: StringNullableFilter<"Affiliates"> | string | null
    description?: StringNullableFilter<"Affiliates"> | string | null
    created_at?: DateTimeFilter<"Affiliates"> | Date | string
    updated_at?: DateTimeFilter<"Affiliates"> | Date | string
    status?: StringFilter<"Affiliates"> | string
    wallet_address?: StringNullableFilter<"Affiliates"> | string | null
    metadata?: JsonNullableFilter<"Affiliates">
    social_media_profiles?: JsonNullableFilter<"Affiliates">
    affiliate_business?: Affiliate_BusinessListRelationFilter
    orders?: OrdersListRelationFilter
    affiliate_pending_payments?: Affiliate_Pending_PaymentsListRelationFilter
  }, "id" | "email">

  export type AffiliatesOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    email?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    wallet_address?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    social_media_profiles?: SortOrderInput | SortOrder
    _count?: AffiliatesCountOrderByAggregateInput
    _avg?: AffiliatesAvgOrderByAggregateInput
    _max?: AffiliatesMaxOrderByAggregateInput
    _min?: AffiliatesMinOrderByAggregateInput
    _sum?: AffiliatesSumOrderByAggregateInput
  }

  export type AffiliatesScalarWhereWithAggregatesInput = {
    AND?: AffiliatesScalarWhereWithAggregatesInput | AffiliatesScalarWhereWithAggregatesInput[]
    OR?: AffiliatesScalarWhereWithAggregatesInput[]
    NOT?: AffiliatesScalarWhereWithAggregatesInput | AffiliatesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Affiliates"> | number
    first_name?: StringNullableWithAggregatesFilter<"Affiliates"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"Affiliates"> | string | null
    email?: StringWithAggregatesFilter<"Affiliates"> | string
    description?: StringNullableWithAggregatesFilter<"Affiliates"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Affiliates"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Affiliates"> | Date | string
    status?: StringWithAggregatesFilter<"Affiliates"> | string
    wallet_address?: StringNullableWithAggregatesFilter<"Affiliates"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Affiliates">
    social_media_profiles?: JsonNullableWithAggregatesFilter<"Affiliates">
  }

  export type Affiliate_BusinessWhereInput = {
    AND?: Affiliate_BusinessWhereInput | Affiliate_BusinessWhereInput[]
    OR?: Affiliate_BusinessWhereInput[]
    NOT?: Affiliate_BusinessWhereInput | Affiliate_BusinessWhereInput[]
    id?: UuidFilter<"Affiliate_Business"> | string
    business_id?: UuidFilter<"Affiliate_Business"> | string
    affiliate_id?: IntFilter<"Affiliate_Business"> | number
    affiliate_link?: StringNullableFilter<"Affiliate_Business"> | string | null
    affiliate_link_key?: StringNullableFilter<"Affiliate_Business"> | string | null
    product_id?: IntNullableFilter<"Affiliate_Business"> | number | null
    pipeline_id?: IntNullableFilter<"Affiliate_Business"> | number | null
    instagram_scope_identifier?: StringNullableFilter<"Affiliate_Business"> | string | null
    ig_scope_identifier?: XOR<Ig_scope_identifiersNullableScalarRelationFilter, ig_scope_identifiersWhereInput> | null
    affiliate?: XOR<AffiliatesScalarRelationFilter, AffiliatesWhereInput>
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    products?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    pipelines?: XOR<PipelinesNullableScalarRelationFilter, PipelinesWhereInput> | null
  }

  export type Affiliate_BusinessOrderByWithRelationInput = {
    id?: SortOrder
    business_id?: SortOrder
    affiliate_id?: SortOrder
    affiliate_link?: SortOrderInput | SortOrder
    affiliate_link_key?: SortOrderInput | SortOrder
    product_id?: SortOrderInput | SortOrder
    pipeline_id?: SortOrderInput | SortOrder
    instagram_scope_identifier?: SortOrderInput | SortOrder
    ig_scope_identifier?: ig_scope_identifiersOrderByWithRelationInput
    affiliate?: AffiliatesOrderByWithRelationInput
    business?: BusinessOrderByWithRelationInput
    products?: ProductsOrderByWithRelationInput
    pipelines?: PipelinesOrderByWithRelationInput
  }

  export type Affiliate_BusinessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    business_id_affiliate_id?: Affiliate_BusinessBusiness_idAffiliate_idCompoundUniqueInput
    AND?: Affiliate_BusinessWhereInput | Affiliate_BusinessWhereInput[]
    OR?: Affiliate_BusinessWhereInput[]
    NOT?: Affiliate_BusinessWhereInput | Affiliate_BusinessWhereInput[]
    business_id?: UuidFilter<"Affiliate_Business"> | string
    affiliate_id?: IntFilter<"Affiliate_Business"> | number
    affiliate_link?: StringNullableFilter<"Affiliate_Business"> | string | null
    affiliate_link_key?: StringNullableFilter<"Affiliate_Business"> | string | null
    product_id?: IntNullableFilter<"Affiliate_Business"> | number | null
    pipeline_id?: IntNullableFilter<"Affiliate_Business"> | number | null
    instagram_scope_identifier?: StringNullableFilter<"Affiliate_Business"> | string | null
    ig_scope_identifier?: XOR<Ig_scope_identifiersNullableScalarRelationFilter, ig_scope_identifiersWhereInput> | null
    affiliate?: XOR<AffiliatesScalarRelationFilter, AffiliatesWhereInput>
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    products?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    pipelines?: XOR<PipelinesNullableScalarRelationFilter, PipelinesWhereInput> | null
  }, "id" | "business_id_affiliate_id">

  export type Affiliate_BusinessOrderByWithAggregationInput = {
    id?: SortOrder
    business_id?: SortOrder
    affiliate_id?: SortOrder
    affiliate_link?: SortOrderInput | SortOrder
    affiliate_link_key?: SortOrderInput | SortOrder
    product_id?: SortOrderInput | SortOrder
    pipeline_id?: SortOrderInput | SortOrder
    instagram_scope_identifier?: SortOrderInput | SortOrder
    _count?: Affiliate_BusinessCountOrderByAggregateInput
    _avg?: Affiliate_BusinessAvgOrderByAggregateInput
    _max?: Affiliate_BusinessMaxOrderByAggregateInput
    _min?: Affiliate_BusinessMinOrderByAggregateInput
    _sum?: Affiliate_BusinessSumOrderByAggregateInput
  }

  export type Affiliate_BusinessScalarWhereWithAggregatesInput = {
    AND?: Affiliate_BusinessScalarWhereWithAggregatesInput | Affiliate_BusinessScalarWhereWithAggregatesInput[]
    OR?: Affiliate_BusinessScalarWhereWithAggregatesInput[]
    NOT?: Affiliate_BusinessScalarWhereWithAggregatesInput | Affiliate_BusinessScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Affiliate_Business"> | string
    business_id?: UuidWithAggregatesFilter<"Affiliate_Business"> | string
    affiliate_id?: IntWithAggregatesFilter<"Affiliate_Business"> | number
    affiliate_link?: StringNullableWithAggregatesFilter<"Affiliate_Business"> | string | null
    affiliate_link_key?: StringNullableWithAggregatesFilter<"Affiliate_Business"> | string | null
    product_id?: IntNullableWithAggregatesFilter<"Affiliate_Business"> | number | null
    pipeline_id?: IntNullableWithAggregatesFilter<"Affiliate_Business"> | number | null
    instagram_scope_identifier?: StringNullableWithAggregatesFilter<"Affiliate_Business"> | string | null
  }

  export type OrdersWhereInput = {
    AND?: OrdersWhereInput | OrdersWhereInput[]
    OR?: OrdersWhereInput[]
    NOT?: OrdersWhereInput | OrdersWhereInput[]
    id?: UuidFilter<"Orders"> | string
    customer_name?: StringNullableFilter<"Orders"> | string | null
    customer_email?: StringFilter<"Orders"> | string
    customer_address?: StringNullableFilter<"Orders"> | string | null
    invoice_url?: StringNullableFilter<"Orders"> | string | null
    order_quantity?: IntNullableFilter<"Orders"> | number | null
    status?: StringNullableFilter<"Orders"> | string | null
    created_at?: DateTimeFilter<"Orders"> | Date | string
    updated_at?: DateTimeFilter<"Orders"> | Date | string
    business_id?: UuidNullableFilter<"Orders"> | string | null
    affiliate_id?: IntNullableFilter<"Orders"> | number | null
    product_id?: IntNullableFilter<"Orders"> | number | null
    affiliate?: XOR<AffiliatesNullableScalarRelationFilter, AffiliatesWhereInput> | null
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
  }

  export type OrdersOrderByWithRelationInput = {
    id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    customer_email?: SortOrder
    customer_address?: SortOrderInput | SortOrder
    invoice_url?: SortOrderInput | SortOrder
    order_quantity?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    business_id?: SortOrderInput | SortOrder
    affiliate_id?: SortOrderInput | SortOrder
    product_id?: SortOrderInput | SortOrder
    affiliate?: AffiliatesOrderByWithRelationInput
    business?: BusinessOrderByWithRelationInput
    products?: ProductsOrderByWithRelationInput
  }

  export type OrdersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrdersWhereInput | OrdersWhereInput[]
    OR?: OrdersWhereInput[]
    NOT?: OrdersWhereInput | OrdersWhereInput[]
    customer_name?: StringNullableFilter<"Orders"> | string | null
    customer_email?: StringFilter<"Orders"> | string
    customer_address?: StringNullableFilter<"Orders"> | string | null
    invoice_url?: StringNullableFilter<"Orders"> | string | null
    order_quantity?: IntNullableFilter<"Orders"> | number | null
    status?: StringNullableFilter<"Orders"> | string | null
    created_at?: DateTimeFilter<"Orders"> | Date | string
    updated_at?: DateTimeFilter<"Orders"> | Date | string
    business_id?: UuidNullableFilter<"Orders"> | string | null
    affiliate_id?: IntNullableFilter<"Orders"> | number | null
    product_id?: IntNullableFilter<"Orders"> | number | null
    affiliate?: XOR<AffiliatesNullableScalarRelationFilter, AffiliatesWhereInput> | null
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
  }, "id">

  export type OrdersOrderByWithAggregationInput = {
    id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    customer_email?: SortOrder
    customer_address?: SortOrderInput | SortOrder
    invoice_url?: SortOrderInput | SortOrder
    order_quantity?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    business_id?: SortOrderInput | SortOrder
    affiliate_id?: SortOrderInput | SortOrder
    product_id?: SortOrderInput | SortOrder
    _count?: OrdersCountOrderByAggregateInput
    _avg?: OrdersAvgOrderByAggregateInput
    _max?: OrdersMaxOrderByAggregateInput
    _min?: OrdersMinOrderByAggregateInput
    _sum?: OrdersSumOrderByAggregateInput
  }

  export type OrdersScalarWhereWithAggregatesInput = {
    AND?: OrdersScalarWhereWithAggregatesInput | OrdersScalarWhereWithAggregatesInput[]
    OR?: OrdersScalarWhereWithAggregatesInput[]
    NOT?: OrdersScalarWhereWithAggregatesInput | OrdersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Orders"> | string
    customer_name?: StringNullableWithAggregatesFilter<"Orders"> | string | null
    customer_email?: StringWithAggregatesFilter<"Orders"> | string
    customer_address?: StringNullableWithAggregatesFilter<"Orders"> | string | null
    invoice_url?: StringNullableWithAggregatesFilter<"Orders"> | string | null
    order_quantity?: IntNullableWithAggregatesFilter<"Orders"> | number | null
    status?: StringNullableWithAggregatesFilter<"Orders"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Orders"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Orders"> | Date | string
    business_id?: UuidNullableWithAggregatesFilter<"Orders"> | string | null
    affiliate_id?: IntNullableWithAggregatesFilter<"Orders"> | number | null
    product_id?: IntNullableWithAggregatesFilter<"Orders"> | number | null
  }

  export type ProductsWhereInput = {
    AND?: ProductsWhereInput | ProductsWhereInput[]
    OR?: ProductsWhereInput[]
    NOT?: ProductsWhereInput | ProductsWhereInput[]
    name?: StringFilter<"Products"> | string
    description?: StringFilter<"Products"> | string
    html_description?: StringNullableFilter<"Products"> | string | null
    image_url?: StringNullableFilter<"Products"> | string | null
    price?: FloatFilter<"Products"> | number
    price_currency?: StringNullableFilter<"Products"> | string | null
    is_shippable?: BoolNullableFilter<"Products"> | boolean | null
    price_type?: EnumPriceTypeNullableFilter<"Products"> | $Enums.PriceType | null
    created_at?: DateTimeFilter<"Products"> | Date | string
    updated_at?: DateTimeFilter<"Products"> | Date | string
    status?: StringFilter<"Products"> | string
    business_id?: UuidNullableFilter<"Products"> | string | null
    metadata?: JsonNullableFilter<"Products">
    id?: IntFilter<"Products"> | number
    affiliate_business?: Affiliate_BusinessListRelationFilter
    orders?: OrdersListRelationFilter
    pipelines?: PipelinesListRelationFilter
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
  }

  export type ProductsOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrder
    html_description?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    price?: SortOrder
    price_currency?: SortOrderInput | SortOrder
    is_shippable?: SortOrderInput | SortOrder
    price_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    business_id?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    id?: SortOrder
    affiliate_business?: Affiliate_BusinessOrderByRelationAggregateInput
    orders?: OrdersOrderByRelationAggregateInput
    pipelines?: PipelinesOrderByRelationAggregateInput
    business?: BusinessOrderByWithRelationInput
  }

  export type ProductsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductsWhereInput | ProductsWhereInput[]
    OR?: ProductsWhereInput[]
    NOT?: ProductsWhereInput | ProductsWhereInput[]
    name?: StringFilter<"Products"> | string
    description?: StringFilter<"Products"> | string
    html_description?: StringNullableFilter<"Products"> | string | null
    image_url?: StringNullableFilter<"Products"> | string | null
    price?: FloatFilter<"Products"> | number
    price_currency?: StringNullableFilter<"Products"> | string | null
    is_shippable?: BoolNullableFilter<"Products"> | boolean | null
    price_type?: EnumPriceTypeNullableFilter<"Products"> | $Enums.PriceType | null
    created_at?: DateTimeFilter<"Products"> | Date | string
    updated_at?: DateTimeFilter<"Products"> | Date | string
    status?: StringFilter<"Products"> | string
    business_id?: UuidNullableFilter<"Products"> | string | null
    metadata?: JsonNullableFilter<"Products">
    affiliate_business?: Affiliate_BusinessListRelationFilter
    orders?: OrdersListRelationFilter
    pipelines?: PipelinesListRelationFilter
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
  }, "id">

  export type ProductsOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrder
    html_description?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    price?: SortOrder
    price_currency?: SortOrderInput | SortOrder
    is_shippable?: SortOrderInput | SortOrder
    price_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    business_id?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    id?: SortOrder
    _count?: ProductsCountOrderByAggregateInput
    _avg?: ProductsAvgOrderByAggregateInput
    _max?: ProductsMaxOrderByAggregateInput
    _min?: ProductsMinOrderByAggregateInput
    _sum?: ProductsSumOrderByAggregateInput
  }

  export type ProductsScalarWhereWithAggregatesInput = {
    AND?: ProductsScalarWhereWithAggregatesInput | ProductsScalarWhereWithAggregatesInput[]
    OR?: ProductsScalarWhereWithAggregatesInput[]
    NOT?: ProductsScalarWhereWithAggregatesInput | ProductsScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"Products"> | string
    description?: StringWithAggregatesFilter<"Products"> | string
    html_description?: StringNullableWithAggregatesFilter<"Products"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"Products"> | string | null
    price?: FloatWithAggregatesFilter<"Products"> | number
    price_currency?: StringNullableWithAggregatesFilter<"Products"> | string | null
    is_shippable?: BoolNullableWithAggregatesFilter<"Products"> | boolean | null
    price_type?: EnumPriceTypeNullableWithAggregatesFilter<"Products"> | $Enums.PriceType | null
    created_at?: DateTimeWithAggregatesFilter<"Products"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Products"> | Date | string
    status?: StringWithAggregatesFilter<"Products"> | string
    business_id?: UuidNullableWithAggregatesFilter<"Products"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Products">
    id?: IntWithAggregatesFilter<"Products"> | number
  }

  export type PipelinesWhereInput = {
    AND?: PipelinesWhereInput | PipelinesWhereInput[]
    OR?: PipelinesWhereInput[]
    NOT?: PipelinesWhereInput | PipelinesWhereInput[]
    id?: IntFilter<"Pipelines"> | number
    prompt?: StringNullableFilter<"Pipelines"> | string | null
    remark?: StringNullableFilter<"Pipelines"> | string | null
    status?: StringFilter<"Pipelines"> | string
    affiliate_count?: IntNullableFilter<"Pipelines"> | number | null
    business_id?: UuidNullableFilter<"Pipelines"> | string | null
    product_id?: IntNullableFilter<"Pipelines"> | number | null
    format?: StringNullableFilter<"Pipelines"> | string | null
    location?: StringNullableFilter<"Pipelines"> | string | null
    heygen_video_id?: StringNullableFilter<"Pipelines"> | string | null
    ig_post_id?: StringNullableFilter<"Pipelines"> | string | null
    ig_post_url?: StringNullableFilter<"Pipelines"> | string | null
    run_mode?: EnumRunModeNullableFilter<"Pipelines"> | $Enums.RunMode | null
    workflow?: StringNullableFilter<"Pipelines"> | string | null
    created_at?: DateTimeFilter<"Pipelines"> | Date | string
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    affiliate_business?: Affiliate_BusinessListRelationFilter
    ChatMessage?: ChatMessageListRelationFilter
  }

  export type PipelinesOrderByWithRelationInput = {
    id?: SortOrder
    prompt?: SortOrderInput | SortOrder
    remark?: SortOrderInput | SortOrder
    status?: SortOrder
    affiliate_count?: SortOrderInput | SortOrder
    business_id?: SortOrderInput | SortOrder
    product_id?: SortOrderInput | SortOrder
    format?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    heygen_video_id?: SortOrderInput | SortOrder
    ig_post_id?: SortOrderInput | SortOrder
    ig_post_url?: SortOrderInput | SortOrder
    run_mode?: SortOrderInput | SortOrder
    workflow?: SortOrderInput | SortOrder
    created_at?: SortOrder
    business?: BusinessOrderByWithRelationInput
    products?: ProductsOrderByWithRelationInput
    affiliate_business?: Affiliate_BusinessOrderByRelationAggregateInput
    ChatMessage?: ChatMessageOrderByRelationAggregateInput
  }

  export type PipelinesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PipelinesWhereInput | PipelinesWhereInput[]
    OR?: PipelinesWhereInput[]
    NOT?: PipelinesWhereInput | PipelinesWhereInput[]
    prompt?: StringNullableFilter<"Pipelines"> | string | null
    remark?: StringNullableFilter<"Pipelines"> | string | null
    status?: StringFilter<"Pipelines"> | string
    affiliate_count?: IntNullableFilter<"Pipelines"> | number | null
    business_id?: UuidNullableFilter<"Pipelines"> | string | null
    product_id?: IntNullableFilter<"Pipelines"> | number | null
    format?: StringNullableFilter<"Pipelines"> | string | null
    location?: StringNullableFilter<"Pipelines"> | string | null
    heygen_video_id?: StringNullableFilter<"Pipelines"> | string | null
    ig_post_id?: StringNullableFilter<"Pipelines"> | string | null
    ig_post_url?: StringNullableFilter<"Pipelines"> | string | null
    run_mode?: EnumRunModeNullableFilter<"Pipelines"> | $Enums.RunMode | null
    workflow?: StringNullableFilter<"Pipelines"> | string | null
    created_at?: DateTimeFilter<"Pipelines"> | Date | string
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    affiliate_business?: Affiliate_BusinessListRelationFilter
    ChatMessage?: ChatMessageListRelationFilter
  }, "id">

  export type PipelinesOrderByWithAggregationInput = {
    id?: SortOrder
    prompt?: SortOrderInput | SortOrder
    remark?: SortOrderInput | SortOrder
    status?: SortOrder
    affiliate_count?: SortOrderInput | SortOrder
    business_id?: SortOrderInput | SortOrder
    product_id?: SortOrderInput | SortOrder
    format?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    heygen_video_id?: SortOrderInput | SortOrder
    ig_post_id?: SortOrderInput | SortOrder
    ig_post_url?: SortOrderInput | SortOrder
    run_mode?: SortOrderInput | SortOrder
    workflow?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: PipelinesCountOrderByAggregateInput
    _avg?: PipelinesAvgOrderByAggregateInput
    _max?: PipelinesMaxOrderByAggregateInput
    _min?: PipelinesMinOrderByAggregateInput
    _sum?: PipelinesSumOrderByAggregateInput
  }

  export type PipelinesScalarWhereWithAggregatesInput = {
    AND?: PipelinesScalarWhereWithAggregatesInput | PipelinesScalarWhereWithAggregatesInput[]
    OR?: PipelinesScalarWhereWithAggregatesInput[]
    NOT?: PipelinesScalarWhereWithAggregatesInput | PipelinesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pipelines"> | number
    prompt?: StringNullableWithAggregatesFilter<"Pipelines"> | string | null
    remark?: StringNullableWithAggregatesFilter<"Pipelines"> | string | null
    status?: StringWithAggregatesFilter<"Pipelines"> | string
    affiliate_count?: IntNullableWithAggregatesFilter<"Pipelines"> | number | null
    business_id?: UuidNullableWithAggregatesFilter<"Pipelines"> | string | null
    product_id?: IntNullableWithAggregatesFilter<"Pipelines"> | number | null
    format?: StringNullableWithAggregatesFilter<"Pipelines"> | string | null
    location?: StringNullableWithAggregatesFilter<"Pipelines"> | string | null
    heygen_video_id?: StringNullableWithAggregatesFilter<"Pipelines"> | string | null
    ig_post_id?: StringNullableWithAggregatesFilter<"Pipelines"> | string | null
    ig_post_url?: StringNullableWithAggregatesFilter<"Pipelines"> | string | null
    run_mode?: EnumRunModeNullableWithAggregatesFilter<"Pipelines"> | $Enums.RunMode | null
    workflow?: StringNullableWithAggregatesFilter<"Pipelines"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Pipelines"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    sender?: StringFilter<"ChatMessage"> | string
    receiver?: StringFilter<"ChatMessage"> | string
    text?: StringFilter<"ChatMessage"> | string
    pipeline_id?: IntFilter<"ChatMessage"> | number
    chat_message_status?: StringNullableFilter<"ChatMessage"> | string | null
    created_at?: DateTimeFilter<"ChatMessage"> | Date | string
    updated_at?: DateTimeFilter<"ChatMessage"> | Date | string
    pipeline?: XOR<PipelinesScalarRelationFilter, PipelinesWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    sender?: SortOrder
    receiver?: SortOrder
    text?: SortOrder
    pipeline_id?: SortOrder
    chat_message_status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    pipeline?: PipelinesOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    sender?: StringFilter<"ChatMessage"> | string
    receiver?: StringFilter<"ChatMessage"> | string
    text?: StringFilter<"ChatMessage"> | string
    pipeline_id?: IntFilter<"ChatMessage"> | number
    chat_message_status?: StringNullableFilter<"ChatMessage"> | string | null
    created_at?: DateTimeFilter<"ChatMessage"> | Date | string
    updated_at?: DateTimeFilter<"ChatMessage"> | Date | string
    pipeline?: XOR<PipelinesScalarRelationFilter, PipelinesWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    sender?: SortOrder
    receiver?: SortOrder
    text?: SortOrder
    pipeline_id?: SortOrder
    chat_message_status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _avg?: ChatMessageAvgOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
    _sum?: ChatMessageSumOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatMessage"> | number
    sender?: StringWithAggregatesFilter<"ChatMessage"> | string
    receiver?: StringWithAggregatesFilter<"ChatMessage"> | string
    text?: StringWithAggregatesFilter<"ChatMessage"> | string
    pipeline_id?: IntWithAggregatesFilter<"ChatMessage"> | number
    chat_message_status?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type WaitlistWhereInput = {
    AND?: WaitlistWhereInput | WaitlistWhereInput[]
    OR?: WaitlistWhereInput[]
    NOT?: WaitlistWhereInput | WaitlistWhereInput[]
    id?: StringFilter<"Waitlist"> | string
    email?: StringFilter<"Waitlist"> | string
    created_at?: DateTimeFilter<"Waitlist"> | Date | string
  }

  export type WaitlistOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    created_at?: SortOrder
  }

  export type WaitlistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: WaitlistWhereInput | WaitlistWhereInput[]
    OR?: WaitlistWhereInput[]
    NOT?: WaitlistWhereInput | WaitlistWhereInput[]
    created_at?: DateTimeFilter<"Waitlist"> | Date | string
  }, "id" | "email">

  export type WaitlistOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    created_at?: SortOrder
    _count?: WaitlistCountOrderByAggregateInput
    _max?: WaitlistMaxOrderByAggregateInput
    _min?: WaitlistMinOrderByAggregateInput
  }

  export type WaitlistScalarWhereWithAggregatesInput = {
    AND?: WaitlistScalarWhereWithAggregatesInput | WaitlistScalarWhereWithAggregatesInput[]
    OR?: WaitlistScalarWhereWithAggregatesInput[]
    NOT?: WaitlistScalarWhereWithAggregatesInput | WaitlistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Waitlist"> | string
    email?: StringWithAggregatesFilter<"Waitlist"> | string
    created_at?: DateTimeWithAggregatesFilter<"Waitlist"> | Date | string
  }

  export type Pending_PaymentsWhereInput = {
    AND?: Pending_PaymentsWhereInput | Pending_PaymentsWhereInput[]
    OR?: Pending_PaymentsWhereInput[]
    NOT?: Pending_PaymentsWhereInput | Pending_PaymentsWhereInput[]
    id?: UuidFilter<"Pending_Payments"> | string
    business_id?: UuidFilter<"Pending_Payments"> | string
    product_id?: IntFilter<"Pending_Payments"> | number
    full_amount?: DecimalNullableFilter<"Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: DecimalNullableFilter<"Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: DecimalNullableFilter<"Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    payout_date?: DateTimeNullableFilter<"Pending_Payments"> | Date | string | null
    status?: StringFilter<"Pending_Payments"> | string
    created_at?: DateTimeFilter<"Pending_Payments"> | Date | string
    updated_at?: DateTimeFilter<"Pending_Payments"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
  }

  export type Pending_PaymentsOrderByWithRelationInput = {
    id?: SortOrder
    business_id?: SortOrder
    product_id?: SortOrder
    full_amount?: SortOrderInput | SortOrder
    fiat_amount?: SortOrderInput | SortOrder
    crypto_amount?: SortOrderInput | SortOrder
    payout_date?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    business?: BusinessOrderByWithRelationInput
  }

  export type Pending_PaymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Pending_PaymentsWhereInput | Pending_PaymentsWhereInput[]
    OR?: Pending_PaymentsWhereInput[]
    NOT?: Pending_PaymentsWhereInput | Pending_PaymentsWhereInput[]
    business_id?: UuidFilter<"Pending_Payments"> | string
    product_id?: IntFilter<"Pending_Payments"> | number
    full_amount?: DecimalNullableFilter<"Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: DecimalNullableFilter<"Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: DecimalNullableFilter<"Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    payout_date?: DateTimeNullableFilter<"Pending_Payments"> | Date | string | null
    status?: StringFilter<"Pending_Payments"> | string
    created_at?: DateTimeFilter<"Pending_Payments"> | Date | string
    updated_at?: DateTimeFilter<"Pending_Payments"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
  }, "id">

  export type Pending_PaymentsOrderByWithAggregationInput = {
    id?: SortOrder
    business_id?: SortOrder
    product_id?: SortOrder
    full_amount?: SortOrderInput | SortOrder
    fiat_amount?: SortOrderInput | SortOrder
    crypto_amount?: SortOrderInput | SortOrder
    payout_date?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: Pending_PaymentsCountOrderByAggregateInput
    _avg?: Pending_PaymentsAvgOrderByAggregateInput
    _max?: Pending_PaymentsMaxOrderByAggregateInput
    _min?: Pending_PaymentsMinOrderByAggregateInput
    _sum?: Pending_PaymentsSumOrderByAggregateInput
  }

  export type Pending_PaymentsScalarWhereWithAggregatesInput = {
    AND?: Pending_PaymentsScalarWhereWithAggregatesInput | Pending_PaymentsScalarWhereWithAggregatesInput[]
    OR?: Pending_PaymentsScalarWhereWithAggregatesInput[]
    NOT?: Pending_PaymentsScalarWhereWithAggregatesInput | Pending_PaymentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Pending_Payments"> | string
    business_id?: UuidWithAggregatesFilter<"Pending_Payments"> | string
    product_id?: IntWithAggregatesFilter<"Pending_Payments"> | number
    full_amount?: DecimalNullableWithAggregatesFilter<"Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: DecimalNullableWithAggregatesFilter<"Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: DecimalNullableWithAggregatesFilter<"Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    payout_date?: DateTimeNullableWithAggregatesFilter<"Pending_Payments"> | Date | string | null
    status?: StringWithAggregatesFilter<"Pending_Payments"> | string
    created_at?: DateTimeWithAggregatesFilter<"Pending_Payments"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Pending_Payments"> | Date | string
  }

  export type Affiliate_Pending_PaymentsWhereInput = {
    AND?: Affiliate_Pending_PaymentsWhereInput | Affiliate_Pending_PaymentsWhereInput[]
    OR?: Affiliate_Pending_PaymentsWhereInput[]
    NOT?: Affiliate_Pending_PaymentsWhereInput | Affiliate_Pending_PaymentsWhereInput[]
    id?: UuidFilter<"Affiliate_Pending_Payments"> | string
    affiliate_id?: IntFilter<"Affiliate_Pending_Payments"> | number
    product_id?: IntFilter<"Affiliate_Pending_Payments"> | number
    full_amount?: DecimalNullableFilter<"Affiliate_Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: DecimalNullableFilter<"Affiliate_Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: DecimalNullableFilter<"Affiliate_Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    payout_date?: DateTimeNullableFilter<"Affiliate_Pending_Payments"> | Date | string | null
    status?: StringFilter<"Affiliate_Pending_Payments"> | string
    created_at?: DateTimeFilter<"Affiliate_Pending_Payments"> | Date | string
    updated_at?: DateTimeFilter<"Affiliate_Pending_Payments"> | Date | string
    affiliate?: XOR<AffiliatesScalarRelationFilter, AffiliatesWhereInput>
  }

  export type Affiliate_Pending_PaymentsOrderByWithRelationInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
    product_id?: SortOrder
    full_amount?: SortOrderInput | SortOrder
    fiat_amount?: SortOrderInput | SortOrder
    crypto_amount?: SortOrderInput | SortOrder
    payout_date?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliate?: AffiliatesOrderByWithRelationInput
  }

  export type Affiliate_Pending_PaymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Affiliate_Pending_PaymentsWhereInput | Affiliate_Pending_PaymentsWhereInput[]
    OR?: Affiliate_Pending_PaymentsWhereInput[]
    NOT?: Affiliate_Pending_PaymentsWhereInput | Affiliate_Pending_PaymentsWhereInput[]
    affiliate_id?: IntFilter<"Affiliate_Pending_Payments"> | number
    product_id?: IntFilter<"Affiliate_Pending_Payments"> | number
    full_amount?: DecimalNullableFilter<"Affiliate_Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: DecimalNullableFilter<"Affiliate_Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: DecimalNullableFilter<"Affiliate_Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    payout_date?: DateTimeNullableFilter<"Affiliate_Pending_Payments"> | Date | string | null
    status?: StringFilter<"Affiliate_Pending_Payments"> | string
    created_at?: DateTimeFilter<"Affiliate_Pending_Payments"> | Date | string
    updated_at?: DateTimeFilter<"Affiliate_Pending_Payments"> | Date | string
    affiliate?: XOR<AffiliatesScalarRelationFilter, AffiliatesWhereInput>
  }, "id">

  export type Affiliate_Pending_PaymentsOrderByWithAggregationInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
    product_id?: SortOrder
    full_amount?: SortOrderInput | SortOrder
    fiat_amount?: SortOrderInput | SortOrder
    crypto_amount?: SortOrderInput | SortOrder
    payout_date?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: Affiliate_Pending_PaymentsCountOrderByAggregateInput
    _avg?: Affiliate_Pending_PaymentsAvgOrderByAggregateInput
    _max?: Affiliate_Pending_PaymentsMaxOrderByAggregateInput
    _min?: Affiliate_Pending_PaymentsMinOrderByAggregateInput
    _sum?: Affiliate_Pending_PaymentsSumOrderByAggregateInput
  }

  export type Affiliate_Pending_PaymentsScalarWhereWithAggregatesInput = {
    AND?: Affiliate_Pending_PaymentsScalarWhereWithAggregatesInput | Affiliate_Pending_PaymentsScalarWhereWithAggregatesInput[]
    OR?: Affiliate_Pending_PaymentsScalarWhereWithAggregatesInput[]
    NOT?: Affiliate_Pending_PaymentsScalarWhereWithAggregatesInput | Affiliate_Pending_PaymentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Affiliate_Pending_Payments"> | string
    affiliate_id?: IntWithAggregatesFilter<"Affiliate_Pending_Payments"> | number
    product_id?: IntWithAggregatesFilter<"Affiliate_Pending_Payments"> | number
    full_amount?: DecimalNullableWithAggregatesFilter<"Affiliate_Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: DecimalNullableWithAggregatesFilter<"Affiliate_Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: DecimalNullableWithAggregatesFilter<"Affiliate_Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    payout_date?: DateTimeNullableWithAggregatesFilter<"Affiliate_Pending_Payments"> | Date | string | null
    status?: StringWithAggregatesFilter<"Affiliate_Pending_Payments"> | string
    created_at?: DateTimeWithAggregatesFilter<"Affiliate_Pending_Payments"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Affiliate_Pending_Payments"> | Date | string
  }

  export type embeddingsWhereInput = {
    AND?: embeddingsWhereInput | embeddingsWhereInput[]
    OR?: embeddingsWhereInput[]
    NOT?: embeddingsWhereInput | embeddingsWhereInput[]
    id?: BigIntFilter<"embeddings"> | bigint | number
    created_at?: DateTimeFilter<"embeddings"> | Date | string
    content?: StringNullableFilter<"embeddings"> | string | null
    resource_id?: BigIntNullableFilter<"embeddings"> | bigint | number | null
    resources?: XOR<ResourcesNullableScalarRelationFilter, resourcesWhereInput> | null
  }

  export type embeddingsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    content?: SortOrderInput | SortOrder
    resource_id?: SortOrderInput | SortOrder
    resources?: resourcesOrderByWithRelationInput
  }

  export type embeddingsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: embeddingsWhereInput | embeddingsWhereInput[]
    OR?: embeddingsWhereInput[]
    NOT?: embeddingsWhereInput | embeddingsWhereInput[]
    created_at?: DateTimeFilter<"embeddings"> | Date | string
    content?: StringNullableFilter<"embeddings"> | string | null
    resource_id?: BigIntNullableFilter<"embeddings"> | bigint | number | null
    resources?: XOR<ResourcesNullableScalarRelationFilter, resourcesWhereInput> | null
  }, "id">

  export type embeddingsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    content?: SortOrderInput | SortOrder
    resource_id?: SortOrderInput | SortOrder
    _count?: embeddingsCountOrderByAggregateInput
    _avg?: embeddingsAvgOrderByAggregateInput
    _max?: embeddingsMaxOrderByAggregateInput
    _min?: embeddingsMinOrderByAggregateInput
    _sum?: embeddingsSumOrderByAggregateInput
  }

  export type embeddingsScalarWhereWithAggregatesInput = {
    AND?: embeddingsScalarWhereWithAggregatesInput | embeddingsScalarWhereWithAggregatesInput[]
    OR?: embeddingsScalarWhereWithAggregatesInput[]
    NOT?: embeddingsScalarWhereWithAggregatesInput | embeddingsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"embeddings"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"embeddings"> | Date | string
    content?: StringNullableWithAggregatesFilter<"embeddings"> | string | null
    resource_id?: BigIntNullableWithAggregatesFilter<"embeddings"> | bigint | number | null
  }

  export type ig_chat_historyWhereInput = {
    AND?: ig_chat_historyWhereInput | ig_chat_historyWhereInput[]
    OR?: ig_chat_historyWhereInput[]
    NOT?: ig_chat_historyWhereInput | ig_chat_historyWhereInput[]
    id?: BigIntFilter<"ig_chat_history"> | bigint | number
    created_at?: DateTimeFilter<"ig_chat_history"> | Date | string
    ig_recipient_id?: StringNullableFilter<"ig_chat_history"> | string | null
    message?: StringNullableFilter<"ig_chat_history"> | string | null
    role?: StringNullableFilter<"ig_chat_history"> | string | null
  }

  export type ig_chat_historyOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    ig_recipient_id?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
  }

  export type ig_chat_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ig_chat_historyWhereInput | ig_chat_historyWhereInput[]
    OR?: ig_chat_historyWhereInput[]
    NOT?: ig_chat_historyWhereInput | ig_chat_historyWhereInput[]
    created_at?: DateTimeFilter<"ig_chat_history"> | Date | string
    ig_recipient_id?: StringNullableFilter<"ig_chat_history"> | string | null
    message?: StringNullableFilter<"ig_chat_history"> | string | null
    role?: StringNullableFilter<"ig_chat_history"> | string | null
  }, "id">

  export type ig_chat_historyOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    ig_recipient_id?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    _count?: ig_chat_historyCountOrderByAggregateInput
    _avg?: ig_chat_historyAvgOrderByAggregateInput
    _max?: ig_chat_historyMaxOrderByAggregateInput
    _min?: ig_chat_historyMinOrderByAggregateInput
    _sum?: ig_chat_historySumOrderByAggregateInput
  }

  export type ig_chat_historyScalarWhereWithAggregatesInput = {
    AND?: ig_chat_historyScalarWhereWithAggregatesInput | ig_chat_historyScalarWhereWithAggregatesInput[]
    OR?: ig_chat_historyScalarWhereWithAggregatesInput[]
    NOT?: ig_chat_historyScalarWhereWithAggregatesInput | ig_chat_historyScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ig_chat_history"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"ig_chat_history"> | Date | string
    ig_recipient_id?: StringNullableWithAggregatesFilter<"ig_chat_history"> | string | null
    message?: StringNullableWithAggregatesFilter<"ig_chat_history"> | string | null
    role?: StringNullableWithAggregatesFilter<"ig_chat_history"> | string | null
  }

  export type resourcesWhereInput = {
    AND?: resourcesWhereInput | resourcesWhereInput[]
    OR?: resourcesWhereInput[]
    NOT?: resourcesWhereInput | resourcesWhereInput[]
    id?: BigIntFilter<"resources"> | bigint | number
    content?: StringNullableFilter<"resources"> | string | null
    created_at?: DateTimeFilter<"resources"> | Date | string
    updated_at?: DateTimeNullableFilter<"resources"> | Date | string | null
    embeddings?: EmbeddingsListRelationFilter
  }

  export type resourcesOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    embeddings?: embeddingsOrderByRelationAggregateInput
  }

  export type resourcesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: resourcesWhereInput | resourcesWhereInput[]
    OR?: resourcesWhereInput[]
    NOT?: resourcesWhereInput | resourcesWhereInput[]
    content?: StringNullableFilter<"resources"> | string | null
    created_at?: DateTimeFilter<"resources"> | Date | string
    updated_at?: DateTimeNullableFilter<"resources"> | Date | string | null
    embeddings?: EmbeddingsListRelationFilter
  }, "id">

  export type resourcesOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: resourcesCountOrderByAggregateInput
    _avg?: resourcesAvgOrderByAggregateInput
    _max?: resourcesMaxOrderByAggregateInput
    _min?: resourcesMinOrderByAggregateInput
    _sum?: resourcesSumOrderByAggregateInput
  }

  export type resourcesScalarWhereWithAggregatesInput = {
    AND?: resourcesScalarWhereWithAggregatesInput | resourcesScalarWhereWithAggregatesInput[]
    OR?: resourcesScalarWhereWithAggregatesInput[]
    NOT?: resourcesScalarWhereWithAggregatesInput | resourcesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"resources"> | bigint | number
    content?: StringNullableWithAggregatesFilter<"resources"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"resources"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"resources"> | Date | string | null
  }

  export type ig_access_tokenWhereInput = {
    AND?: ig_access_tokenWhereInput | ig_access_tokenWhereInput[]
    OR?: ig_access_tokenWhereInput[]
    NOT?: ig_access_tokenWhereInput | ig_access_tokenWhereInput[]
    id?: UuidFilter<"ig_access_token"> | string
    token?: StringFilter<"ig_access_token"> | string
    encryption_iv?: StringFilter<"ig_access_token"> | string
    expires_at?: StringFilter<"ig_access_token"> | string
    created_at?: DateTimeFilter<"ig_access_token"> | Date | string
    updated_at?: DateTimeFilter<"ig_access_token"> | Date | string
  }

  export type ig_access_tokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    encryption_iv?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ig_access_tokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ig_access_tokenWhereInput | ig_access_tokenWhereInput[]
    OR?: ig_access_tokenWhereInput[]
    NOT?: ig_access_tokenWhereInput | ig_access_tokenWhereInput[]
    token?: StringFilter<"ig_access_token"> | string
    encryption_iv?: StringFilter<"ig_access_token"> | string
    expires_at?: StringFilter<"ig_access_token"> | string
    created_at?: DateTimeFilter<"ig_access_token"> | Date | string
    updated_at?: DateTimeFilter<"ig_access_token"> | Date | string
  }, "id">

  export type ig_access_tokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    encryption_iv?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ig_access_tokenCountOrderByAggregateInput
    _max?: ig_access_tokenMaxOrderByAggregateInput
    _min?: ig_access_tokenMinOrderByAggregateInput
  }

  export type ig_access_tokenScalarWhereWithAggregatesInput = {
    AND?: ig_access_tokenScalarWhereWithAggregatesInput | ig_access_tokenScalarWhereWithAggregatesInput[]
    OR?: ig_access_tokenScalarWhereWithAggregatesInput[]
    NOT?: ig_access_tokenScalarWhereWithAggregatesInput | ig_access_tokenScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ig_access_token"> | string
    token?: StringWithAggregatesFilter<"ig_access_token"> | string
    encryption_iv?: StringWithAggregatesFilter<"ig_access_token"> | string
    expires_at?: StringWithAggregatesFilter<"ig_access_token"> | string
    created_at?: DateTimeWithAggregatesFilter<"ig_access_token"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ig_access_token"> | Date | string
  }

  export type ig_scope_identifiersWhereInput = {
    AND?: ig_scope_identifiersWhereInput | ig_scope_identifiersWhereInput[]
    OR?: ig_scope_identifiersWhereInput[]
    NOT?: ig_scope_identifiersWhereInput | ig_scope_identifiersWhereInput[]
    id?: UuidFilter<"ig_scope_identifiers"> | string
    ig_username?: StringFilter<"ig_scope_identifiers"> | string
    created_at?: DateTimeFilter<"ig_scope_identifiers"> | Date | string
    updated_at?: DateTimeFilter<"ig_scope_identifiers"> | Date | string
    affiliate_business?: Affiliate_BusinessListRelationFilter
  }

  export type ig_scope_identifiersOrderByWithRelationInput = {
    id?: SortOrder
    ig_username?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliate_business?: Affiliate_BusinessOrderByRelationAggregateInput
  }

  export type ig_scope_identifiersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ig_username?: string
    AND?: ig_scope_identifiersWhereInput | ig_scope_identifiersWhereInput[]
    OR?: ig_scope_identifiersWhereInput[]
    NOT?: ig_scope_identifiersWhereInput | ig_scope_identifiersWhereInput[]
    created_at?: DateTimeFilter<"ig_scope_identifiers"> | Date | string
    updated_at?: DateTimeFilter<"ig_scope_identifiers"> | Date | string
    affiliate_business?: Affiliate_BusinessListRelationFilter
  }, "id" | "ig_username">

  export type ig_scope_identifiersOrderByWithAggregationInput = {
    id?: SortOrder
    ig_username?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ig_scope_identifiersCountOrderByAggregateInput
    _max?: ig_scope_identifiersMaxOrderByAggregateInput
    _min?: ig_scope_identifiersMinOrderByAggregateInput
  }

  export type ig_scope_identifiersScalarWhereWithAggregatesInput = {
    AND?: ig_scope_identifiersScalarWhereWithAggregatesInput | ig_scope_identifiersScalarWhereWithAggregatesInput[]
    OR?: ig_scope_identifiersScalarWhereWithAggregatesInput[]
    NOT?: ig_scope_identifiersScalarWhereWithAggregatesInput | ig_scope_identifiersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ig_scope_identifiers"> | string
    ig_username?: StringWithAggregatesFilter<"ig_scope_identifiers"> | string
    created_at?: DateTimeWithAggregatesFilter<"ig_scope_identifiers"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ig_scope_identifiers"> | Date | string
  }

  export type BusinessCreateInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutBusinessInput
    messages?: MessagesCreateNestedManyWithoutBusinessInput
    orders?: OrdersCreateNestedManyWithoutBusinessInput
    pipelines?: PipelinesCreateNestedManyWithoutBusinessInput
    products?: ProductsCreateNestedManyWithoutBusinessInput
    pending_payments?: Pending_PaymentsCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutBusinessInput
    messages?: MessagesUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrdersUncheckedCreateNestedManyWithoutBusinessInput
    pipelines?: PipelinesUncheckedCreateNestedManyWithoutBusinessInput
    products?: ProductsUncheckedCreateNestedManyWithoutBusinessInput
    pending_payments?: Pending_PaymentsUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutBusinessNestedInput
    messages?: MessagesUpdateManyWithoutBusinessNestedInput
    orders?: OrdersUpdateManyWithoutBusinessNestedInput
    pipelines?: PipelinesUpdateManyWithoutBusinessNestedInput
    products?: ProductsUpdateManyWithoutBusinessNestedInput
    pending_payments?: Pending_PaymentsUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutBusinessNestedInput
    messages?: MessagesUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutBusinessNestedInput
    pipelines?: PipelinesUncheckedUpdateManyWithoutBusinessNestedInput
    products?: ProductsUncheckedUpdateManyWithoutBusinessNestedInput
    pending_payments?: Pending_PaymentsUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateManyInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
  }

  export type BusinessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
  }

  export type BusinessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
  }

  export type MessagesCreateInput = {
    id?: string
    message: string
    type: string
    sent_at?: Date | string
    message_id?: string | null
    email?: string | null
    name?: string | null
    subject: string
    channel_id?: string | null
    video_id?: string | null
    business: BusinessCreateNestedOneWithoutMessagesInput
    parent?: MessagesCreateNestedOneWithoutRepliesInput
    replies?: MessagesCreateNestedManyWithoutParentInput
  }

  export type MessagesUncheckedCreateInput = {
    id?: string
    message: string
    type: string
    sent_at?: Date | string
    business_id: string
    message_id?: string | null
    email?: string | null
    name?: string | null
    subject: string
    parent_id?: string | null
    channel_id?: string | null
    video_id?: string | null
    replies?: MessagesUncheckedCreateNestedManyWithoutParentInput
  }

  export type MessagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    channel_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessUpdateOneRequiredWithoutMessagesNestedInput
    parent?: MessagesUpdateOneWithoutRepliesNestedInput
    replies?: MessagesUpdateManyWithoutParentNestedInput
  }

  export type MessagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business_id?: StringFieldUpdateOperationsInput | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    channel_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessagesUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MessagesCreateManyInput = {
    id?: string
    message: string
    type: string
    sent_at?: Date | string
    business_id: string
    message_id?: string | null
    email?: string | null
    name?: string | null
    subject: string
    parent_id?: string | null
    channel_id?: string | null
    video_id?: string | null
  }

  export type MessagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    channel_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business_id?: StringFieldUpdateOperationsInput | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    channel_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AffiliatesCreateInput = {
    first_name?: string | null
    last_name?: string | null
    email: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    wallet_address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutAffiliateInput
    orders?: OrdersCreateNestedManyWithoutAffiliateInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliatesUncheckedCreateInput = {
    id?: number
    first_name?: string | null
    last_name?: string | null
    email: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    wallet_address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliateInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliatesUpdateInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutAffiliateNestedInput
    orders?: OrdersUpdateManyWithoutAffiliateNestedInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliatesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutAffiliateNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliateNestedInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliatesCreateManyInput = {
    id?: number
    first_name?: string | null
    last_name?: string | null
    email: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    wallet_address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AffiliatesUpdateManyMutationInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AffiliatesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
  }

  export type Affiliate_BusinessCreateInput = {
    id?: string
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    ig_scope_identifier?: ig_scope_identifiersCreateNestedOneWithoutAffiliate_businessInput
    affiliate: AffiliatesCreateNestedOneWithoutAffiliate_businessInput
    business: BusinessCreateNestedOneWithoutAffiliate_businessInput
    products?: ProductsCreateNestedOneWithoutAffiliate_businessInput
    pipelines?: PipelinesCreateNestedOneWithoutAffiliate_businessInput
  }

  export type Affiliate_BusinessUncheckedCreateInput = {
    id?: string
    business_id: string
    affiliate_id: number
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    product_id?: number | null
    pipeline_id?: number | null
    instagram_scope_identifier?: string | null
  }

  export type Affiliate_BusinessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    ig_scope_identifier?: ig_scope_identifiersUpdateOneWithoutAffiliate_businessNestedInput
    affiliate?: AffiliatesUpdateOneRequiredWithoutAffiliate_businessNestedInput
    business?: BusinessUpdateOneRequiredWithoutAffiliate_businessNestedInput
    products?: ProductsUpdateOneWithoutAffiliate_businessNestedInput
    pipelines?: PipelinesUpdateOneWithoutAffiliate_businessNestedInput
  }

  export type Affiliate_BusinessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_id?: StringFieldUpdateOperationsInput | string
    affiliate_id?: IntFieldUpdateOperationsInput | number
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    pipeline_id?: NullableIntFieldUpdateOperationsInput | number | null
    instagram_scope_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Affiliate_BusinessCreateManyInput = {
    id?: string
    business_id: string
    affiliate_id: number
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    product_id?: number | null
    pipeline_id?: number | null
    instagram_scope_identifier?: string | null
  }

  export type Affiliate_BusinessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Affiliate_BusinessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_id?: StringFieldUpdateOperationsInput | string
    affiliate_id?: IntFieldUpdateOperationsInput | number
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    pipeline_id?: NullableIntFieldUpdateOperationsInput | number | null
    instagram_scope_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrdersCreateInput = {
    id?: string
    customer_name?: string | null
    customer_email: string
    customer_address?: string | null
    invoice_url?: string | null
    order_quantity?: number | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    affiliate?: AffiliatesCreateNestedOneWithoutOrdersInput
    business?: BusinessCreateNestedOneWithoutOrdersInput
    products?: ProductsCreateNestedOneWithoutOrdersInput
  }

  export type OrdersUncheckedCreateInput = {
    id?: string
    customer_name?: string | null
    customer_email: string
    customer_address?: string | null
    invoice_url?: string | null
    order_quantity?: number | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    business_id?: string | null
    affiliate_id?: number | null
    product_id?: number | null
  }

  export type OrdersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliatesUpdateOneWithoutOrdersNestedInput
    business?: BusinessUpdateOneWithoutOrdersNestedInput
    products?: ProductsUpdateOneWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrdersCreateManyInput = {
    id?: string
    customer_name?: string | null
    customer_email: string
    customer_address?: string | null
    invoice_url?: string | null
    order_quantity?: number | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    business_id?: string | null
    affiliate_id?: number | null
    product_id?: number | null
  }

  export type OrdersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductsCreateInput = {
    name: string
    description: string
    html_description?: string | null
    image_url?: string | null
    price: number
    price_currency?: string | null
    is_shippable?: boolean | null
    price_type?: $Enums.PriceType | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutProductsInput
    orders?: OrdersCreateNestedManyWithoutProductsInput
    pipelines?: PipelinesCreateNestedManyWithoutProductsInput
    business?: BusinessCreateNestedOneWithoutProductsInput
  }

  export type ProductsUncheckedCreateInput = {
    name: string
    description: string
    html_description?: string | null
    image_url?: string | null
    price: number
    price_currency?: string | null
    is_shippable?: boolean | null
    price_type?: $Enums.PriceType | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    business_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: number
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrdersUncheckedCreateNestedManyWithoutProductsInput
    pipelines?: PipelinesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutProductsNestedInput
    orders?: OrdersUpdateManyWithoutProductsNestedInput
    pipelines?: PipelinesUpdateManyWithoutProductsNestedInput
    business?: BusinessUpdateOneWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: IntFieldUpdateOperationsInput | number
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutProductsNestedInput
    pipelines?: PipelinesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsCreateManyInput = {
    name: string
    description: string
    html_description?: string | null
    image_url?: string | null
    price: number
    price_currency?: string | null
    is_shippable?: boolean | null
    price_type?: $Enums.PriceType | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    business_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: number
  }

  export type ProductsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PipelinesCreateInput = {
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
    business?: BusinessCreateNestedOneWithoutPipelinesInput
    products?: ProductsCreateNestedOneWithoutPipelinesInput
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutPipelinesInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutPipelineInput
  }

  export type PipelinesUncheckedCreateInput = {
    id?: number
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    business_id?: string | null
    product_id?: number | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutPipelinesInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelinesUpdateInput = {
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneWithoutPipelinesNestedInput
    products?: ProductsUpdateOneWithoutPipelinesNestedInput
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutPipelinesNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutPipelineNestedInput
  }

  export type PipelinesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutPipelinesNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type PipelinesCreateManyInput = {
    id?: number
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    business_id?: string | null
    product_id?: number | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
  }

  export type PipelinesUpdateManyMutationInput = {
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelinesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    sender: string
    receiver: string
    text: string
    chat_message_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    pipeline: PipelinesCreateNestedOneWithoutChatMessageInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: number
    sender: string
    receiver: string
    text: string
    pipeline_id: number
    chat_message_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatMessageUpdateInput = {
    sender?: StringFieldUpdateOperationsInput | string
    receiver?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    chat_message_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pipeline?: PipelinesUpdateOneRequiredWithoutChatMessageNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender?: StringFieldUpdateOperationsInput | string
    receiver?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    pipeline_id?: IntFieldUpdateOperationsInput | number
    chat_message_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: number
    sender: string
    receiver: string
    text: string
    pipeline_id: number
    chat_message_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    sender?: StringFieldUpdateOperationsInput | string
    receiver?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    chat_message_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender?: StringFieldUpdateOperationsInput | string
    receiver?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    pipeline_id?: IntFieldUpdateOperationsInput | number
    chat_message_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistCreateInput = {
    id?: string
    email: string
    created_at?: Date | string
  }

  export type WaitlistUncheckedCreateInput = {
    id?: string
    email: string
    created_at?: Date | string
  }

  export type WaitlistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistCreateManyInput = {
    id?: string
    email: string
    created_at?: Date | string
  }

  export type WaitlistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Pending_PaymentsCreateInput = {
    id?: string
    product_id: number
    full_amount?: Decimal | DecimalJsLike | number | string | null
    fiat_amount?: Decimal | DecimalJsLike | number | string | null
    crypto_amount?: Decimal | DecimalJsLike | number | string | null
    payout_date?: Date | string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    business: BusinessCreateNestedOneWithoutPending_paymentsInput
  }

  export type Pending_PaymentsUncheckedCreateInput = {
    id?: string
    business_id: string
    product_id: number
    full_amount?: Decimal | DecimalJsLike | number | string | null
    fiat_amount?: Decimal | DecimalJsLike | number | string | null
    crypto_amount?: Decimal | DecimalJsLike | number | string | null
    payout_date?: Date | string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Pending_PaymentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutPending_paymentsNestedInput
  }

  export type Pending_PaymentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_id?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Pending_PaymentsCreateManyInput = {
    id?: string
    business_id: string
    product_id: number
    full_amount?: Decimal | DecimalJsLike | number | string | null
    fiat_amount?: Decimal | DecimalJsLike | number | string | null
    crypto_amount?: Decimal | DecimalJsLike | number | string | null
    payout_date?: Date | string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Pending_PaymentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Pending_PaymentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_id?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Affiliate_Pending_PaymentsCreateInput = {
    id?: string
    product_id: number
    full_amount?: Decimal | DecimalJsLike | number | string | null
    fiat_amount?: Decimal | DecimalJsLike | number | string | null
    crypto_amount?: Decimal | DecimalJsLike | number | string | null
    payout_date?: Date | string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate: AffiliatesCreateNestedOneWithoutAffiliate_pending_paymentsInput
  }

  export type Affiliate_Pending_PaymentsUncheckedCreateInput = {
    id?: string
    affiliate_id: number
    product_id: number
    full_amount?: Decimal | DecimalJsLike | number | string | null
    fiat_amount?: Decimal | DecimalJsLike | number | string | null
    crypto_amount?: Decimal | DecimalJsLike | number | string | null
    payout_date?: Date | string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Affiliate_Pending_PaymentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliatesUpdateOneRequiredWithoutAffiliate_pending_paymentsNestedInput
  }

  export type Affiliate_Pending_PaymentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Affiliate_Pending_PaymentsCreateManyInput = {
    id?: string
    affiliate_id: number
    product_id: number
    full_amount?: Decimal | DecimalJsLike | number | string | null
    fiat_amount?: Decimal | DecimalJsLike | number | string | null
    crypto_amount?: Decimal | DecimalJsLike | number | string | null
    payout_date?: Date | string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Affiliate_Pending_PaymentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Affiliate_Pending_PaymentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type embeddingsCreateInput = {
    id?: bigint | number
    created_at?: Date | string
    content?: string | null
    resources?: resourcesCreateNestedOneWithoutEmbeddingsInput
  }

  export type embeddingsUncheckedCreateInput = {
    id?: bigint | number
    created_at?: Date | string
    content?: string | null
    resource_id?: bigint | number | null
  }

  export type embeddingsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: resourcesUpdateOneWithoutEmbeddingsNestedInput
  }

  export type embeddingsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type embeddingsCreateManyInput = {
    id?: bigint | number
    created_at?: Date | string
    content?: string | null
    resource_id?: bigint | number | null
  }

  export type embeddingsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type embeddingsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type ig_chat_historyCreateInput = {
    id?: bigint | number
    created_at?: Date | string
    ig_recipient_id?: string | null
    message?: string | null
    role?: string | null
  }

  export type ig_chat_historyUncheckedCreateInput = {
    id?: bigint | number
    created_at?: Date | string
    ig_recipient_id?: string | null
    message?: string | null
    role?: string | null
  }

  export type ig_chat_historyUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ig_recipient_id?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ig_chat_historyUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ig_recipient_id?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ig_chat_historyCreateManyInput = {
    id?: bigint | number
    created_at?: Date | string
    ig_recipient_id?: string | null
    message?: string | null
    role?: string | null
  }

  export type ig_chat_historyUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ig_recipient_id?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ig_chat_historyUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ig_recipient_id?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type resourcesCreateInput = {
    id?: bigint | number
    content?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    embeddings?: embeddingsCreateNestedManyWithoutResourcesInput
  }

  export type resourcesUncheckedCreateInput = {
    id?: bigint | number
    content?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    embeddings?: embeddingsUncheckedCreateNestedManyWithoutResourcesInput
  }

  export type resourcesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    embeddings?: embeddingsUpdateManyWithoutResourcesNestedInput
  }

  export type resourcesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    embeddings?: embeddingsUncheckedUpdateManyWithoutResourcesNestedInput
  }

  export type resourcesCreateManyInput = {
    id?: bigint | number
    content?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type resourcesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourcesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ig_access_tokenCreateInput = {
    id?: string
    token: string
    encryption_iv: string
    expires_at: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ig_access_tokenUncheckedCreateInput = {
    id?: string
    token: string
    encryption_iv: string
    expires_at: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ig_access_tokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    encryption_iv?: StringFieldUpdateOperationsInput | string
    expires_at?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ig_access_tokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    encryption_iv?: StringFieldUpdateOperationsInput | string
    expires_at?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ig_access_tokenCreateManyInput = {
    id?: string
    token: string
    encryption_iv: string
    expires_at: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ig_access_tokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    encryption_iv?: StringFieldUpdateOperationsInput | string
    expires_at?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ig_access_tokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    encryption_iv?: StringFieldUpdateOperationsInput | string
    expires_at?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ig_scope_identifiersCreateInput = {
    id?: string
    ig_username: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutIg_scope_identifierInput
  }

  export type ig_scope_identifiersUncheckedCreateInput = {
    id?: string
    ig_username: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutIg_scope_identifierInput
  }

  export type ig_scope_identifiersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ig_username?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutIg_scope_identifierNestedInput
  }

  export type ig_scope_identifiersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ig_username?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutIg_scope_identifierNestedInput
  }

  export type ig_scope_identifiersCreateManyInput = {
    id?: string
    ig_username: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ig_scope_identifiersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ig_username?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ig_scope_identifiersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ig_username?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumPricePlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PricePlan | EnumPricePlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.PricePlan[] | ListEnumPricePlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PricePlan[] | ListEnumPricePlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPricePlanNullableFilter<$PrismaModel> | $Enums.PricePlan | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumPaymentPreferenceFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentPreference | EnumPaymentPreferenceFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentPreference[] | ListEnumPaymentPreferenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentPreference[] | ListEnumPaymentPreferenceFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentPreferenceFilter<$PrismaModel> | $Enums.PaymentPreference
  }

  export type Affiliate_BusinessListRelationFilter = {
    every?: Affiliate_BusinessWhereInput
    some?: Affiliate_BusinessWhereInput
    none?: Affiliate_BusinessWhereInput
  }

  export type MessagesListRelationFilter = {
    every?: MessagesWhereInput
    some?: MessagesWhereInput
    none?: MessagesWhereInput
  }

  export type OrdersListRelationFilter = {
    every?: OrdersWhereInput
    some?: OrdersWhereInput
    none?: OrdersWhereInput
  }

  export type PipelinesListRelationFilter = {
    every?: PipelinesWhereInput
    some?: PipelinesWhereInput
    none?: PipelinesWhereInput
  }

  export type ProductsListRelationFilter = {
    every?: ProductsWhereInput
    some?: ProductsWhereInput
    none?: ProductsWhereInput
  }

  export type Pending_PaymentsListRelationFilter = {
    every?: Pending_PaymentsWhereInput
    some?: Pending_PaymentsWhereInput
    none?: Pending_PaymentsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type Affiliate_BusinessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelinesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Pending_PaymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    store_name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    url?: SortOrder
    wallet_address?: SortOrder
    commission?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliate_hub_description?: SortOrder
    svix_consumer_app_id?: SortOrder
    stripe_connected_account?: SortOrder
    price_plan?: SortOrder
    trial_ends_at?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_subscription_id?: SortOrder
    payment_preference?: SortOrder
  }

  export type BusinessAvgOrderByAggregateInput = {
    commission?: SortOrder
  }

  export type BusinessMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    store_name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    url?: SortOrder
    wallet_address?: SortOrder
    commission?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliate_hub_description?: SortOrder
    svix_consumer_app_id?: SortOrder
    stripe_connected_account?: SortOrder
    price_plan?: SortOrder
    trial_ends_at?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_subscription_id?: SortOrder
    payment_preference?: SortOrder
  }

  export type BusinessMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    store_name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    url?: SortOrder
    wallet_address?: SortOrder
    commission?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliate_hub_description?: SortOrder
    svix_consumer_app_id?: SortOrder
    stripe_connected_account?: SortOrder
    price_plan?: SortOrder
    trial_ends_at?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_subscription_id?: SortOrder
    payment_preference?: SortOrder
  }

  export type BusinessSumOrderByAggregateInput = {
    commission?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPricePlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricePlan | EnumPricePlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.PricePlan[] | ListEnumPricePlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PricePlan[] | ListEnumPricePlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPricePlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.PricePlan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPricePlanNullableFilter<$PrismaModel>
    _max?: NestedEnumPricePlanNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumPaymentPreferenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentPreference | EnumPaymentPreferenceFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentPreference[] | ListEnumPaymentPreferenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentPreference[] | ListEnumPaymentPreferenceFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentPreferenceWithAggregatesFilter<$PrismaModel> | $Enums.PaymentPreference
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentPreferenceFilter<$PrismaModel>
    _max?: NestedEnumPaymentPreferenceFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type BusinessScalarRelationFilter = {
    is?: BusinessWhereInput
    isNot?: BusinessWhereInput
  }

  export type MessagesNullableScalarRelationFilter = {
    is?: MessagesWhereInput | null
    isNot?: MessagesWhereInput | null
  }

  export type MessagesCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    type?: SortOrder
    sent_at?: SortOrder
    business_id?: SortOrder
    message_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    parent_id?: SortOrder
    channel_id?: SortOrder
    video_id?: SortOrder
  }

  export type MessagesMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    type?: SortOrder
    sent_at?: SortOrder
    business_id?: SortOrder
    message_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    parent_id?: SortOrder
    channel_id?: SortOrder
    video_id?: SortOrder
  }

  export type MessagesMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    type?: SortOrder
    sent_at?: SortOrder
    business_id?: SortOrder
    message_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    parent_id?: SortOrder
    channel_id?: SortOrder
    video_id?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Affiliate_Pending_PaymentsListRelationFilter = {
    every?: Affiliate_Pending_PaymentsWhereInput
    some?: Affiliate_Pending_PaymentsWhereInput
    none?: Affiliate_Pending_PaymentsWhereInput
  }

  export type Affiliate_Pending_PaymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliatesCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    wallet_address?: SortOrder
    metadata?: SortOrder
    social_media_profiles?: SortOrder
  }

  export type AffiliatesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AffiliatesMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    wallet_address?: SortOrder
  }

  export type AffiliatesMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    wallet_address?: SortOrder
  }

  export type AffiliatesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type Ig_scope_identifiersNullableScalarRelationFilter = {
    is?: ig_scope_identifiersWhereInput | null
    isNot?: ig_scope_identifiersWhereInput | null
  }

  export type AffiliatesScalarRelationFilter = {
    is?: AffiliatesWhereInput
    isNot?: AffiliatesWhereInput
  }

  export type ProductsNullableScalarRelationFilter = {
    is?: ProductsWhereInput | null
    isNot?: ProductsWhereInput | null
  }

  export type PipelinesNullableScalarRelationFilter = {
    is?: PipelinesWhereInput | null
    isNot?: PipelinesWhereInput | null
  }

  export type Affiliate_BusinessBusiness_idAffiliate_idCompoundUniqueInput = {
    business_id: string
    affiliate_id: number
  }

  export type Affiliate_BusinessCountOrderByAggregateInput = {
    id?: SortOrder
    business_id?: SortOrder
    affiliate_id?: SortOrder
    affiliate_link?: SortOrder
    affiliate_link_key?: SortOrder
    product_id?: SortOrder
    pipeline_id?: SortOrder
    instagram_scope_identifier?: SortOrder
  }

  export type Affiliate_BusinessAvgOrderByAggregateInput = {
    affiliate_id?: SortOrder
    product_id?: SortOrder
    pipeline_id?: SortOrder
  }

  export type Affiliate_BusinessMaxOrderByAggregateInput = {
    id?: SortOrder
    business_id?: SortOrder
    affiliate_id?: SortOrder
    affiliate_link?: SortOrder
    affiliate_link_key?: SortOrder
    product_id?: SortOrder
    pipeline_id?: SortOrder
    instagram_scope_identifier?: SortOrder
  }

  export type Affiliate_BusinessMinOrderByAggregateInput = {
    id?: SortOrder
    business_id?: SortOrder
    affiliate_id?: SortOrder
    affiliate_link?: SortOrder
    affiliate_link_key?: SortOrder
    product_id?: SortOrder
    pipeline_id?: SortOrder
    instagram_scope_identifier?: SortOrder
  }

  export type Affiliate_BusinessSumOrderByAggregateInput = {
    affiliate_id?: SortOrder
    product_id?: SortOrder
    pipeline_id?: SortOrder
  }

  export type AffiliatesNullableScalarRelationFilter = {
    is?: AffiliatesWhereInput | null
    isNot?: AffiliatesWhereInput | null
  }

  export type BusinessNullableScalarRelationFilter = {
    is?: BusinessWhereInput | null
    isNot?: BusinessWhereInput | null
  }

  export type OrdersCountOrderByAggregateInput = {
    id?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrder
    customer_address?: SortOrder
    invoice_url?: SortOrder
    order_quantity?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    business_id?: SortOrder
    affiliate_id?: SortOrder
    product_id?: SortOrder
  }

  export type OrdersAvgOrderByAggregateInput = {
    order_quantity?: SortOrder
    affiliate_id?: SortOrder
    product_id?: SortOrder
  }

  export type OrdersMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrder
    customer_address?: SortOrder
    invoice_url?: SortOrder
    order_quantity?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    business_id?: SortOrder
    affiliate_id?: SortOrder
    product_id?: SortOrder
  }

  export type OrdersMinOrderByAggregateInput = {
    id?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrder
    customer_address?: SortOrder
    invoice_url?: SortOrder
    order_quantity?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    business_id?: SortOrder
    affiliate_id?: SortOrder
    product_id?: SortOrder
  }

  export type OrdersSumOrderByAggregateInput = {
    order_quantity?: SortOrder
    affiliate_id?: SortOrder
    product_id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumPriceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriceTypeNullableFilter<$PrismaModel> | $Enums.PriceType | null
  }

  export type ProductsCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    html_description?: SortOrder
    image_url?: SortOrder
    price?: SortOrder
    price_currency?: SortOrder
    is_shippable?: SortOrder
    price_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    business_id?: SortOrder
    metadata?: SortOrder
    id?: SortOrder
  }

  export type ProductsAvgOrderByAggregateInput = {
    price?: SortOrder
    id?: SortOrder
  }

  export type ProductsMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    html_description?: SortOrder
    image_url?: SortOrder
    price?: SortOrder
    price_currency?: SortOrder
    is_shippable?: SortOrder
    price_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    business_id?: SortOrder
    id?: SortOrder
  }

  export type ProductsMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    html_description?: SortOrder
    image_url?: SortOrder
    price?: SortOrder
    price_currency?: SortOrder
    is_shippable?: SortOrder
    price_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    business_id?: SortOrder
    id?: SortOrder
  }

  export type ProductsSumOrderByAggregateInput = {
    price?: SortOrder
    id?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumPriceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PriceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPriceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPriceTypeNullableFilter<$PrismaModel>
  }

  export type EnumRunModeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RunMode | EnumRunModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RunMode[] | ListEnumRunModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RunMode[] | ListEnumRunModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRunModeNullableFilter<$PrismaModel> | $Enums.RunMode | null
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelinesCountOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    remark?: SortOrder
    status?: SortOrder
    affiliate_count?: SortOrder
    business_id?: SortOrder
    product_id?: SortOrder
    format?: SortOrder
    location?: SortOrder
    heygen_video_id?: SortOrder
    ig_post_id?: SortOrder
    ig_post_url?: SortOrder
    run_mode?: SortOrder
    workflow?: SortOrder
    created_at?: SortOrder
  }

  export type PipelinesAvgOrderByAggregateInput = {
    id?: SortOrder
    affiliate_count?: SortOrder
    product_id?: SortOrder
  }

  export type PipelinesMaxOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    remark?: SortOrder
    status?: SortOrder
    affiliate_count?: SortOrder
    business_id?: SortOrder
    product_id?: SortOrder
    format?: SortOrder
    location?: SortOrder
    heygen_video_id?: SortOrder
    ig_post_id?: SortOrder
    ig_post_url?: SortOrder
    run_mode?: SortOrder
    workflow?: SortOrder
    created_at?: SortOrder
  }

  export type PipelinesMinOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    remark?: SortOrder
    status?: SortOrder
    affiliate_count?: SortOrder
    business_id?: SortOrder
    product_id?: SortOrder
    format?: SortOrder
    location?: SortOrder
    heygen_video_id?: SortOrder
    ig_post_id?: SortOrder
    ig_post_url?: SortOrder
    run_mode?: SortOrder
    workflow?: SortOrder
    created_at?: SortOrder
  }

  export type PipelinesSumOrderByAggregateInput = {
    id?: SortOrder
    affiliate_count?: SortOrder
    product_id?: SortOrder
  }

  export type EnumRunModeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RunMode | EnumRunModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RunMode[] | ListEnumRunModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RunMode[] | ListEnumRunModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRunModeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RunMode | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRunModeNullableFilter<$PrismaModel>
    _max?: NestedEnumRunModeNullableFilter<$PrismaModel>
  }

  export type PipelinesScalarRelationFilter = {
    is?: PipelinesWhereInput
    isNot?: PipelinesWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    sender?: SortOrder
    receiver?: SortOrder
    text?: SortOrder
    pipeline_id?: SortOrder
    chat_message_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChatMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    pipeline_id?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sender?: SortOrder
    receiver?: SortOrder
    text?: SortOrder
    pipeline_id?: SortOrder
    chat_message_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    sender?: SortOrder
    receiver?: SortOrder
    text?: SortOrder
    pipeline_id?: SortOrder
    chat_message_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChatMessageSumOrderByAggregateInput = {
    id?: SortOrder
    pipeline_id?: SortOrder
  }

  export type WaitlistCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    created_at?: SortOrder
  }

  export type WaitlistMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    created_at?: SortOrder
  }

  export type WaitlistMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    created_at?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type Pending_PaymentsCountOrderByAggregateInput = {
    id?: SortOrder
    business_id?: SortOrder
    product_id?: SortOrder
    full_amount?: SortOrder
    fiat_amount?: SortOrder
    crypto_amount?: SortOrder
    payout_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Pending_PaymentsAvgOrderByAggregateInput = {
    product_id?: SortOrder
    full_amount?: SortOrder
    fiat_amount?: SortOrder
    crypto_amount?: SortOrder
  }

  export type Pending_PaymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    business_id?: SortOrder
    product_id?: SortOrder
    full_amount?: SortOrder
    fiat_amount?: SortOrder
    crypto_amount?: SortOrder
    payout_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Pending_PaymentsMinOrderByAggregateInput = {
    id?: SortOrder
    business_id?: SortOrder
    product_id?: SortOrder
    full_amount?: SortOrder
    fiat_amount?: SortOrder
    crypto_amount?: SortOrder
    payout_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Pending_PaymentsSumOrderByAggregateInput = {
    product_id?: SortOrder
    full_amount?: SortOrder
    fiat_amount?: SortOrder
    crypto_amount?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type Affiliate_Pending_PaymentsCountOrderByAggregateInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
    product_id?: SortOrder
    full_amount?: SortOrder
    fiat_amount?: SortOrder
    crypto_amount?: SortOrder
    payout_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Affiliate_Pending_PaymentsAvgOrderByAggregateInput = {
    affiliate_id?: SortOrder
    product_id?: SortOrder
    full_amount?: SortOrder
    fiat_amount?: SortOrder
    crypto_amount?: SortOrder
  }

  export type Affiliate_Pending_PaymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
    product_id?: SortOrder
    full_amount?: SortOrder
    fiat_amount?: SortOrder
    crypto_amount?: SortOrder
    payout_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Affiliate_Pending_PaymentsMinOrderByAggregateInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
    product_id?: SortOrder
    full_amount?: SortOrder
    fiat_amount?: SortOrder
    crypto_amount?: SortOrder
    payout_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Affiliate_Pending_PaymentsSumOrderByAggregateInput = {
    affiliate_id?: SortOrder
    product_id?: SortOrder
    full_amount?: SortOrder
    fiat_amount?: SortOrder
    crypto_amount?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type ResourcesNullableScalarRelationFilter = {
    is?: resourcesWhereInput | null
    isNot?: resourcesWhereInput | null
  }

  export type embeddingsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    content?: SortOrder
    resource_id?: SortOrder
  }

  export type embeddingsAvgOrderByAggregateInput = {
    id?: SortOrder
    resource_id?: SortOrder
  }

  export type embeddingsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    content?: SortOrder
    resource_id?: SortOrder
  }

  export type embeddingsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    content?: SortOrder
    resource_id?: SortOrder
  }

  export type embeddingsSumOrderByAggregateInput = {
    id?: SortOrder
    resource_id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type ig_chat_historyCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    ig_recipient_id?: SortOrder
    message?: SortOrder
    role?: SortOrder
  }

  export type ig_chat_historyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ig_chat_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    ig_recipient_id?: SortOrder
    message?: SortOrder
    role?: SortOrder
  }

  export type ig_chat_historyMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    ig_recipient_id?: SortOrder
    message?: SortOrder
    role?: SortOrder
  }

  export type ig_chat_historySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmbeddingsListRelationFilter = {
    every?: embeddingsWhereInput
    some?: embeddingsWhereInput
    none?: embeddingsWhereInput
  }

  export type embeddingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type resourcesCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type resourcesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type resourcesMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type resourcesMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type resourcesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ig_access_tokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    encryption_iv?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ig_access_tokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    encryption_iv?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ig_access_tokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    encryption_iv?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ig_scope_identifiersCountOrderByAggregateInput = {
    id?: SortOrder
    ig_username?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ig_scope_identifiersMaxOrderByAggregateInput = {
    id?: SortOrder
    ig_username?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ig_scope_identifiersMinOrderByAggregateInput = {
    id?: SortOrder
    ig_username?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Affiliate_BusinessCreateNestedManyWithoutBusinessInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutBusinessInput, Affiliate_BusinessUncheckedCreateWithoutBusinessInput> | Affiliate_BusinessCreateWithoutBusinessInput[] | Affiliate_BusinessUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutBusinessInput | Affiliate_BusinessCreateOrConnectWithoutBusinessInput[]
    createMany?: Affiliate_BusinessCreateManyBusinessInputEnvelope
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
  }

  export type MessagesCreateNestedManyWithoutBusinessInput = {
    create?: XOR<MessagesCreateWithoutBusinessInput, MessagesUncheckedCreateWithoutBusinessInput> | MessagesCreateWithoutBusinessInput[] | MessagesUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutBusinessInput | MessagesCreateOrConnectWithoutBusinessInput[]
    createMany?: MessagesCreateManyBusinessInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type OrdersCreateNestedManyWithoutBusinessInput = {
    create?: XOR<OrdersCreateWithoutBusinessInput, OrdersUncheckedCreateWithoutBusinessInput> | OrdersCreateWithoutBusinessInput[] | OrdersUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutBusinessInput | OrdersCreateOrConnectWithoutBusinessInput[]
    createMany?: OrdersCreateManyBusinessInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type PipelinesCreateNestedManyWithoutBusinessInput = {
    create?: XOR<PipelinesCreateWithoutBusinessInput, PipelinesUncheckedCreateWithoutBusinessInput> | PipelinesCreateWithoutBusinessInput[] | PipelinesUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: PipelinesCreateOrConnectWithoutBusinessInput | PipelinesCreateOrConnectWithoutBusinessInput[]
    createMany?: PipelinesCreateManyBusinessInputEnvelope
    connect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
  }

  export type ProductsCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ProductsCreateWithoutBusinessInput, ProductsUncheckedCreateWithoutBusinessInput> | ProductsCreateWithoutBusinessInput[] | ProductsUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutBusinessInput | ProductsCreateOrConnectWithoutBusinessInput[]
    createMany?: ProductsCreateManyBusinessInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type Pending_PaymentsCreateNestedManyWithoutBusinessInput = {
    create?: XOR<Pending_PaymentsCreateWithoutBusinessInput, Pending_PaymentsUncheckedCreateWithoutBusinessInput> | Pending_PaymentsCreateWithoutBusinessInput[] | Pending_PaymentsUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: Pending_PaymentsCreateOrConnectWithoutBusinessInput | Pending_PaymentsCreateOrConnectWithoutBusinessInput[]
    createMany?: Pending_PaymentsCreateManyBusinessInputEnvelope
    connect?: Pending_PaymentsWhereUniqueInput | Pending_PaymentsWhereUniqueInput[]
  }

  export type Affiliate_BusinessUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutBusinessInput, Affiliate_BusinessUncheckedCreateWithoutBusinessInput> | Affiliate_BusinessCreateWithoutBusinessInput[] | Affiliate_BusinessUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutBusinessInput | Affiliate_BusinessCreateOrConnectWithoutBusinessInput[]
    createMany?: Affiliate_BusinessCreateManyBusinessInputEnvelope
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
  }

  export type MessagesUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<MessagesCreateWithoutBusinessInput, MessagesUncheckedCreateWithoutBusinessInput> | MessagesCreateWithoutBusinessInput[] | MessagesUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutBusinessInput | MessagesCreateOrConnectWithoutBusinessInput[]
    createMany?: MessagesCreateManyBusinessInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type OrdersUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<OrdersCreateWithoutBusinessInput, OrdersUncheckedCreateWithoutBusinessInput> | OrdersCreateWithoutBusinessInput[] | OrdersUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutBusinessInput | OrdersCreateOrConnectWithoutBusinessInput[]
    createMany?: OrdersCreateManyBusinessInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type PipelinesUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<PipelinesCreateWithoutBusinessInput, PipelinesUncheckedCreateWithoutBusinessInput> | PipelinesCreateWithoutBusinessInput[] | PipelinesUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: PipelinesCreateOrConnectWithoutBusinessInput | PipelinesCreateOrConnectWithoutBusinessInput[]
    createMany?: PipelinesCreateManyBusinessInputEnvelope
    connect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
  }

  export type ProductsUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ProductsCreateWithoutBusinessInput, ProductsUncheckedCreateWithoutBusinessInput> | ProductsCreateWithoutBusinessInput[] | ProductsUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutBusinessInput | ProductsCreateOrConnectWithoutBusinessInput[]
    createMany?: ProductsCreateManyBusinessInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type Pending_PaymentsUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<Pending_PaymentsCreateWithoutBusinessInput, Pending_PaymentsUncheckedCreateWithoutBusinessInput> | Pending_PaymentsCreateWithoutBusinessInput[] | Pending_PaymentsUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: Pending_PaymentsCreateOrConnectWithoutBusinessInput | Pending_PaymentsCreateOrConnectWithoutBusinessInput[]
    createMany?: Pending_PaymentsCreateManyBusinessInputEnvelope
    connect?: Pending_PaymentsWhereUniqueInput | Pending_PaymentsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableEnumPricePlanFieldUpdateOperationsInput = {
    set?: $Enums.PricePlan | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumPaymentPreferenceFieldUpdateOperationsInput = {
    set?: $Enums.PaymentPreference
  }

  export type Affiliate_BusinessUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutBusinessInput, Affiliate_BusinessUncheckedCreateWithoutBusinessInput> | Affiliate_BusinessCreateWithoutBusinessInput[] | Affiliate_BusinessUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutBusinessInput | Affiliate_BusinessCreateOrConnectWithoutBusinessInput[]
    upsert?: Affiliate_BusinessUpsertWithWhereUniqueWithoutBusinessInput | Affiliate_BusinessUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: Affiliate_BusinessCreateManyBusinessInputEnvelope
    set?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    disconnect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    delete?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    update?: Affiliate_BusinessUpdateWithWhereUniqueWithoutBusinessInput | Affiliate_BusinessUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: Affiliate_BusinessUpdateManyWithWhereWithoutBusinessInput | Affiliate_BusinessUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: Affiliate_BusinessScalarWhereInput | Affiliate_BusinessScalarWhereInput[]
  }

  export type MessagesUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<MessagesCreateWithoutBusinessInput, MessagesUncheckedCreateWithoutBusinessInput> | MessagesCreateWithoutBusinessInput[] | MessagesUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutBusinessInput | MessagesCreateOrConnectWithoutBusinessInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutBusinessInput | MessagesUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: MessagesCreateManyBusinessInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutBusinessInput | MessagesUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutBusinessInput | MessagesUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type OrdersUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<OrdersCreateWithoutBusinessInput, OrdersUncheckedCreateWithoutBusinessInput> | OrdersCreateWithoutBusinessInput[] | OrdersUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutBusinessInput | OrdersCreateOrConnectWithoutBusinessInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutBusinessInput | OrdersUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: OrdersCreateManyBusinessInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutBusinessInput | OrdersUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutBusinessInput | OrdersUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type PipelinesUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<PipelinesCreateWithoutBusinessInput, PipelinesUncheckedCreateWithoutBusinessInput> | PipelinesCreateWithoutBusinessInput[] | PipelinesUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: PipelinesCreateOrConnectWithoutBusinessInput | PipelinesCreateOrConnectWithoutBusinessInput[]
    upsert?: PipelinesUpsertWithWhereUniqueWithoutBusinessInput | PipelinesUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: PipelinesCreateManyBusinessInputEnvelope
    set?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    disconnect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    delete?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    connect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    update?: PipelinesUpdateWithWhereUniqueWithoutBusinessInput | PipelinesUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: PipelinesUpdateManyWithWhereWithoutBusinessInput | PipelinesUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: PipelinesScalarWhereInput | PipelinesScalarWhereInput[]
  }

  export type ProductsUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ProductsCreateWithoutBusinessInput, ProductsUncheckedCreateWithoutBusinessInput> | ProductsCreateWithoutBusinessInput[] | ProductsUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutBusinessInput | ProductsCreateOrConnectWithoutBusinessInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutBusinessInput | ProductsUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ProductsCreateManyBusinessInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutBusinessInput | ProductsUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutBusinessInput | ProductsUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type Pending_PaymentsUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<Pending_PaymentsCreateWithoutBusinessInput, Pending_PaymentsUncheckedCreateWithoutBusinessInput> | Pending_PaymentsCreateWithoutBusinessInput[] | Pending_PaymentsUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: Pending_PaymentsCreateOrConnectWithoutBusinessInput | Pending_PaymentsCreateOrConnectWithoutBusinessInput[]
    upsert?: Pending_PaymentsUpsertWithWhereUniqueWithoutBusinessInput | Pending_PaymentsUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: Pending_PaymentsCreateManyBusinessInputEnvelope
    set?: Pending_PaymentsWhereUniqueInput | Pending_PaymentsWhereUniqueInput[]
    disconnect?: Pending_PaymentsWhereUniqueInput | Pending_PaymentsWhereUniqueInput[]
    delete?: Pending_PaymentsWhereUniqueInput | Pending_PaymentsWhereUniqueInput[]
    connect?: Pending_PaymentsWhereUniqueInput | Pending_PaymentsWhereUniqueInput[]
    update?: Pending_PaymentsUpdateWithWhereUniqueWithoutBusinessInput | Pending_PaymentsUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: Pending_PaymentsUpdateManyWithWhereWithoutBusinessInput | Pending_PaymentsUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: Pending_PaymentsScalarWhereInput | Pending_PaymentsScalarWhereInput[]
  }

  export type Affiliate_BusinessUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutBusinessInput, Affiliate_BusinessUncheckedCreateWithoutBusinessInput> | Affiliate_BusinessCreateWithoutBusinessInput[] | Affiliate_BusinessUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutBusinessInput | Affiliate_BusinessCreateOrConnectWithoutBusinessInput[]
    upsert?: Affiliate_BusinessUpsertWithWhereUniqueWithoutBusinessInput | Affiliate_BusinessUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: Affiliate_BusinessCreateManyBusinessInputEnvelope
    set?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    disconnect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    delete?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    update?: Affiliate_BusinessUpdateWithWhereUniqueWithoutBusinessInput | Affiliate_BusinessUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: Affiliate_BusinessUpdateManyWithWhereWithoutBusinessInput | Affiliate_BusinessUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: Affiliate_BusinessScalarWhereInput | Affiliate_BusinessScalarWhereInput[]
  }

  export type MessagesUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<MessagesCreateWithoutBusinessInput, MessagesUncheckedCreateWithoutBusinessInput> | MessagesCreateWithoutBusinessInput[] | MessagesUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutBusinessInput | MessagesCreateOrConnectWithoutBusinessInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutBusinessInput | MessagesUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: MessagesCreateManyBusinessInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutBusinessInput | MessagesUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutBusinessInput | MessagesUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type OrdersUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<OrdersCreateWithoutBusinessInput, OrdersUncheckedCreateWithoutBusinessInput> | OrdersCreateWithoutBusinessInput[] | OrdersUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutBusinessInput | OrdersCreateOrConnectWithoutBusinessInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutBusinessInput | OrdersUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: OrdersCreateManyBusinessInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutBusinessInput | OrdersUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutBusinessInput | OrdersUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type PipelinesUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<PipelinesCreateWithoutBusinessInput, PipelinesUncheckedCreateWithoutBusinessInput> | PipelinesCreateWithoutBusinessInput[] | PipelinesUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: PipelinesCreateOrConnectWithoutBusinessInput | PipelinesCreateOrConnectWithoutBusinessInput[]
    upsert?: PipelinesUpsertWithWhereUniqueWithoutBusinessInput | PipelinesUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: PipelinesCreateManyBusinessInputEnvelope
    set?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    disconnect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    delete?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    connect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    update?: PipelinesUpdateWithWhereUniqueWithoutBusinessInput | PipelinesUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: PipelinesUpdateManyWithWhereWithoutBusinessInput | PipelinesUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: PipelinesScalarWhereInput | PipelinesScalarWhereInput[]
  }

  export type ProductsUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ProductsCreateWithoutBusinessInput, ProductsUncheckedCreateWithoutBusinessInput> | ProductsCreateWithoutBusinessInput[] | ProductsUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutBusinessInput | ProductsCreateOrConnectWithoutBusinessInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutBusinessInput | ProductsUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ProductsCreateManyBusinessInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutBusinessInput | ProductsUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutBusinessInput | ProductsUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type Pending_PaymentsUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<Pending_PaymentsCreateWithoutBusinessInput, Pending_PaymentsUncheckedCreateWithoutBusinessInput> | Pending_PaymentsCreateWithoutBusinessInput[] | Pending_PaymentsUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: Pending_PaymentsCreateOrConnectWithoutBusinessInput | Pending_PaymentsCreateOrConnectWithoutBusinessInput[]
    upsert?: Pending_PaymentsUpsertWithWhereUniqueWithoutBusinessInput | Pending_PaymentsUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: Pending_PaymentsCreateManyBusinessInputEnvelope
    set?: Pending_PaymentsWhereUniqueInput | Pending_PaymentsWhereUniqueInput[]
    disconnect?: Pending_PaymentsWhereUniqueInput | Pending_PaymentsWhereUniqueInput[]
    delete?: Pending_PaymentsWhereUniqueInput | Pending_PaymentsWhereUniqueInput[]
    connect?: Pending_PaymentsWhereUniqueInput | Pending_PaymentsWhereUniqueInput[]
    update?: Pending_PaymentsUpdateWithWhereUniqueWithoutBusinessInput | Pending_PaymentsUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: Pending_PaymentsUpdateManyWithWhereWithoutBusinessInput | Pending_PaymentsUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: Pending_PaymentsScalarWhereInput | Pending_PaymentsScalarWhereInput[]
  }

  export type BusinessCreateNestedOneWithoutMessagesInput = {
    create?: XOR<BusinessCreateWithoutMessagesInput, BusinessUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutMessagesInput
    connect?: BusinessWhereUniqueInput
  }

  export type MessagesCreateNestedOneWithoutRepliesInput = {
    create?: XOR<MessagesCreateWithoutRepliesInput, MessagesUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: MessagesCreateOrConnectWithoutRepliesInput
    connect?: MessagesWhereUniqueInput
  }

  export type MessagesCreateNestedManyWithoutParentInput = {
    create?: XOR<MessagesCreateWithoutParentInput, MessagesUncheckedCreateWithoutParentInput> | MessagesCreateWithoutParentInput[] | MessagesUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutParentInput | MessagesCreateOrConnectWithoutParentInput[]
    createMany?: MessagesCreateManyParentInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type MessagesUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<MessagesCreateWithoutParentInput, MessagesUncheckedCreateWithoutParentInput> | MessagesCreateWithoutParentInput[] | MessagesUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutParentInput | MessagesCreateOrConnectWithoutParentInput[]
    createMany?: MessagesCreateManyParentInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type BusinessUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<BusinessCreateWithoutMessagesInput, BusinessUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutMessagesInput
    upsert?: BusinessUpsertWithoutMessagesInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutMessagesInput, BusinessUpdateWithoutMessagesInput>, BusinessUncheckedUpdateWithoutMessagesInput>
  }

  export type MessagesUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<MessagesCreateWithoutRepliesInput, MessagesUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: MessagesCreateOrConnectWithoutRepliesInput
    upsert?: MessagesUpsertWithoutRepliesInput
    disconnect?: MessagesWhereInput | boolean
    delete?: MessagesWhereInput | boolean
    connect?: MessagesWhereUniqueInput
    update?: XOR<XOR<MessagesUpdateToOneWithWhereWithoutRepliesInput, MessagesUpdateWithoutRepliesInput>, MessagesUncheckedUpdateWithoutRepliesInput>
  }

  export type MessagesUpdateManyWithoutParentNestedInput = {
    create?: XOR<MessagesCreateWithoutParentInput, MessagesUncheckedCreateWithoutParentInput> | MessagesCreateWithoutParentInput[] | MessagesUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutParentInput | MessagesCreateOrConnectWithoutParentInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutParentInput | MessagesUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MessagesCreateManyParentInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutParentInput | MessagesUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutParentInput | MessagesUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type MessagesUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<MessagesCreateWithoutParentInput, MessagesUncheckedCreateWithoutParentInput> | MessagesCreateWithoutParentInput[] | MessagesUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutParentInput | MessagesCreateOrConnectWithoutParentInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutParentInput | MessagesUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MessagesCreateManyParentInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutParentInput | MessagesUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutParentInput | MessagesUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type Affiliate_BusinessCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutAffiliateInput, Affiliate_BusinessUncheckedCreateWithoutAffiliateInput> | Affiliate_BusinessCreateWithoutAffiliateInput[] | Affiliate_BusinessUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutAffiliateInput | Affiliate_BusinessCreateOrConnectWithoutAffiliateInput[]
    createMany?: Affiliate_BusinessCreateManyAffiliateInputEnvelope
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
  }

  export type OrdersCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<OrdersCreateWithoutAffiliateInput, OrdersUncheckedCreateWithoutAffiliateInput> | OrdersCreateWithoutAffiliateInput[] | OrdersUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutAffiliateInput | OrdersCreateOrConnectWithoutAffiliateInput[]
    createMany?: OrdersCreateManyAffiliateInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type Affiliate_Pending_PaymentsCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<Affiliate_Pending_PaymentsCreateWithoutAffiliateInput, Affiliate_Pending_PaymentsUncheckedCreateWithoutAffiliateInput> | Affiliate_Pending_PaymentsCreateWithoutAffiliateInput[] | Affiliate_Pending_PaymentsUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: Affiliate_Pending_PaymentsCreateOrConnectWithoutAffiliateInput | Affiliate_Pending_PaymentsCreateOrConnectWithoutAffiliateInput[]
    createMany?: Affiliate_Pending_PaymentsCreateManyAffiliateInputEnvelope
    connect?: Affiliate_Pending_PaymentsWhereUniqueInput | Affiliate_Pending_PaymentsWhereUniqueInput[]
  }

  export type Affiliate_BusinessUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutAffiliateInput, Affiliate_BusinessUncheckedCreateWithoutAffiliateInput> | Affiliate_BusinessCreateWithoutAffiliateInput[] | Affiliate_BusinessUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutAffiliateInput | Affiliate_BusinessCreateOrConnectWithoutAffiliateInput[]
    createMany?: Affiliate_BusinessCreateManyAffiliateInputEnvelope
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
  }

  export type OrdersUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<OrdersCreateWithoutAffiliateInput, OrdersUncheckedCreateWithoutAffiliateInput> | OrdersCreateWithoutAffiliateInput[] | OrdersUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutAffiliateInput | OrdersCreateOrConnectWithoutAffiliateInput[]
    createMany?: OrdersCreateManyAffiliateInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type Affiliate_Pending_PaymentsUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<Affiliate_Pending_PaymentsCreateWithoutAffiliateInput, Affiliate_Pending_PaymentsUncheckedCreateWithoutAffiliateInput> | Affiliate_Pending_PaymentsCreateWithoutAffiliateInput[] | Affiliate_Pending_PaymentsUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: Affiliate_Pending_PaymentsCreateOrConnectWithoutAffiliateInput | Affiliate_Pending_PaymentsCreateOrConnectWithoutAffiliateInput[]
    createMany?: Affiliate_Pending_PaymentsCreateManyAffiliateInputEnvelope
    connect?: Affiliate_Pending_PaymentsWhereUniqueInput | Affiliate_Pending_PaymentsWhereUniqueInput[]
  }

  export type Affiliate_BusinessUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutAffiliateInput, Affiliate_BusinessUncheckedCreateWithoutAffiliateInput> | Affiliate_BusinessCreateWithoutAffiliateInput[] | Affiliate_BusinessUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutAffiliateInput | Affiliate_BusinessCreateOrConnectWithoutAffiliateInput[]
    upsert?: Affiliate_BusinessUpsertWithWhereUniqueWithoutAffiliateInput | Affiliate_BusinessUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: Affiliate_BusinessCreateManyAffiliateInputEnvelope
    set?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    disconnect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    delete?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    update?: Affiliate_BusinessUpdateWithWhereUniqueWithoutAffiliateInput | Affiliate_BusinessUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: Affiliate_BusinessUpdateManyWithWhereWithoutAffiliateInput | Affiliate_BusinessUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: Affiliate_BusinessScalarWhereInput | Affiliate_BusinessScalarWhereInput[]
  }

  export type OrdersUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<OrdersCreateWithoutAffiliateInput, OrdersUncheckedCreateWithoutAffiliateInput> | OrdersCreateWithoutAffiliateInput[] | OrdersUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutAffiliateInput | OrdersCreateOrConnectWithoutAffiliateInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutAffiliateInput | OrdersUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: OrdersCreateManyAffiliateInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutAffiliateInput | OrdersUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutAffiliateInput | OrdersUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type Affiliate_Pending_PaymentsUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<Affiliate_Pending_PaymentsCreateWithoutAffiliateInput, Affiliate_Pending_PaymentsUncheckedCreateWithoutAffiliateInput> | Affiliate_Pending_PaymentsCreateWithoutAffiliateInput[] | Affiliate_Pending_PaymentsUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: Affiliate_Pending_PaymentsCreateOrConnectWithoutAffiliateInput | Affiliate_Pending_PaymentsCreateOrConnectWithoutAffiliateInput[]
    upsert?: Affiliate_Pending_PaymentsUpsertWithWhereUniqueWithoutAffiliateInput | Affiliate_Pending_PaymentsUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: Affiliate_Pending_PaymentsCreateManyAffiliateInputEnvelope
    set?: Affiliate_Pending_PaymentsWhereUniqueInput | Affiliate_Pending_PaymentsWhereUniqueInput[]
    disconnect?: Affiliate_Pending_PaymentsWhereUniqueInput | Affiliate_Pending_PaymentsWhereUniqueInput[]
    delete?: Affiliate_Pending_PaymentsWhereUniqueInput | Affiliate_Pending_PaymentsWhereUniqueInput[]
    connect?: Affiliate_Pending_PaymentsWhereUniqueInput | Affiliate_Pending_PaymentsWhereUniqueInput[]
    update?: Affiliate_Pending_PaymentsUpdateWithWhereUniqueWithoutAffiliateInput | Affiliate_Pending_PaymentsUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: Affiliate_Pending_PaymentsUpdateManyWithWhereWithoutAffiliateInput | Affiliate_Pending_PaymentsUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: Affiliate_Pending_PaymentsScalarWhereInput | Affiliate_Pending_PaymentsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Affiliate_BusinessUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutAffiliateInput, Affiliate_BusinessUncheckedCreateWithoutAffiliateInput> | Affiliate_BusinessCreateWithoutAffiliateInput[] | Affiliate_BusinessUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutAffiliateInput | Affiliate_BusinessCreateOrConnectWithoutAffiliateInput[]
    upsert?: Affiliate_BusinessUpsertWithWhereUniqueWithoutAffiliateInput | Affiliate_BusinessUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: Affiliate_BusinessCreateManyAffiliateInputEnvelope
    set?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    disconnect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    delete?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    update?: Affiliate_BusinessUpdateWithWhereUniqueWithoutAffiliateInput | Affiliate_BusinessUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: Affiliate_BusinessUpdateManyWithWhereWithoutAffiliateInput | Affiliate_BusinessUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: Affiliate_BusinessScalarWhereInput | Affiliate_BusinessScalarWhereInput[]
  }

  export type OrdersUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<OrdersCreateWithoutAffiliateInput, OrdersUncheckedCreateWithoutAffiliateInput> | OrdersCreateWithoutAffiliateInput[] | OrdersUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutAffiliateInput | OrdersCreateOrConnectWithoutAffiliateInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutAffiliateInput | OrdersUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: OrdersCreateManyAffiliateInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutAffiliateInput | OrdersUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutAffiliateInput | OrdersUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type Affiliate_Pending_PaymentsUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<Affiliate_Pending_PaymentsCreateWithoutAffiliateInput, Affiliate_Pending_PaymentsUncheckedCreateWithoutAffiliateInput> | Affiliate_Pending_PaymentsCreateWithoutAffiliateInput[] | Affiliate_Pending_PaymentsUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: Affiliate_Pending_PaymentsCreateOrConnectWithoutAffiliateInput | Affiliate_Pending_PaymentsCreateOrConnectWithoutAffiliateInput[]
    upsert?: Affiliate_Pending_PaymentsUpsertWithWhereUniqueWithoutAffiliateInput | Affiliate_Pending_PaymentsUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: Affiliate_Pending_PaymentsCreateManyAffiliateInputEnvelope
    set?: Affiliate_Pending_PaymentsWhereUniqueInput | Affiliate_Pending_PaymentsWhereUniqueInput[]
    disconnect?: Affiliate_Pending_PaymentsWhereUniqueInput | Affiliate_Pending_PaymentsWhereUniqueInput[]
    delete?: Affiliate_Pending_PaymentsWhereUniqueInput | Affiliate_Pending_PaymentsWhereUniqueInput[]
    connect?: Affiliate_Pending_PaymentsWhereUniqueInput | Affiliate_Pending_PaymentsWhereUniqueInput[]
    update?: Affiliate_Pending_PaymentsUpdateWithWhereUniqueWithoutAffiliateInput | Affiliate_Pending_PaymentsUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: Affiliate_Pending_PaymentsUpdateManyWithWhereWithoutAffiliateInput | Affiliate_Pending_PaymentsUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: Affiliate_Pending_PaymentsScalarWhereInput | Affiliate_Pending_PaymentsScalarWhereInput[]
  }

  export type ig_scope_identifiersCreateNestedOneWithoutAffiliate_businessInput = {
    create?: XOR<ig_scope_identifiersCreateWithoutAffiliate_businessInput, ig_scope_identifiersUncheckedCreateWithoutAffiliate_businessInput>
    connectOrCreate?: ig_scope_identifiersCreateOrConnectWithoutAffiliate_businessInput
    connect?: ig_scope_identifiersWhereUniqueInput
  }

  export type AffiliatesCreateNestedOneWithoutAffiliate_businessInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_businessInput, AffiliatesUncheckedCreateWithoutAffiliate_businessInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_businessInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutAffiliate_businessInput = {
    create?: XOR<BusinessCreateWithoutAffiliate_businessInput, BusinessUncheckedCreateWithoutAffiliate_businessInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutAffiliate_businessInput
    connect?: BusinessWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutAffiliate_businessInput = {
    create?: XOR<ProductsCreateWithoutAffiliate_businessInput, ProductsUncheckedCreateWithoutAffiliate_businessInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutAffiliate_businessInput
    connect?: ProductsWhereUniqueInput
  }

  export type PipelinesCreateNestedOneWithoutAffiliate_businessInput = {
    create?: XOR<PipelinesCreateWithoutAffiliate_businessInput, PipelinesUncheckedCreateWithoutAffiliate_businessInput>
    connectOrCreate?: PipelinesCreateOrConnectWithoutAffiliate_businessInput
    connect?: PipelinesWhereUniqueInput
  }

  export type ig_scope_identifiersUpdateOneWithoutAffiliate_businessNestedInput = {
    create?: XOR<ig_scope_identifiersCreateWithoutAffiliate_businessInput, ig_scope_identifiersUncheckedCreateWithoutAffiliate_businessInput>
    connectOrCreate?: ig_scope_identifiersCreateOrConnectWithoutAffiliate_businessInput
    upsert?: ig_scope_identifiersUpsertWithoutAffiliate_businessInput
    disconnect?: ig_scope_identifiersWhereInput | boolean
    delete?: ig_scope_identifiersWhereInput | boolean
    connect?: ig_scope_identifiersWhereUniqueInput
    update?: XOR<XOR<ig_scope_identifiersUpdateToOneWithWhereWithoutAffiliate_businessInput, ig_scope_identifiersUpdateWithoutAffiliate_businessInput>, ig_scope_identifiersUncheckedUpdateWithoutAffiliate_businessInput>
  }

  export type AffiliatesUpdateOneRequiredWithoutAffiliate_businessNestedInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_businessInput, AffiliatesUncheckedCreateWithoutAffiliate_businessInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_businessInput
    upsert?: AffiliatesUpsertWithoutAffiliate_businessInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutAffiliate_businessInput, AffiliatesUpdateWithoutAffiliate_businessInput>, AffiliatesUncheckedUpdateWithoutAffiliate_businessInput>
  }

  export type BusinessUpdateOneRequiredWithoutAffiliate_businessNestedInput = {
    create?: XOR<BusinessCreateWithoutAffiliate_businessInput, BusinessUncheckedCreateWithoutAffiliate_businessInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutAffiliate_businessInput
    upsert?: BusinessUpsertWithoutAffiliate_businessInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutAffiliate_businessInput, BusinessUpdateWithoutAffiliate_businessInput>, BusinessUncheckedUpdateWithoutAffiliate_businessInput>
  }

  export type ProductsUpdateOneWithoutAffiliate_businessNestedInput = {
    create?: XOR<ProductsCreateWithoutAffiliate_businessInput, ProductsUncheckedCreateWithoutAffiliate_businessInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutAffiliate_businessInput
    upsert?: ProductsUpsertWithoutAffiliate_businessInput
    disconnect?: ProductsWhereInput | boolean
    delete?: ProductsWhereInput | boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutAffiliate_businessInput, ProductsUpdateWithoutAffiliate_businessInput>, ProductsUncheckedUpdateWithoutAffiliate_businessInput>
  }

  export type PipelinesUpdateOneWithoutAffiliate_businessNestedInput = {
    create?: XOR<PipelinesCreateWithoutAffiliate_businessInput, PipelinesUncheckedCreateWithoutAffiliate_businessInput>
    connectOrCreate?: PipelinesCreateOrConnectWithoutAffiliate_businessInput
    upsert?: PipelinesUpsertWithoutAffiliate_businessInput
    disconnect?: PipelinesWhereInput | boolean
    delete?: PipelinesWhereInput | boolean
    connect?: PipelinesWhereUniqueInput
    update?: XOR<XOR<PipelinesUpdateToOneWithWhereWithoutAffiliate_businessInput, PipelinesUpdateWithoutAffiliate_businessInput>, PipelinesUncheckedUpdateWithoutAffiliate_businessInput>
  }

  export type AffiliatesCreateNestedOneWithoutOrdersInput = {
    create?: XOR<AffiliatesCreateWithoutOrdersInput, AffiliatesUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutOrdersInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutOrdersInput = {
    create?: XOR<BusinessCreateWithoutOrdersInput, BusinessUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutOrdersInput
    connect?: BusinessWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ProductsCreateWithoutOrdersInput, ProductsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutOrdersInput
    connect?: ProductsWhereUniqueInput
  }

  export type AffiliatesUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<AffiliatesCreateWithoutOrdersInput, AffiliatesUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutOrdersInput
    upsert?: AffiliatesUpsertWithoutOrdersInput
    disconnect?: AffiliatesWhereInput | boolean
    delete?: AffiliatesWhereInput | boolean
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutOrdersInput, AffiliatesUpdateWithoutOrdersInput>, AffiliatesUncheckedUpdateWithoutOrdersInput>
  }

  export type BusinessUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<BusinessCreateWithoutOrdersInput, BusinessUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutOrdersInput
    upsert?: BusinessUpsertWithoutOrdersInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutOrdersInput, BusinessUpdateWithoutOrdersInput>, BusinessUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductsUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<ProductsCreateWithoutOrdersInput, ProductsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutOrdersInput
    upsert?: ProductsUpsertWithoutOrdersInput
    disconnect?: ProductsWhereInput | boolean
    delete?: ProductsWhereInput | boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutOrdersInput, ProductsUpdateWithoutOrdersInput>, ProductsUncheckedUpdateWithoutOrdersInput>
  }

  export type Affiliate_BusinessCreateNestedManyWithoutProductsInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutProductsInput, Affiliate_BusinessUncheckedCreateWithoutProductsInput> | Affiliate_BusinessCreateWithoutProductsInput[] | Affiliate_BusinessUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutProductsInput | Affiliate_BusinessCreateOrConnectWithoutProductsInput[]
    createMany?: Affiliate_BusinessCreateManyProductsInputEnvelope
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
  }

  export type OrdersCreateNestedManyWithoutProductsInput = {
    create?: XOR<OrdersCreateWithoutProductsInput, OrdersUncheckedCreateWithoutProductsInput> | OrdersCreateWithoutProductsInput[] | OrdersUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutProductsInput | OrdersCreateOrConnectWithoutProductsInput[]
    createMany?: OrdersCreateManyProductsInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type PipelinesCreateNestedManyWithoutProductsInput = {
    create?: XOR<PipelinesCreateWithoutProductsInput, PipelinesUncheckedCreateWithoutProductsInput> | PipelinesCreateWithoutProductsInput[] | PipelinesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PipelinesCreateOrConnectWithoutProductsInput | PipelinesCreateOrConnectWithoutProductsInput[]
    createMany?: PipelinesCreateManyProductsInputEnvelope
    connect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
  }

  export type BusinessCreateNestedOneWithoutProductsInput = {
    create?: XOR<BusinessCreateWithoutProductsInput, BusinessUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutProductsInput
    connect?: BusinessWhereUniqueInput
  }

  export type Affiliate_BusinessUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutProductsInput, Affiliate_BusinessUncheckedCreateWithoutProductsInput> | Affiliate_BusinessCreateWithoutProductsInput[] | Affiliate_BusinessUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutProductsInput | Affiliate_BusinessCreateOrConnectWithoutProductsInput[]
    createMany?: Affiliate_BusinessCreateManyProductsInputEnvelope
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
  }

  export type OrdersUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<OrdersCreateWithoutProductsInput, OrdersUncheckedCreateWithoutProductsInput> | OrdersCreateWithoutProductsInput[] | OrdersUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutProductsInput | OrdersCreateOrConnectWithoutProductsInput[]
    createMany?: OrdersCreateManyProductsInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type PipelinesUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<PipelinesCreateWithoutProductsInput, PipelinesUncheckedCreateWithoutProductsInput> | PipelinesCreateWithoutProductsInput[] | PipelinesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PipelinesCreateOrConnectWithoutProductsInput | PipelinesCreateOrConnectWithoutProductsInput[]
    createMany?: PipelinesCreateManyProductsInputEnvelope
    connect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableEnumPriceTypeFieldUpdateOperationsInput = {
    set?: $Enums.PriceType | null
  }

  export type Affiliate_BusinessUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutProductsInput, Affiliate_BusinessUncheckedCreateWithoutProductsInput> | Affiliate_BusinessCreateWithoutProductsInput[] | Affiliate_BusinessUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutProductsInput | Affiliate_BusinessCreateOrConnectWithoutProductsInput[]
    upsert?: Affiliate_BusinessUpsertWithWhereUniqueWithoutProductsInput | Affiliate_BusinessUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: Affiliate_BusinessCreateManyProductsInputEnvelope
    set?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    disconnect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    delete?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    update?: Affiliate_BusinessUpdateWithWhereUniqueWithoutProductsInput | Affiliate_BusinessUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: Affiliate_BusinessUpdateManyWithWhereWithoutProductsInput | Affiliate_BusinessUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: Affiliate_BusinessScalarWhereInput | Affiliate_BusinessScalarWhereInput[]
  }

  export type OrdersUpdateManyWithoutProductsNestedInput = {
    create?: XOR<OrdersCreateWithoutProductsInput, OrdersUncheckedCreateWithoutProductsInput> | OrdersCreateWithoutProductsInput[] | OrdersUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutProductsInput | OrdersCreateOrConnectWithoutProductsInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutProductsInput | OrdersUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: OrdersCreateManyProductsInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutProductsInput | OrdersUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutProductsInput | OrdersUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type PipelinesUpdateManyWithoutProductsNestedInput = {
    create?: XOR<PipelinesCreateWithoutProductsInput, PipelinesUncheckedCreateWithoutProductsInput> | PipelinesCreateWithoutProductsInput[] | PipelinesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PipelinesCreateOrConnectWithoutProductsInput | PipelinesCreateOrConnectWithoutProductsInput[]
    upsert?: PipelinesUpsertWithWhereUniqueWithoutProductsInput | PipelinesUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: PipelinesCreateManyProductsInputEnvelope
    set?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    disconnect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    delete?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    connect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    update?: PipelinesUpdateWithWhereUniqueWithoutProductsInput | PipelinesUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: PipelinesUpdateManyWithWhereWithoutProductsInput | PipelinesUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: PipelinesScalarWhereInput | PipelinesScalarWhereInput[]
  }

  export type BusinessUpdateOneWithoutProductsNestedInput = {
    create?: XOR<BusinessCreateWithoutProductsInput, BusinessUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutProductsInput
    upsert?: BusinessUpsertWithoutProductsInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutProductsInput, BusinessUpdateWithoutProductsInput>, BusinessUncheckedUpdateWithoutProductsInput>
  }

  export type Affiliate_BusinessUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutProductsInput, Affiliate_BusinessUncheckedCreateWithoutProductsInput> | Affiliate_BusinessCreateWithoutProductsInput[] | Affiliate_BusinessUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutProductsInput | Affiliate_BusinessCreateOrConnectWithoutProductsInput[]
    upsert?: Affiliate_BusinessUpsertWithWhereUniqueWithoutProductsInput | Affiliate_BusinessUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: Affiliate_BusinessCreateManyProductsInputEnvelope
    set?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    disconnect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    delete?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    update?: Affiliate_BusinessUpdateWithWhereUniqueWithoutProductsInput | Affiliate_BusinessUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: Affiliate_BusinessUpdateManyWithWhereWithoutProductsInput | Affiliate_BusinessUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: Affiliate_BusinessScalarWhereInput | Affiliate_BusinessScalarWhereInput[]
  }

  export type OrdersUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<OrdersCreateWithoutProductsInput, OrdersUncheckedCreateWithoutProductsInput> | OrdersCreateWithoutProductsInput[] | OrdersUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutProductsInput | OrdersCreateOrConnectWithoutProductsInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutProductsInput | OrdersUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: OrdersCreateManyProductsInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutProductsInput | OrdersUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutProductsInput | OrdersUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type PipelinesUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<PipelinesCreateWithoutProductsInput, PipelinesUncheckedCreateWithoutProductsInput> | PipelinesCreateWithoutProductsInput[] | PipelinesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PipelinesCreateOrConnectWithoutProductsInput | PipelinesCreateOrConnectWithoutProductsInput[]
    upsert?: PipelinesUpsertWithWhereUniqueWithoutProductsInput | PipelinesUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: PipelinesCreateManyProductsInputEnvelope
    set?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    disconnect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    delete?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    connect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    update?: PipelinesUpdateWithWhereUniqueWithoutProductsInput | PipelinesUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: PipelinesUpdateManyWithWhereWithoutProductsInput | PipelinesUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: PipelinesScalarWhereInput | PipelinesScalarWhereInput[]
  }

  export type BusinessCreateNestedOneWithoutPipelinesInput = {
    create?: XOR<BusinessCreateWithoutPipelinesInput, BusinessUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutPipelinesInput
    connect?: BusinessWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutPipelinesInput = {
    create?: XOR<ProductsCreateWithoutPipelinesInput, ProductsUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutPipelinesInput
    connect?: ProductsWhereUniqueInput
  }

  export type Affiliate_BusinessCreateNestedManyWithoutPipelinesInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutPipelinesInput, Affiliate_BusinessUncheckedCreateWithoutPipelinesInput> | Affiliate_BusinessCreateWithoutPipelinesInput[] | Affiliate_BusinessUncheckedCreateWithoutPipelinesInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutPipelinesInput | Affiliate_BusinessCreateOrConnectWithoutPipelinesInput[]
    createMany?: Affiliate_BusinessCreateManyPipelinesInputEnvelope
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutPipelineInput = {
    create?: XOR<ChatMessageCreateWithoutPipelineInput, ChatMessageUncheckedCreateWithoutPipelineInput> | ChatMessageCreateWithoutPipelineInput[] | ChatMessageUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutPipelineInput | ChatMessageCreateOrConnectWithoutPipelineInput[]
    createMany?: ChatMessageCreateManyPipelineInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type Affiliate_BusinessUncheckedCreateNestedManyWithoutPipelinesInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutPipelinesInput, Affiliate_BusinessUncheckedCreateWithoutPipelinesInput> | Affiliate_BusinessCreateWithoutPipelinesInput[] | Affiliate_BusinessUncheckedCreateWithoutPipelinesInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutPipelinesInput | Affiliate_BusinessCreateOrConnectWithoutPipelinesInput[]
    createMany?: Affiliate_BusinessCreateManyPipelinesInputEnvelope
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutPipelineInput = {
    create?: XOR<ChatMessageCreateWithoutPipelineInput, ChatMessageUncheckedCreateWithoutPipelineInput> | ChatMessageCreateWithoutPipelineInput[] | ChatMessageUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutPipelineInput | ChatMessageCreateOrConnectWithoutPipelineInput[]
    createMany?: ChatMessageCreateManyPipelineInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type NullableEnumRunModeFieldUpdateOperationsInput = {
    set?: $Enums.RunMode | null
  }

  export type BusinessUpdateOneWithoutPipelinesNestedInput = {
    create?: XOR<BusinessCreateWithoutPipelinesInput, BusinessUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutPipelinesInput
    upsert?: BusinessUpsertWithoutPipelinesInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutPipelinesInput, BusinessUpdateWithoutPipelinesInput>, BusinessUncheckedUpdateWithoutPipelinesInput>
  }

  export type ProductsUpdateOneWithoutPipelinesNestedInput = {
    create?: XOR<ProductsCreateWithoutPipelinesInput, ProductsUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutPipelinesInput
    upsert?: ProductsUpsertWithoutPipelinesInput
    disconnect?: ProductsWhereInput | boolean
    delete?: ProductsWhereInput | boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutPipelinesInput, ProductsUpdateWithoutPipelinesInput>, ProductsUncheckedUpdateWithoutPipelinesInput>
  }

  export type Affiliate_BusinessUpdateManyWithoutPipelinesNestedInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutPipelinesInput, Affiliate_BusinessUncheckedCreateWithoutPipelinesInput> | Affiliate_BusinessCreateWithoutPipelinesInput[] | Affiliate_BusinessUncheckedCreateWithoutPipelinesInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutPipelinesInput | Affiliate_BusinessCreateOrConnectWithoutPipelinesInput[]
    upsert?: Affiliate_BusinessUpsertWithWhereUniqueWithoutPipelinesInput | Affiliate_BusinessUpsertWithWhereUniqueWithoutPipelinesInput[]
    createMany?: Affiliate_BusinessCreateManyPipelinesInputEnvelope
    set?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    disconnect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    delete?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    update?: Affiliate_BusinessUpdateWithWhereUniqueWithoutPipelinesInput | Affiliate_BusinessUpdateWithWhereUniqueWithoutPipelinesInput[]
    updateMany?: Affiliate_BusinessUpdateManyWithWhereWithoutPipelinesInput | Affiliate_BusinessUpdateManyWithWhereWithoutPipelinesInput[]
    deleteMany?: Affiliate_BusinessScalarWhereInput | Affiliate_BusinessScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<ChatMessageCreateWithoutPipelineInput, ChatMessageUncheckedCreateWithoutPipelineInput> | ChatMessageCreateWithoutPipelineInput[] | ChatMessageUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutPipelineInput | ChatMessageCreateOrConnectWithoutPipelineInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutPipelineInput | ChatMessageUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: ChatMessageCreateManyPipelineInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutPipelineInput | ChatMessageUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutPipelineInput | ChatMessageUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type Affiliate_BusinessUncheckedUpdateManyWithoutPipelinesNestedInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutPipelinesInput, Affiliate_BusinessUncheckedCreateWithoutPipelinesInput> | Affiliate_BusinessCreateWithoutPipelinesInput[] | Affiliate_BusinessUncheckedCreateWithoutPipelinesInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutPipelinesInput | Affiliate_BusinessCreateOrConnectWithoutPipelinesInput[]
    upsert?: Affiliate_BusinessUpsertWithWhereUniqueWithoutPipelinesInput | Affiliate_BusinessUpsertWithWhereUniqueWithoutPipelinesInput[]
    createMany?: Affiliate_BusinessCreateManyPipelinesInputEnvelope
    set?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    disconnect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    delete?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    update?: Affiliate_BusinessUpdateWithWhereUniqueWithoutPipelinesInput | Affiliate_BusinessUpdateWithWhereUniqueWithoutPipelinesInput[]
    updateMany?: Affiliate_BusinessUpdateManyWithWhereWithoutPipelinesInput | Affiliate_BusinessUpdateManyWithWhereWithoutPipelinesInput[]
    deleteMany?: Affiliate_BusinessScalarWhereInput | Affiliate_BusinessScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<ChatMessageCreateWithoutPipelineInput, ChatMessageUncheckedCreateWithoutPipelineInput> | ChatMessageCreateWithoutPipelineInput[] | ChatMessageUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutPipelineInput | ChatMessageCreateOrConnectWithoutPipelineInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutPipelineInput | ChatMessageUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: ChatMessageCreateManyPipelineInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutPipelineInput | ChatMessageUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutPipelineInput | ChatMessageUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type PipelinesCreateNestedOneWithoutChatMessageInput = {
    create?: XOR<PipelinesCreateWithoutChatMessageInput, PipelinesUncheckedCreateWithoutChatMessageInput>
    connectOrCreate?: PipelinesCreateOrConnectWithoutChatMessageInput
    connect?: PipelinesWhereUniqueInput
  }

  export type PipelinesUpdateOneRequiredWithoutChatMessageNestedInput = {
    create?: XOR<PipelinesCreateWithoutChatMessageInput, PipelinesUncheckedCreateWithoutChatMessageInput>
    connectOrCreate?: PipelinesCreateOrConnectWithoutChatMessageInput
    upsert?: PipelinesUpsertWithoutChatMessageInput
    connect?: PipelinesWhereUniqueInput
    update?: XOR<XOR<PipelinesUpdateToOneWithWhereWithoutChatMessageInput, PipelinesUpdateWithoutChatMessageInput>, PipelinesUncheckedUpdateWithoutChatMessageInput>
  }

  export type BusinessCreateNestedOneWithoutPending_paymentsInput = {
    create?: XOR<BusinessCreateWithoutPending_paymentsInput, BusinessUncheckedCreateWithoutPending_paymentsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutPending_paymentsInput
    connect?: BusinessWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BusinessUpdateOneRequiredWithoutPending_paymentsNestedInput = {
    create?: XOR<BusinessCreateWithoutPending_paymentsInput, BusinessUncheckedCreateWithoutPending_paymentsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutPending_paymentsInput
    upsert?: BusinessUpsertWithoutPending_paymentsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutPending_paymentsInput, BusinessUpdateWithoutPending_paymentsInput>, BusinessUncheckedUpdateWithoutPending_paymentsInput>
  }

  export type AffiliatesCreateNestedOneWithoutAffiliate_pending_paymentsInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_pending_paymentsInput, AffiliatesUncheckedCreateWithoutAffiliate_pending_paymentsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_pending_paymentsInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type AffiliatesUpdateOneRequiredWithoutAffiliate_pending_paymentsNestedInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_pending_paymentsInput, AffiliatesUncheckedCreateWithoutAffiliate_pending_paymentsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_pending_paymentsInput
    upsert?: AffiliatesUpsertWithoutAffiliate_pending_paymentsInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutAffiliate_pending_paymentsInput, AffiliatesUpdateWithoutAffiliate_pending_paymentsInput>, AffiliatesUncheckedUpdateWithoutAffiliate_pending_paymentsInput>
  }

  export type resourcesCreateNestedOneWithoutEmbeddingsInput = {
    create?: XOR<resourcesCreateWithoutEmbeddingsInput, resourcesUncheckedCreateWithoutEmbeddingsInput>
    connectOrCreate?: resourcesCreateOrConnectWithoutEmbeddingsInput
    connect?: resourcesWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type resourcesUpdateOneWithoutEmbeddingsNestedInput = {
    create?: XOR<resourcesCreateWithoutEmbeddingsInput, resourcesUncheckedCreateWithoutEmbeddingsInput>
    connectOrCreate?: resourcesCreateOrConnectWithoutEmbeddingsInput
    upsert?: resourcesUpsertWithoutEmbeddingsInput
    disconnect?: resourcesWhereInput | boolean
    delete?: resourcesWhereInput | boolean
    connect?: resourcesWhereUniqueInput
    update?: XOR<XOR<resourcesUpdateToOneWithWhereWithoutEmbeddingsInput, resourcesUpdateWithoutEmbeddingsInput>, resourcesUncheckedUpdateWithoutEmbeddingsInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type embeddingsCreateNestedManyWithoutResourcesInput = {
    create?: XOR<embeddingsCreateWithoutResourcesInput, embeddingsUncheckedCreateWithoutResourcesInput> | embeddingsCreateWithoutResourcesInput[] | embeddingsUncheckedCreateWithoutResourcesInput[]
    connectOrCreate?: embeddingsCreateOrConnectWithoutResourcesInput | embeddingsCreateOrConnectWithoutResourcesInput[]
    createMany?: embeddingsCreateManyResourcesInputEnvelope
    connect?: embeddingsWhereUniqueInput | embeddingsWhereUniqueInput[]
  }

  export type embeddingsUncheckedCreateNestedManyWithoutResourcesInput = {
    create?: XOR<embeddingsCreateWithoutResourcesInput, embeddingsUncheckedCreateWithoutResourcesInput> | embeddingsCreateWithoutResourcesInput[] | embeddingsUncheckedCreateWithoutResourcesInput[]
    connectOrCreate?: embeddingsCreateOrConnectWithoutResourcesInput | embeddingsCreateOrConnectWithoutResourcesInput[]
    createMany?: embeddingsCreateManyResourcesInputEnvelope
    connect?: embeddingsWhereUniqueInput | embeddingsWhereUniqueInput[]
  }

  export type embeddingsUpdateManyWithoutResourcesNestedInput = {
    create?: XOR<embeddingsCreateWithoutResourcesInput, embeddingsUncheckedCreateWithoutResourcesInput> | embeddingsCreateWithoutResourcesInput[] | embeddingsUncheckedCreateWithoutResourcesInput[]
    connectOrCreate?: embeddingsCreateOrConnectWithoutResourcesInput | embeddingsCreateOrConnectWithoutResourcesInput[]
    upsert?: embeddingsUpsertWithWhereUniqueWithoutResourcesInput | embeddingsUpsertWithWhereUniqueWithoutResourcesInput[]
    createMany?: embeddingsCreateManyResourcesInputEnvelope
    set?: embeddingsWhereUniqueInput | embeddingsWhereUniqueInput[]
    disconnect?: embeddingsWhereUniqueInput | embeddingsWhereUniqueInput[]
    delete?: embeddingsWhereUniqueInput | embeddingsWhereUniqueInput[]
    connect?: embeddingsWhereUniqueInput | embeddingsWhereUniqueInput[]
    update?: embeddingsUpdateWithWhereUniqueWithoutResourcesInput | embeddingsUpdateWithWhereUniqueWithoutResourcesInput[]
    updateMany?: embeddingsUpdateManyWithWhereWithoutResourcesInput | embeddingsUpdateManyWithWhereWithoutResourcesInput[]
    deleteMany?: embeddingsScalarWhereInput | embeddingsScalarWhereInput[]
  }

  export type embeddingsUncheckedUpdateManyWithoutResourcesNestedInput = {
    create?: XOR<embeddingsCreateWithoutResourcesInput, embeddingsUncheckedCreateWithoutResourcesInput> | embeddingsCreateWithoutResourcesInput[] | embeddingsUncheckedCreateWithoutResourcesInput[]
    connectOrCreate?: embeddingsCreateOrConnectWithoutResourcesInput | embeddingsCreateOrConnectWithoutResourcesInput[]
    upsert?: embeddingsUpsertWithWhereUniqueWithoutResourcesInput | embeddingsUpsertWithWhereUniqueWithoutResourcesInput[]
    createMany?: embeddingsCreateManyResourcesInputEnvelope
    set?: embeddingsWhereUniqueInput | embeddingsWhereUniqueInput[]
    disconnect?: embeddingsWhereUniqueInput | embeddingsWhereUniqueInput[]
    delete?: embeddingsWhereUniqueInput | embeddingsWhereUniqueInput[]
    connect?: embeddingsWhereUniqueInput | embeddingsWhereUniqueInput[]
    update?: embeddingsUpdateWithWhereUniqueWithoutResourcesInput | embeddingsUpdateWithWhereUniqueWithoutResourcesInput[]
    updateMany?: embeddingsUpdateManyWithWhereWithoutResourcesInput | embeddingsUpdateManyWithWhereWithoutResourcesInput[]
    deleteMany?: embeddingsScalarWhereInput | embeddingsScalarWhereInput[]
  }

  export type Affiliate_BusinessCreateNestedManyWithoutIg_scope_identifierInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutIg_scope_identifierInput, Affiliate_BusinessUncheckedCreateWithoutIg_scope_identifierInput> | Affiliate_BusinessCreateWithoutIg_scope_identifierInput[] | Affiliate_BusinessUncheckedCreateWithoutIg_scope_identifierInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutIg_scope_identifierInput | Affiliate_BusinessCreateOrConnectWithoutIg_scope_identifierInput[]
    createMany?: Affiliate_BusinessCreateManyIg_scope_identifierInputEnvelope
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
  }

  export type Affiliate_BusinessUncheckedCreateNestedManyWithoutIg_scope_identifierInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutIg_scope_identifierInput, Affiliate_BusinessUncheckedCreateWithoutIg_scope_identifierInput> | Affiliate_BusinessCreateWithoutIg_scope_identifierInput[] | Affiliate_BusinessUncheckedCreateWithoutIg_scope_identifierInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutIg_scope_identifierInput | Affiliate_BusinessCreateOrConnectWithoutIg_scope_identifierInput[]
    createMany?: Affiliate_BusinessCreateManyIg_scope_identifierInputEnvelope
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
  }

  export type Affiliate_BusinessUpdateManyWithoutIg_scope_identifierNestedInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutIg_scope_identifierInput, Affiliate_BusinessUncheckedCreateWithoutIg_scope_identifierInput> | Affiliate_BusinessCreateWithoutIg_scope_identifierInput[] | Affiliate_BusinessUncheckedCreateWithoutIg_scope_identifierInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutIg_scope_identifierInput | Affiliate_BusinessCreateOrConnectWithoutIg_scope_identifierInput[]
    upsert?: Affiliate_BusinessUpsertWithWhereUniqueWithoutIg_scope_identifierInput | Affiliate_BusinessUpsertWithWhereUniqueWithoutIg_scope_identifierInput[]
    createMany?: Affiliate_BusinessCreateManyIg_scope_identifierInputEnvelope
    set?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    disconnect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    delete?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    update?: Affiliate_BusinessUpdateWithWhereUniqueWithoutIg_scope_identifierInput | Affiliate_BusinessUpdateWithWhereUniqueWithoutIg_scope_identifierInput[]
    updateMany?: Affiliate_BusinessUpdateManyWithWhereWithoutIg_scope_identifierInput | Affiliate_BusinessUpdateManyWithWhereWithoutIg_scope_identifierInput[]
    deleteMany?: Affiliate_BusinessScalarWhereInput | Affiliate_BusinessScalarWhereInput[]
  }

  export type Affiliate_BusinessUncheckedUpdateManyWithoutIg_scope_identifierNestedInput = {
    create?: XOR<Affiliate_BusinessCreateWithoutIg_scope_identifierInput, Affiliate_BusinessUncheckedCreateWithoutIg_scope_identifierInput> | Affiliate_BusinessCreateWithoutIg_scope_identifierInput[] | Affiliate_BusinessUncheckedCreateWithoutIg_scope_identifierInput[]
    connectOrCreate?: Affiliate_BusinessCreateOrConnectWithoutIg_scope_identifierInput | Affiliate_BusinessCreateOrConnectWithoutIg_scope_identifierInput[]
    upsert?: Affiliate_BusinessUpsertWithWhereUniqueWithoutIg_scope_identifierInput | Affiliate_BusinessUpsertWithWhereUniqueWithoutIg_scope_identifierInput[]
    createMany?: Affiliate_BusinessCreateManyIg_scope_identifierInputEnvelope
    set?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    disconnect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    delete?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    connect?: Affiliate_BusinessWhereUniqueInput | Affiliate_BusinessWhereUniqueInput[]
    update?: Affiliate_BusinessUpdateWithWhereUniqueWithoutIg_scope_identifierInput | Affiliate_BusinessUpdateWithWhereUniqueWithoutIg_scope_identifierInput[]
    updateMany?: Affiliate_BusinessUpdateManyWithWhereWithoutIg_scope_identifierInput | Affiliate_BusinessUpdateManyWithWhereWithoutIg_scope_identifierInput[]
    deleteMany?: Affiliate_BusinessScalarWhereInput | Affiliate_BusinessScalarWhereInput[]
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumPricePlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PricePlan | EnumPricePlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.PricePlan[] | ListEnumPricePlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PricePlan[] | ListEnumPricePlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPricePlanNullableFilter<$PrismaModel> | $Enums.PricePlan | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPaymentPreferenceFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentPreference | EnumPaymentPreferenceFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentPreference[] | ListEnumPaymentPreferenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentPreference[] | ListEnumPaymentPreferenceFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentPreferenceFilter<$PrismaModel> | $Enums.PaymentPreference
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPricePlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricePlan | EnumPricePlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.PricePlan[] | ListEnumPricePlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PricePlan[] | ListEnumPricePlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPricePlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.PricePlan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPricePlanNullableFilter<$PrismaModel>
    _max?: NestedEnumPricePlanNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentPreferenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentPreference | EnumPaymentPreferenceFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentPreference[] | ListEnumPaymentPreferenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentPreference[] | ListEnumPaymentPreferenceFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentPreferenceWithAggregatesFilter<$PrismaModel> | $Enums.PaymentPreference
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentPreferenceFilter<$PrismaModel>
    _max?: NestedEnumPaymentPreferenceFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumPriceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriceTypeNullableFilter<$PrismaModel> | $Enums.PriceType | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumPriceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PriceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPriceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPriceTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRunModeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RunMode | EnumRunModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RunMode[] | ListEnumRunModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RunMode[] | ListEnumRunModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRunModeNullableFilter<$PrismaModel> | $Enums.RunMode | null
  }

  export type NestedEnumRunModeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RunMode | EnumRunModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RunMode[] | ListEnumRunModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RunMode[] | ListEnumRunModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRunModeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RunMode | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRunModeNullableFilter<$PrismaModel>
    _max?: NestedEnumRunModeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type Affiliate_BusinessCreateWithoutBusinessInput = {
    id?: string
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    ig_scope_identifier?: ig_scope_identifiersCreateNestedOneWithoutAffiliate_businessInput
    affiliate: AffiliatesCreateNestedOneWithoutAffiliate_businessInput
    products?: ProductsCreateNestedOneWithoutAffiliate_businessInput
    pipelines?: PipelinesCreateNestedOneWithoutAffiliate_businessInput
  }

  export type Affiliate_BusinessUncheckedCreateWithoutBusinessInput = {
    id?: string
    affiliate_id: number
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    product_id?: number | null
    pipeline_id?: number | null
    instagram_scope_identifier?: string | null
  }

  export type Affiliate_BusinessCreateOrConnectWithoutBusinessInput = {
    where: Affiliate_BusinessWhereUniqueInput
    create: XOR<Affiliate_BusinessCreateWithoutBusinessInput, Affiliate_BusinessUncheckedCreateWithoutBusinessInput>
  }

  export type Affiliate_BusinessCreateManyBusinessInputEnvelope = {
    data: Affiliate_BusinessCreateManyBusinessInput | Affiliate_BusinessCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type MessagesCreateWithoutBusinessInput = {
    id?: string
    message: string
    type: string
    sent_at?: Date | string
    message_id?: string | null
    email?: string | null
    name?: string | null
    subject: string
    channel_id?: string | null
    video_id?: string | null
    parent?: MessagesCreateNestedOneWithoutRepliesInput
    replies?: MessagesCreateNestedManyWithoutParentInput
  }

  export type MessagesUncheckedCreateWithoutBusinessInput = {
    id?: string
    message: string
    type: string
    sent_at?: Date | string
    message_id?: string | null
    email?: string | null
    name?: string | null
    subject: string
    parent_id?: string | null
    channel_id?: string | null
    video_id?: string | null
    replies?: MessagesUncheckedCreateNestedManyWithoutParentInput
  }

  export type MessagesCreateOrConnectWithoutBusinessInput = {
    where: MessagesWhereUniqueInput
    create: XOR<MessagesCreateWithoutBusinessInput, MessagesUncheckedCreateWithoutBusinessInput>
  }

  export type MessagesCreateManyBusinessInputEnvelope = {
    data: MessagesCreateManyBusinessInput | MessagesCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type OrdersCreateWithoutBusinessInput = {
    id?: string
    customer_name?: string | null
    customer_email: string
    customer_address?: string | null
    invoice_url?: string | null
    order_quantity?: number | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    affiliate?: AffiliatesCreateNestedOneWithoutOrdersInput
    products?: ProductsCreateNestedOneWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutBusinessInput = {
    id?: string
    customer_name?: string | null
    customer_email: string
    customer_address?: string | null
    invoice_url?: string | null
    order_quantity?: number | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_id?: number | null
    product_id?: number | null
  }

  export type OrdersCreateOrConnectWithoutBusinessInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutBusinessInput, OrdersUncheckedCreateWithoutBusinessInput>
  }

  export type OrdersCreateManyBusinessInputEnvelope = {
    data: OrdersCreateManyBusinessInput | OrdersCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type PipelinesCreateWithoutBusinessInput = {
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
    products?: ProductsCreateNestedOneWithoutPipelinesInput
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutPipelinesInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutPipelineInput
  }

  export type PipelinesUncheckedCreateWithoutBusinessInput = {
    id?: number
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    product_id?: number | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutPipelinesInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelinesCreateOrConnectWithoutBusinessInput = {
    where: PipelinesWhereUniqueInput
    create: XOR<PipelinesCreateWithoutBusinessInput, PipelinesUncheckedCreateWithoutBusinessInput>
  }

  export type PipelinesCreateManyBusinessInputEnvelope = {
    data: PipelinesCreateManyBusinessInput | PipelinesCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type ProductsCreateWithoutBusinessInput = {
    name: string
    description: string
    html_description?: string | null
    image_url?: string | null
    price: number
    price_currency?: string | null
    is_shippable?: boolean | null
    price_type?: $Enums.PriceType | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutProductsInput
    orders?: OrdersCreateNestedManyWithoutProductsInput
    pipelines?: PipelinesCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutBusinessInput = {
    name: string
    description: string
    html_description?: string | null
    image_url?: string | null
    price: number
    price_currency?: string | null
    is_shippable?: boolean | null
    price_type?: $Enums.PriceType | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: number
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrdersUncheckedCreateNestedManyWithoutProductsInput
    pipelines?: PipelinesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutBusinessInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutBusinessInput, ProductsUncheckedCreateWithoutBusinessInput>
  }

  export type ProductsCreateManyBusinessInputEnvelope = {
    data: ProductsCreateManyBusinessInput | ProductsCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type Pending_PaymentsCreateWithoutBusinessInput = {
    id?: string
    product_id: number
    full_amount?: Decimal | DecimalJsLike | number | string | null
    fiat_amount?: Decimal | DecimalJsLike | number | string | null
    crypto_amount?: Decimal | DecimalJsLike | number | string | null
    payout_date?: Date | string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Pending_PaymentsUncheckedCreateWithoutBusinessInput = {
    id?: string
    product_id: number
    full_amount?: Decimal | DecimalJsLike | number | string | null
    fiat_amount?: Decimal | DecimalJsLike | number | string | null
    crypto_amount?: Decimal | DecimalJsLike | number | string | null
    payout_date?: Date | string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Pending_PaymentsCreateOrConnectWithoutBusinessInput = {
    where: Pending_PaymentsWhereUniqueInput
    create: XOR<Pending_PaymentsCreateWithoutBusinessInput, Pending_PaymentsUncheckedCreateWithoutBusinessInput>
  }

  export type Pending_PaymentsCreateManyBusinessInputEnvelope = {
    data: Pending_PaymentsCreateManyBusinessInput | Pending_PaymentsCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type Affiliate_BusinessUpsertWithWhereUniqueWithoutBusinessInput = {
    where: Affiliate_BusinessWhereUniqueInput
    update: XOR<Affiliate_BusinessUpdateWithoutBusinessInput, Affiliate_BusinessUncheckedUpdateWithoutBusinessInput>
    create: XOR<Affiliate_BusinessCreateWithoutBusinessInput, Affiliate_BusinessUncheckedCreateWithoutBusinessInput>
  }

  export type Affiliate_BusinessUpdateWithWhereUniqueWithoutBusinessInput = {
    where: Affiliate_BusinessWhereUniqueInput
    data: XOR<Affiliate_BusinessUpdateWithoutBusinessInput, Affiliate_BusinessUncheckedUpdateWithoutBusinessInput>
  }

  export type Affiliate_BusinessUpdateManyWithWhereWithoutBusinessInput = {
    where: Affiliate_BusinessScalarWhereInput
    data: XOR<Affiliate_BusinessUpdateManyMutationInput, Affiliate_BusinessUncheckedUpdateManyWithoutBusinessInput>
  }

  export type Affiliate_BusinessScalarWhereInput = {
    AND?: Affiliate_BusinessScalarWhereInput | Affiliate_BusinessScalarWhereInput[]
    OR?: Affiliate_BusinessScalarWhereInput[]
    NOT?: Affiliate_BusinessScalarWhereInput | Affiliate_BusinessScalarWhereInput[]
    id?: UuidFilter<"Affiliate_Business"> | string
    business_id?: UuidFilter<"Affiliate_Business"> | string
    affiliate_id?: IntFilter<"Affiliate_Business"> | number
    affiliate_link?: StringNullableFilter<"Affiliate_Business"> | string | null
    affiliate_link_key?: StringNullableFilter<"Affiliate_Business"> | string | null
    product_id?: IntNullableFilter<"Affiliate_Business"> | number | null
    pipeline_id?: IntNullableFilter<"Affiliate_Business"> | number | null
    instagram_scope_identifier?: StringNullableFilter<"Affiliate_Business"> | string | null
  }

  export type MessagesUpsertWithWhereUniqueWithoutBusinessInput = {
    where: MessagesWhereUniqueInput
    update: XOR<MessagesUpdateWithoutBusinessInput, MessagesUncheckedUpdateWithoutBusinessInput>
    create: XOR<MessagesCreateWithoutBusinessInput, MessagesUncheckedCreateWithoutBusinessInput>
  }

  export type MessagesUpdateWithWhereUniqueWithoutBusinessInput = {
    where: MessagesWhereUniqueInput
    data: XOR<MessagesUpdateWithoutBusinessInput, MessagesUncheckedUpdateWithoutBusinessInput>
  }

  export type MessagesUpdateManyWithWhereWithoutBusinessInput = {
    where: MessagesScalarWhereInput
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyWithoutBusinessInput>
  }

  export type MessagesScalarWhereInput = {
    AND?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
    OR?: MessagesScalarWhereInput[]
    NOT?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
    id?: UuidFilter<"Messages"> | string
    message?: StringFilter<"Messages"> | string
    type?: StringFilter<"Messages"> | string
    sent_at?: DateTimeFilter<"Messages"> | Date | string
    business_id?: UuidFilter<"Messages"> | string
    message_id?: StringNullableFilter<"Messages"> | string | null
    email?: StringNullableFilter<"Messages"> | string | null
    name?: StringNullableFilter<"Messages"> | string | null
    subject?: StringFilter<"Messages"> | string
    parent_id?: UuidNullableFilter<"Messages"> | string | null
    channel_id?: StringNullableFilter<"Messages"> | string | null
    video_id?: StringNullableFilter<"Messages"> | string | null
  }

  export type OrdersUpsertWithWhereUniqueWithoutBusinessInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutBusinessInput, OrdersUncheckedUpdateWithoutBusinessInput>
    create: XOR<OrdersCreateWithoutBusinessInput, OrdersUncheckedCreateWithoutBusinessInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutBusinessInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutBusinessInput, OrdersUncheckedUpdateWithoutBusinessInput>
  }

  export type OrdersUpdateManyWithWhereWithoutBusinessInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutBusinessInput>
  }

  export type OrdersScalarWhereInput = {
    AND?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
    OR?: OrdersScalarWhereInput[]
    NOT?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
    id?: UuidFilter<"Orders"> | string
    customer_name?: StringNullableFilter<"Orders"> | string | null
    customer_email?: StringFilter<"Orders"> | string
    customer_address?: StringNullableFilter<"Orders"> | string | null
    invoice_url?: StringNullableFilter<"Orders"> | string | null
    order_quantity?: IntNullableFilter<"Orders"> | number | null
    status?: StringNullableFilter<"Orders"> | string | null
    created_at?: DateTimeFilter<"Orders"> | Date | string
    updated_at?: DateTimeFilter<"Orders"> | Date | string
    business_id?: UuidNullableFilter<"Orders"> | string | null
    affiliate_id?: IntNullableFilter<"Orders"> | number | null
    product_id?: IntNullableFilter<"Orders"> | number | null
  }

  export type PipelinesUpsertWithWhereUniqueWithoutBusinessInput = {
    where: PipelinesWhereUniqueInput
    update: XOR<PipelinesUpdateWithoutBusinessInput, PipelinesUncheckedUpdateWithoutBusinessInput>
    create: XOR<PipelinesCreateWithoutBusinessInput, PipelinesUncheckedCreateWithoutBusinessInput>
  }

  export type PipelinesUpdateWithWhereUniqueWithoutBusinessInput = {
    where: PipelinesWhereUniqueInput
    data: XOR<PipelinesUpdateWithoutBusinessInput, PipelinesUncheckedUpdateWithoutBusinessInput>
  }

  export type PipelinesUpdateManyWithWhereWithoutBusinessInput = {
    where: PipelinesScalarWhereInput
    data: XOR<PipelinesUpdateManyMutationInput, PipelinesUncheckedUpdateManyWithoutBusinessInput>
  }

  export type PipelinesScalarWhereInput = {
    AND?: PipelinesScalarWhereInput | PipelinesScalarWhereInput[]
    OR?: PipelinesScalarWhereInput[]
    NOT?: PipelinesScalarWhereInput | PipelinesScalarWhereInput[]
    id?: IntFilter<"Pipelines"> | number
    prompt?: StringNullableFilter<"Pipelines"> | string | null
    remark?: StringNullableFilter<"Pipelines"> | string | null
    status?: StringFilter<"Pipelines"> | string
    affiliate_count?: IntNullableFilter<"Pipelines"> | number | null
    business_id?: UuidNullableFilter<"Pipelines"> | string | null
    product_id?: IntNullableFilter<"Pipelines"> | number | null
    format?: StringNullableFilter<"Pipelines"> | string | null
    location?: StringNullableFilter<"Pipelines"> | string | null
    heygen_video_id?: StringNullableFilter<"Pipelines"> | string | null
    ig_post_id?: StringNullableFilter<"Pipelines"> | string | null
    ig_post_url?: StringNullableFilter<"Pipelines"> | string | null
    run_mode?: EnumRunModeNullableFilter<"Pipelines"> | $Enums.RunMode | null
    workflow?: StringNullableFilter<"Pipelines"> | string | null
    created_at?: DateTimeFilter<"Pipelines"> | Date | string
  }

  export type ProductsUpsertWithWhereUniqueWithoutBusinessInput = {
    where: ProductsWhereUniqueInput
    update: XOR<ProductsUpdateWithoutBusinessInput, ProductsUncheckedUpdateWithoutBusinessInput>
    create: XOR<ProductsCreateWithoutBusinessInput, ProductsUncheckedCreateWithoutBusinessInput>
  }

  export type ProductsUpdateWithWhereUniqueWithoutBusinessInput = {
    where: ProductsWhereUniqueInput
    data: XOR<ProductsUpdateWithoutBusinessInput, ProductsUncheckedUpdateWithoutBusinessInput>
  }

  export type ProductsUpdateManyWithWhereWithoutBusinessInput = {
    where: ProductsScalarWhereInput
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyWithoutBusinessInput>
  }

  export type ProductsScalarWhereInput = {
    AND?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
    OR?: ProductsScalarWhereInput[]
    NOT?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
    name?: StringFilter<"Products"> | string
    description?: StringFilter<"Products"> | string
    html_description?: StringNullableFilter<"Products"> | string | null
    image_url?: StringNullableFilter<"Products"> | string | null
    price?: FloatFilter<"Products"> | number
    price_currency?: StringNullableFilter<"Products"> | string | null
    is_shippable?: BoolNullableFilter<"Products"> | boolean | null
    price_type?: EnumPriceTypeNullableFilter<"Products"> | $Enums.PriceType | null
    created_at?: DateTimeFilter<"Products"> | Date | string
    updated_at?: DateTimeFilter<"Products"> | Date | string
    status?: StringFilter<"Products"> | string
    business_id?: UuidNullableFilter<"Products"> | string | null
    metadata?: JsonNullableFilter<"Products">
    id?: IntFilter<"Products"> | number
  }

  export type Pending_PaymentsUpsertWithWhereUniqueWithoutBusinessInput = {
    where: Pending_PaymentsWhereUniqueInput
    update: XOR<Pending_PaymentsUpdateWithoutBusinessInput, Pending_PaymentsUncheckedUpdateWithoutBusinessInput>
    create: XOR<Pending_PaymentsCreateWithoutBusinessInput, Pending_PaymentsUncheckedCreateWithoutBusinessInput>
  }

  export type Pending_PaymentsUpdateWithWhereUniqueWithoutBusinessInput = {
    where: Pending_PaymentsWhereUniqueInput
    data: XOR<Pending_PaymentsUpdateWithoutBusinessInput, Pending_PaymentsUncheckedUpdateWithoutBusinessInput>
  }

  export type Pending_PaymentsUpdateManyWithWhereWithoutBusinessInput = {
    where: Pending_PaymentsScalarWhereInput
    data: XOR<Pending_PaymentsUpdateManyMutationInput, Pending_PaymentsUncheckedUpdateManyWithoutBusinessInput>
  }

  export type Pending_PaymentsScalarWhereInput = {
    AND?: Pending_PaymentsScalarWhereInput | Pending_PaymentsScalarWhereInput[]
    OR?: Pending_PaymentsScalarWhereInput[]
    NOT?: Pending_PaymentsScalarWhereInput | Pending_PaymentsScalarWhereInput[]
    id?: UuidFilter<"Pending_Payments"> | string
    business_id?: UuidFilter<"Pending_Payments"> | string
    product_id?: IntFilter<"Pending_Payments"> | number
    full_amount?: DecimalNullableFilter<"Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: DecimalNullableFilter<"Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: DecimalNullableFilter<"Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    payout_date?: DateTimeNullableFilter<"Pending_Payments"> | Date | string | null
    status?: StringFilter<"Pending_Payments"> | string
    created_at?: DateTimeFilter<"Pending_Payments"> | Date | string
    updated_at?: DateTimeFilter<"Pending_Payments"> | Date | string
  }

  export type BusinessCreateWithoutMessagesInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutBusinessInput
    orders?: OrdersCreateNestedManyWithoutBusinessInput
    pipelines?: PipelinesCreateNestedManyWithoutBusinessInput
    products?: ProductsCreateNestedManyWithoutBusinessInput
    pending_payments?: Pending_PaymentsCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutMessagesInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrdersUncheckedCreateNestedManyWithoutBusinessInput
    pipelines?: PipelinesUncheckedCreateNestedManyWithoutBusinessInput
    products?: ProductsUncheckedCreateNestedManyWithoutBusinessInput
    pending_payments?: Pending_PaymentsUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutMessagesInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutMessagesInput, BusinessUncheckedCreateWithoutMessagesInput>
  }

  export type MessagesCreateWithoutRepliesInput = {
    id?: string
    message: string
    type: string
    sent_at?: Date | string
    message_id?: string | null
    email?: string | null
    name?: string | null
    subject: string
    channel_id?: string | null
    video_id?: string | null
    business: BusinessCreateNestedOneWithoutMessagesInput
    parent?: MessagesCreateNestedOneWithoutRepliesInput
  }

  export type MessagesUncheckedCreateWithoutRepliesInput = {
    id?: string
    message: string
    type: string
    sent_at?: Date | string
    business_id: string
    message_id?: string | null
    email?: string | null
    name?: string | null
    subject: string
    parent_id?: string | null
    channel_id?: string | null
    video_id?: string | null
  }

  export type MessagesCreateOrConnectWithoutRepliesInput = {
    where: MessagesWhereUniqueInput
    create: XOR<MessagesCreateWithoutRepliesInput, MessagesUncheckedCreateWithoutRepliesInput>
  }

  export type MessagesCreateWithoutParentInput = {
    id?: string
    message: string
    type: string
    sent_at?: Date | string
    message_id?: string | null
    email?: string | null
    name?: string | null
    subject: string
    channel_id?: string | null
    video_id?: string | null
    business: BusinessCreateNestedOneWithoutMessagesInput
    replies?: MessagesCreateNestedManyWithoutParentInput
  }

  export type MessagesUncheckedCreateWithoutParentInput = {
    id?: string
    message: string
    type: string
    sent_at?: Date | string
    business_id: string
    message_id?: string | null
    email?: string | null
    name?: string | null
    subject: string
    channel_id?: string | null
    video_id?: string | null
    replies?: MessagesUncheckedCreateNestedManyWithoutParentInput
  }

  export type MessagesCreateOrConnectWithoutParentInput = {
    where: MessagesWhereUniqueInput
    create: XOR<MessagesCreateWithoutParentInput, MessagesUncheckedCreateWithoutParentInput>
  }

  export type MessagesCreateManyParentInputEnvelope = {
    data: MessagesCreateManyParentInput | MessagesCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithoutMessagesInput = {
    update: XOR<BusinessUpdateWithoutMessagesInput, BusinessUncheckedUpdateWithoutMessagesInput>
    create: XOR<BusinessCreateWithoutMessagesInput, BusinessUncheckedCreateWithoutMessagesInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutMessagesInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutMessagesInput, BusinessUncheckedUpdateWithoutMessagesInput>
  }

  export type BusinessUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutBusinessNestedInput
    orders?: OrdersUpdateManyWithoutBusinessNestedInput
    pipelines?: PipelinesUpdateManyWithoutBusinessNestedInput
    products?: ProductsUpdateManyWithoutBusinessNestedInput
    pending_payments?: Pending_PaymentsUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutBusinessNestedInput
    pipelines?: PipelinesUncheckedUpdateManyWithoutBusinessNestedInput
    products?: ProductsUncheckedUpdateManyWithoutBusinessNestedInput
    pending_payments?: Pending_PaymentsUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type MessagesUpsertWithoutRepliesInput = {
    update: XOR<MessagesUpdateWithoutRepliesInput, MessagesUncheckedUpdateWithoutRepliesInput>
    create: XOR<MessagesCreateWithoutRepliesInput, MessagesUncheckedCreateWithoutRepliesInput>
    where?: MessagesWhereInput
  }

  export type MessagesUpdateToOneWithWhereWithoutRepliesInput = {
    where?: MessagesWhereInput
    data: XOR<MessagesUpdateWithoutRepliesInput, MessagesUncheckedUpdateWithoutRepliesInput>
  }

  export type MessagesUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    channel_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessUpdateOneRequiredWithoutMessagesNestedInput
    parent?: MessagesUpdateOneWithoutRepliesNestedInput
  }

  export type MessagesUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business_id?: StringFieldUpdateOperationsInput | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    channel_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessagesUpsertWithWhereUniqueWithoutParentInput = {
    where: MessagesWhereUniqueInput
    update: XOR<MessagesUpdateWithoutParentInput, MessagesUncheckedUpdateWithoutParentInput>
    create: XOR<MessagesCreateWithoutParentInput, MessagesUncheckedCreateWithoutParentInput>
  }

  export type MessagesUpdateWithWhereUniqueWithoutParentInput = {
    where: MessagesWhereUniqueInput
    data: XOR<MessagesUpdateWithoutParentInput, MessagesUncheckedUpdateWithoutParentInput>
  }

  export type MessagesUpdateManyWithWhereWithoutParentInput = {
    where: MessagesScalarWhereInput
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyWithoutParentInput>
  }

  export type Affiliate_BusinessCreateWithoutAffiliateInput = {
    id?: string
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    ig_scope_identifier?: ig_scope_identifiersCreateNestedOneWithoutAffiliate_businessInput
    business: BusinessCreateNestedOneWithoutAffiliate_businessInput
    products?: ProductsCreateNestedOneWithoutAffiliate_businessInput
    pipelines?: PipelinesCreateNestedOneWithoutAffiliate_businessInput
  }

  export type Affiliate_BusinessUncheckedCreateWithoutAffiliateInput = {
    id?: string
    business_id: string
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    product_id?: number | null
    pipeline_id?: number | null
    instagram_scope_identifier?: string | null
  }

  export type Affiliate_BusinessCreateOrConnectWithoutAffiliateInput = {
    where: Affiliate_BusinessWhereUniqueInput
    create: XOR<Affiliate_BusinessCreateWithoutAffiliateInput, Affiliate_BusinessUncheckedCreateWithoutAffiliateInput>
  }

  export type Affiliate_BusinessCreateManyAffiliateInputEnvelope = {
    data: Affiliate_BusinessCreateManyAffiliateInput | Affiliate_BusinessCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type OrdersCreateWithoutAffiliateInput = {
    id?: string
    customer_name?: string | null
    customer_email: string
    customer_address?: string | null
    invoice_url?: string | null
    order_quantity?: number | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    business?: BusinessCreateNestedOneWithoutOrdersInput
    products?: ProductsCreateNestedOneWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutAffiliateInput = {
    id?: string
    customer_name?: string | null
    customer_email: string
    customer_address?: string | null
    invoice_url?: string | null
    order_quantity?: number | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    business_id?: string | null
    product_id?: number | null
  }

  export type OrdersCreateOrConnectWithoutAffiliateInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutAffiliateInput, OrdersUncheckedCreateWithoutAffiliateInput>
  }

  export type OrdersCreateManyAffiliateInputEnvelope = {
    data: OrdersCreateManyAffiliateInput | OrdersCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type Affiliate_Pending_PaymentsCreateWithoutAffiliateInput = {
    id?: string
    product_id: number
    full_amount?: Decimal | DecimalJsLike | number | string | null
    fiat_amount?: Decimal | DecimalJsLike | number | string | null
    crypto_amount?: Decimal | DecimalJsLike | number | string | null
    payout_date?: Date | string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Affiliate_Pending_PaymentsUncheckedCreateWithoutAffiliateInput = {
    id?: string
    product_id: number
    full_amount?: Decimal | DecimalJsLike | number | string | null
    fiat_amount?: Decimal | DecimalJsLike | number | string | null
    crypto_amount?: Decimal | DecimalJsLike | number | string | null
    payout_date?: Date | string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Affiliate_Pending_PaymentsCreateOrConnectWithoutAffiliateInput = {
    where: Affiliate_Pending_PaymentsWhereUniqueInput
    create: XOR<Affiliate_Pending_PaymentsCreateWithoutAffiliateInput, Affiliate_Pending_PaymentsUncheckedCreateWithoutAffiliateInput>
  }

  export type Affiliate_Pending_PaymentsCreateManyAffiliateInputEnvelope = {
    data: Affiliate_Pending_PaymentsCreateManyAffiliateInput | Affiliate_Pending_PaymentsCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type Affiliate_BusinessUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: Affiliate_BusinessWhereUniqueInput
    update: XOR<Affiliate_BusinessUpdateWithoutAffiliateInput, Affiliate_BusinessUncheckedUpdateWithoutAffiliateInput>
    create: XOR<Affiliate_BusinessCreateWithoutAffiliateInput, Affiliate_BusinessUncheckedCreateWithoutAffiliateInput>
  }

  export type Affiliate_BusinessUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: Affiliate_BusinessWhereUniqueInput
    data: XOR<Affiliate_BusinessUpdateWithoutAffiliateInput, Affiliate_BusinessUncheckedUpdateWithoutAffiliateInput>
  }

  export type Affiliate_BusinessUpdateManyWithWhereWithoutAffiliateInput = {
    where: Affiliate_BusinessScalarWhereInput
    data: XOR<Affiliate_BusinessUpdateManyMutationInput, Affiliate_BusinessUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type OrdersUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutAffiliateInput, OrdersUncheckedUpdateWithoutAffiliateInput>
    create: XOR<OrdersCreateWithoutAffiliateInput, OrdersUncheckedCreateWithoutAffiliateInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutAffiliateInput, OrdersUncheckedUpdateWithoutAffiliateInput>
  }

  export type OrdersUpdateManyWithWhereWithoutAffiliateInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type Affiliate_Pending_PaymentsUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: Affiliate_Pending_PaymentsWhereUniqueInput
    update: XOR<Affiliate_Pending_PaymentsUpdateWithoutAffiliateInput, Affiliate_Pending_PaymentsUncheckedUpdateWithoutAffiliateInput>
    create: XOR<Affiliate_Pending_PaymentsCreateWithoutAffiliateInput, Affiliate_Pending_PaymentsUncheckedCreateWithoutAffiliateInput>
  }

  export type Affiliate_Pending_PaymentsUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: Affiliate_Pending_PaymentsWhereUniqueInput
    data: XOR<Affiliate_Pending_PaymentsUpdateWithoutAffiliateInput, Affiliate_Pending_PaymentsUncheckedUpdateWithoutAffiliateInput>
  }

  export type Affiliate_Pending_PaymentsUpdateManyWithWhereWithoutAffiliateInput = {
    where: Affiliate_Pending_PaymentsScalarWhereInput
    data: XOR<Affiliate_Pending_PaymentsUpdateManyMutationInput, Affiliate_Pending_PaymentsUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type Affiliate_Pending_PaymentsScalarWhereInput = {
    AND?: Affiliate_Pending_PaymentsScalarWhereInput | Affiliate_Pending_PaymentsScalarWhereInput[]
    OR?: Affiliate_Pending_PaymentsScalarWhereInput[]
    NOT?: Affiliate_Pending_PaymentsScalarWhereInput | Affiliate_Pending_PaymentsScalarWhereInput[]
    id?: UuidFilter<"Affiliate_Pending_Payments"> | string
    affiliate_id?: IntFilter<"Affiliate_Pending_Payments"> | number
    product_id?: IntFilter<"Affiliate_Pending_Payments"> | number
    full_amount?: DecimalNullableFilter<"Affiliate_Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: DecimalNullableFilter<"Affiliate_Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: DecimalNullableFilter<"Affiliate_Pending_Payments"> | Decimal | DecimalJsLike | number | string | null
    payout_date?: DateTimeNullableFilter<"Affiliate_Pending_Payments"> | Date | string | null
    status?: StringFilter<"Affiliate_Pending_Payments"> | string
    created_at?: DateTimeFilter<"Affiliate_Pending_Payments"> | Date | string
    updated_at?: DateTimeFilter<"Affiliate_Pending_Payments"> | Date | string
  }

  export type ig_scope_identifiersCreateWithoutAffiliate_businessInput = {
    id?: string
    ig_username: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ig_scope_identifiersUncheckedCreateWithoutAffiliate_businessInput = {
    id?: string
    ig_username: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ig_scope_identifiersCreateOrConnectWithoutAffiliate_businessInput = {
    where: ig_scope_identifiersWhereUniqueInput
    create: XOR<ig_scope_identifiersCreateWithoutAffiliate_businessInput, ig_scope_identifiersUncheckedCreateWithoutAffiliate_businessInput>
  }

  export type AffiliatesCreateWithoutAffiliate_businessInput = {
    first_name?: string | null
    last_name?: string | null
    email: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    wallet_address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    orders?: OrdersCreateNestedManyWithoutAffiliateInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliatesUncheckedCreateWithoutAffiliate_businessInput = {
    id?: number
    first_name?: string | null
    last_name?: string | null
    email: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    wallet_address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliateInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliatesCreateOrConnectWithoutAffiliate_businessInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutAffiliate_businessInput, AffiliatesUncheckedCreateWithoutAffiliate_businessInput>
  }

  export type BusinessCreateWithoutAffiliate_businessInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    messages?: MessagesCreateNestedManyWithoutBusinessInput
    orders?: OrdersCreateNestedManyWithoutBusinessInput
    pipelines?: PipelinesCreateNestedManyWithoutBusinessInput
    products?: ProductsCreateNestedManyWithoutBusinessInput
    pending_payments?: Pending_PaymentsCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutAffiliate_businessInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    messages?: MessagesUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrdersUncheckedCreateNestedManyWithoutBusinessInput
    pipelines?: PipelinesUncheckedCreateNestedManyWithoutBusinessInput
    products?: ProductsUncheckedCreateNestedManyWithoutBusinessInput
    pending_payments?: Pending_PaymentsUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutAffiliate_businessInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutAffiliate_businessInput, BusinessUncheckedCreateWithoutAffiliate_businessInput>
  }

  export type ProductsCreateWithoutAffiliate_businessInput = {
    name: string
    description: string
    html_description?: string | null
    image_url?: string | null
    price: number
    price_currency?: string | null
    is_shippable?: boolean | null
    price_type?: $Enums.PriceType | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    orders?: OrdersCreateNestedManyWithoutProductsInput
    pipelines?: PipelinesCreateNestedManyWithoutProductsInput
    business?: BusinessCreateNestedOneWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutAffiliate_businessInput = {
    name: string
    description: string
    html_description?: string | null
    image_url?: string | null
    price: number
    price_currency?: string | null
    is_shippable?: boolean | null
    price_type?: $Enums.PriceType | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    business_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: number
    orders?: OrdersUncheckedCreateNestedManyWithoutProductsInput
    pipelines?: PipelinesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutAffiliate_businessInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutAffiliate_businessInput, ProductsUncheckedCreateWithoutAffiliate_businessInput>
  }

  export type PipelinesCreateWithoutAffiliate_businessInput = {
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
    business?: BusinessCreateNestedOneWithoutPipelinesInput
    products?: ProductsCreateNestedOneWithoutPipelinesInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutPipelineInput
  }

  export type PipelinesUncheckedCreateWithoutAffiliate_businessInput = {
    id?: number
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    business_id?: string | null
    product_id?: number | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelinesCreateOrConnectWithoutAffiliate_businessInput = {
    where: PipelinesWhereUniqueInput
    create: XOR<PipelinesCreateWithoutAffiliate_businessInput, PipelinesUncheckedCreateWithoutAffiliate_businessInput>
  }

  export type ig_scope_identifiersUpsertWithoutAffiliate_businessInput = {
    update: XOR<ig_scope_identifiersUpdateWithoutAffiliate_businessInput, ig_scope_identifiersUncheckedUpdateWithoutAffiliate_businessInput>
    create: XOR<ig_scope_identifiersCreateWithoutAffiliate_businessInput, ig_scope_identifiersUncheckedCreateWithoutAffiliate_businessInput>
    where?: ig_scope_identifiersWhereInput
  }

  export type ig_scope_identifiersUpdateToOneWithWhereWithoutAffiliate_businessInput = {
    where?: ig_scope_identifiersWhereInput
    data: XOR<ig_scope_identifiersUpdateWithoutAffiliate_businessInput, ig_scope_identifiersUncheckedUpdateWithoutAffiliate_businessInput>
  }

  export type ig_scope_identifiersUpdateWithoutAffiliate_businessInput = {
    id?: StringFieldUpdateOperationsInput | string
    ig_username?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ig_scope_identifiersUncheckedUpdateWithoutAffiliate_businessInput = {
    id?: StringFieldUpdateOperationsInput | string
    ig_username?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliatesUpsertWithoutAffiliate_businessInput = {
    update: XOR<AffiliatesUpdateWithoutAffiliate_businessInput, AffiliatesUncheckedUpdateWithoutAffiliate_businessInput>
    create: XOR<AffiliatesCreateWithoutAffiliate_businessInput, AffiliatesUncheckedCreateWithoutAffiliate_businessInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutAffiliate_businessInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutAffiliate_businessInput, AffiliatesUncheckedUpdateWithoutAffiliate_businessInput>
  }

  export type AffiliatesUpdateWithoutAffiliate_businessInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    orders?: OrdersUpdateManyWithoutAffiliateNestedInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutAffiliate_businessInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    orders?: OrdersUncheckedUpdateManyWithoutAffiliateNestedInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type BusinessUpsertWithoutAffiliate_businessInput = {
    update: XOR<BusinessUpdateWithoutAffiliate_businessInput, BusinessUncheckedUpdateWithoutAffiliate_businessInput>
    create: XOR<BusinessCreateWithoutAffiliate_businessInput, BusinessUncheckedCreateWithoutAffiliate_businessInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutAffiliate_businessInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutAffiliate_businessInput, BusinessUncheckedUpdateWithoutAffiliate_businessInput>
  }

  export type BusinessUpdateWithoutAffiliate_businessInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    messages?: MessagesUpdateManyWithoutBusinessNestedInput
    orders?: OrdersUpdateManyWithoutBusinessNestedInput
    pipelines?: PipelinesUpdateManyWithoutBusinessNestedInput
    products?: ProductsUpdateManyWithoutBusinessNestedInput
    pending_payments?: Pending_PaymentsUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutAffiliate_businessInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    messages?: MessagesUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutBusinessNestedInput
    pipelines?: PipelinesUncheckedUpdateManyWithoutBusinessNestedInput
    products?: ProductsUncheckedUpdateManyWithoutBusinessNestedInput
    pending_payments?: Pending_PaymentsUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ProductsUpsertWithoutAffiliate_businessInput = {
    update: XOR<ProductsUpdateWithoutAffiliate_businessInput, ProductsUncheckedUpdateWithoutAffiliate_businessInput>
    create: XOR<ProductsCreateWithoutAffiliate_businessInput, ProductsUncheckedCreateWithoutAffiliate_businessInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutAffiliate_businessInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutAffiliate_businessInput, ProductsUncheckedUpdateWithoutAffiliate_businessInput>
  }

  export type ProductsUpdateWithoutAffiliate_businessInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    orders?: OrdersUpdateManyWithoutProductsNestedInput
    pipelines?: PipelinesUpdateManyWithoutProductsNestedInput
    business?: BusinessUpdateOneWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutAffiliate_businessInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: IntFieldUpdateOperationsInput | number
    orders?: OrdersUncheckedUpdateManyWithoutProductsNestedInput
    pipelines?: PipelinesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type PipelinesUpsertWithoutAffiliate_businessInput = {
    update: XOR<PipelinesUpdateWithoutAffiliate_businessInput, PipelinesUncheckedUpdateWithoutAffiliate_businessInput>
    create: XOR<PipelinesCreateWithoutAffiliate_businessInput, PipelinesUncheckedCreateWithoutAffiliate_businessInput>
    where?: PipelinesWhereInput
  }

  export type PipelinesUpdateToOneWithWhereWithoutAffiliate_businessInput = {
    where?: PipelinesWhereInput
    data: XOR<PipelinesUpdateWithoutAffiliate_businessInput, PipelinesUncheckedUpdateWithoutAffiliate_businessInput>
  }

  export type PipelinesUpdateWithoutAffiliate_businessInput = {
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneWithoutPipelinesNestedInput
    products?: ProductsUpdateOneWithoutPipelinesNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutPipelineNestedInput
  }

  export type PipelinesUncheckedUpdateWithoutAffiliate_businessInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type AffiliatesCreateWithoutOrdersInput = {
    first_name?: string | null
    last_name?: string | null
    email: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    wallet_address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutAffiliateInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliatesUncheckedCreateWithoutOrdersInput = {
    id?: number
    first_name?: string | null
    last_name?: string | null
    email: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    wallet_address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutAffiliateInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliatesCreateOrConnectWithoutOrdersInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutOrdersInput, AffiliatesUncheckedCreateWithoutOrdersInput>
  }

  export type BusinessCreateWithoutOrdersInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutBusinessInput
    messages?: MessagesCreateNestedManyWithoutBusinessInput
    pipelines?: PipelinesCreateNestedManyWithoutBusinessInput
    products?: ProductsCreateNestedManyWithoutBusinessInput
    pending_payments?: Pending_PaymentsCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutOrdersInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutBusinessInput
    messages?: MessagesUncheckedCreateNestedManyWithoutBusinessInput
    pipelines?: PipelinesUncheckedCreateNestedManyWithoutBusinessInput
    products?: ProductsUncheckedCreateNestedManyWithoutBusinessInput
    pending_payments?: Pending_PaymentsUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutOrdersInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutOrdersInput, BusinessUncheckedCreateWithoutOrdersInput>
  }

  export type ProductsCreateWithoutOrdersInput = {
    name: string
    description: string
    html_description?: string | null
    image_url?: string | null
    price: number
    price_currency?: string | null
    is_shippable?: boolean | null
    price_type?: $Enums.PriceType | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutProductsInput
    pipelines?: PipelinesCreateNestedManyWithoutProductsInput
    business?: BusinessCreateNestedOneWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutOrdersInput = {
    name: string
    description: string
    html_description?: string | null
    image_url?: string | null
    price: number
    price_currency?: string | null
    is_shippable?: boolean | null
    price_type?: $Enums.PriceType | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    business_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: number
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutProductsInput
    pipelines?: PipelinesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutOrdersInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutOrdersInput, ProductsUncheckedCreateWithoutOrdersInput>
  }

  export type AffiliatesUpsertWithoutOrdersInput = {
    update: XOR<AffiliatesUpdateWithoutOrdersInput, AffiliatesUncheckedUpdateWithoutOrdersInput>
    create: XOR<AffiliatesCreateWithoutOrdersInput, AffiliatesUncheckedCreateWithoutOrdersInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutOrdersInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutOrdersInput, AffiliatesUncheckedUpdateWithoutOrdersInput>
  }

  export type AffiliatesUpdateWithoutOrdersInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutAffiliateNestedInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutAffiliateNestedInput
    affiliate_pending_payments?: Affiliate_Pending_PaymentsUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type BusinessUpsertWithoutOrdersInput = {
    update: XOR<BusinessUpdateWithoutOrdersInput, BusinessUncheckedUpdateWithoutOrdersInput>
    create: XOR<BusinessCreateWithoutOrdersInput, BusinessUncheckedCreateWithoutOrdersInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutOrdersInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutOrdersInput, BusinessUncheckedUpdateWithoutOrdersInput>
  }

  export type BusinessUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutBusinessNestedInput
    messages?: MessagesUpdateManyWithoutBusinessNestedInput
    pipelines?: PipelinesUpdateManyWithoutBusinessNestedInput
    products?: ProductsUpdateManyWithoutBusinessNestedInput
    pending_payments?: Pending_PaymentsUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutBusinessNestedInput
    messages?: MessagesUncheckedUpdateManyWithoutBusinessNestedInput
    pipelines?: PipelinesUncheckedUpdateManyWithoutBusinessNestedInput
    products?: ProductsUncheckedUpdateManyWithoutBusinessNestedInput
    pending_payments?: Pending_PaymentsUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ProductsUpsertWithoutOrdersInput = {
    update: XOR<ProductsUpdateWithoutOrdersInput, ProductsUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProductsCreateWithoutOrdersInput, ProductsUncheckedCreateWithoutOrdersInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutOrdersInput, ProductsUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductsUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutProductsNestedInput
    pipelines?: PipelinesUpdateManyWithoutProductsNestedInput
    business?: BusinessUpdateOneWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: IntFieldUpdateOperationsInput | number
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutProductsNestedInput
    pipelines?: PipelinesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type Affiliate_BusinessCreateWithoutProductsInput = {
    id?: string
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    ig_scope_identifier?: ig_scope_identifiersCreateNestedOneWithoutAffiliate_businessInput
    affiliate: AffiliatesCreateNestedOneWithoutAffiliate_businessInput
    business: BusinessCreateNestedOneWithoutAffiliate_businessInput
    pipelines?: PipelinesCreateNestedOneWithoutAffiliate_businessInput
  }

  export type Affiliate_BusinessUncheckedCreateWithoutProductsInput = {
    id?: string
    business_id: string
    affiliate_id: number
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    pipeline_id?: number | null
    instagram_scope_identifier?: string | null
  }

  export type Affiliate_BusinessCreateOrConnectWithoutProductsInput = {
    where: Affiliate_BusinessWhereUniqueInput
    create: XOR<Affiliate_BusinessCreateWithoutProductsInput, Affiliate_BusinessUncheckedCreateWithoutProductsInput>
  }

  export type Affiliate_BusinessCreateManyProductsInputEnvelope = {
    data: Affiliate_BusinessCreateManyProductsInput | Affiliate_BusinessCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type OrdersCreateWithoutProductsInput = {
    id?: string
    customer_name?: string | null
    customer_email: string
    customer_address?: string | null
    invoice_url?: string | null
    order_quantity?: number | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    affiliate?: AffiliatesCreateNestedOneWithoutOrdersInput
    business?: BusinessCreateNestedOneWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutProductsInput = {
    id?: string
    customer_name?: string | null
    customer_email: string
    customer_address?: string | null
    invoice_url?: string | null
    order_quantity?: number | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    business_id?: string | null
    affiliate_id?: number | null
  }

  export type OrdersCreateOrConnectWithoutProductsInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutProductsInput, OrdersUncheckedCreateWithoutProductsInput>
  }

  export type OrdersCreateManyProductsInputEnvelope = {
    data: OrdersCreateManyProductsInput | OrdersCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type PipelinesCreateWithoutProductsInput = {
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
    business?: BusinessCreateNestedOneWithoutPipelinesInput
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutPipelinesInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutPipelineInput
  }

  export type PipelinesUncheckedCreateWithoutProductsInput = {
    id?: number
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    business_id?: string | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutPipelinesInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelinesCreateOrConnectWithoutProductsInput = {
    where: PipelinesWhereUniqueInput
    create: XOR<PipelinesCreateWithoutProductsInput, PipelinesUncheckedCreateWithoutProductsInput>
  }

  export type PipelinesCreateManyProductsInputEnvelope = {
    data: PipelinesCreateManyProductsInput | PipelinesCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type BusinessCreateWithoutProductsInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutBusinessInput
    messages?: MessagesCreateNestedManyWithoutBusinessInput
    orders?: OrdersCreateNestedManyWithoutBusinessInput
    pipelines?: PipelinesCreateNestedManyWithoutBusinessInput
    pending_payments?: Pending_PaymentsCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutProductsInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutBusinessInput
    messages?: MessagesUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrdersUncheckedCreateNestedManyWithoutBusinessInput
    pipelines?: PipelinesUncheckedCreateNestedManyWithoutBusinessInput
    pending_payments?: Pending_PaymentsUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutProductsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutProductsInput, BusinessUncheckedCreateWithoutProductsInput>
  }

  export type Affiliate_BusinessUpsertWithWhereUniqueWithoutProductsInput = {
    where: Affiliate_BusinessWhereUniqueInput
    update: XOR<Affiliate_BusinessUpdateWithoutProductsInput, Affiliate_BusinessUncheckedUpdateWithoutProductsInput>
    create: XOR<Affiliate_BusinessCreateWithoutProductsInput, Affiliate_BusinessUncheckedCreateWithoutProductsInput>
  }

  export type Affiliate_BusinessUpdateWithWhereUniqueWithoutProductsInput = {
    where: Affiliate_BusinessWhereUniqueInput
    data: XOR<Affiliate_BusinessUpdateWithoutProductsInput, Affiliate_BusinessUncheckedUpdateWithoutProductsInput>
  }

  export type Affiliate_BusinessUpdateManyWithWhereWithoutProductsInput = {
    where: Affiliate_BusinessScalarWhereInput
    data: XOR<Affiliate_BusinessUpdateManyMutationInput, Affiliate_BusinessUncheckedUpdateManyWithoutProductsInput>
  }

  export type OrdersUpsertWithWhereUniqueWithoutProductsInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutProductsInput, OrdersUncheckedUpdateWithoutProductsInput>
    create: XOR<OrdersCreateWithoutProductsInput, OrdersUncheckedCreateWithoutProductsInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutProductsInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutProductsInput, OrdersUncheckedUpdateWithoutProductsInput>
  }

  export type OrdersUpdateManyWithWhereWithoutProductsInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutProductsInput>
  }

  export type PipelinesUpsertWithWhereUniqueWithoutProductsInput = {
    where: PipelinesWhereUniqueInput
    update: XOR<PipelinesUpdateWithoutProductsInput, PipelinesUncheckedUpdateWithoutProductsInput>
    create: XOR<PipelinesCreateWithoutProductsInput, PipelinesUncheckedCreateWithoutProductsInput>
  }

  export type PipelinesUpdateWithWhereUniqueWithoutProductsInput = {
    where: PipelinesWhereUniqueInput
    data: XOR<PipelinesUpdateWithoutProductsInput, PipelinesUncheckedUpdateWithoutProductsInput>
  }

  export type PipelinesUpdateManyWithWhereWithoutProductsInput = {
    where: PipelinesScalarWhereInput
    data: XOR<PipelinesUpdateManyMutationInput, PipelinesUncheckedUpdateManyWithoutProductsInput>
  }

  export type BusinessUpsertWithoutProductsInput = {
    update: XOR<BusinessUpdateWithoutProductsInput, BusinessUncheckedUpdateWithoutProductsInput>
    create: XOR<BusinessCreateWithoutProductsInput, BusinessUncheckedCreateWithoutProductsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutProductsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutProductsInput, BusinessUncheckedUpdateWithoutProductsInput>
  }

  export type BusinessUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutBusinessNestedInput
    messages?: MessagesUpdateManyWithoutBusinessNestedInput
    orders?: OrdersUpdateManyWithoutBusinessNestedInput
    pipelines?: PipelinesUpdateManyWithoutBusinessNestedInput
    pending_payments?: Pending_PaymentsUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutBusinessNestedInput
    messages?: MessagesUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutBusinessNestedInput
    pipelines?: PipelinesUncheckedUpdateManyWithoutBusinessNestedInput
    pending_payments?: Pending_PaymentsUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateWithoutPipelinesInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutBusinessInput
    messages?: MessagesCreateNestedManyWithoutBusinessInput
    orders?: OrdersCreateNestedManyWithoutBusinessInput
    products?: ProductsCreateNestedManyWithoutBusinessInput
    pending_payments?: Pending_PaymentsCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutPipelinesInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutBusinessInput
    messages?: MessagesUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrdersUncheckedCreateNestedManyWithoutBusinessInput
    products?: ProductsUncheckedCreateNestedManyWithoutBusinessInput
    pending_payments?: Pending_PaymentsUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutPipelinesInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutPipelinesInput, BusinessUncheckedCreateWithoutPipelinesInput>
  }

  export type ProductsCreateWithoutPipelinesInput = {
    name: string
    description: string
    html_description?: string | null
    image_url?: string | null
    price: number
    price_currency?: string | null
    is_shippable?: boolean | null
    price_type?: $Enums.PriceType | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutProductsInput
    orders?: OrdersCreateNestedManyWithoutProductsInput
    business?: BusinessCreateNestedOneWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutPipelinesInput = {
    name: string
    description: string
    html_description?: string | null
    image_url?: string | null
    price: number
    price_currency?: string | null
    is_shippable?: boolean | null
    price_type?: $Enums.PriceType | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    business_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: number
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrdersUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutPipelinesInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutPipelinesInput, ProductsUncheckedCreateWithoutPipelinesInput>
  }

  export type Affiliate_BusinessCreateWithoutPipelinesInput = {
    id?: string
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    ig_scope_identifier?: ig_scope_identifiersCreateNestedOneWithoutAffiliate_businessInput
    affiliate: AffiliatesCreateNestedOneWithoutAffiliate_businessInput
    business: BusinessCreateNestedOneWithoutAffiliate_businessInput
    products?: ProductsCreateNestedOneWithoutAffiliate_businessInput
  }

  export type Affiliate_BusinessUncheckedCreateWithoutPipelinesInput = {
    id?: string
    business_id: string
    affiliate_id: number
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    product_id?: number | null
    instagram_scope_identifier?: string | null
  }

  export type Affiliate_BusinessCreateOrConnectWithoutPipelinesInput = {
    where: Affiliate_BusinessWhereUniqueInput
    create: XOR<Affiliate_BusinessCreateWithoutPipelinesInput, Affiliate_BusinessUncheckedCreateWithoutPipelinesInput>
  }

  export type Affiliate_BusinessCreateManyPipelinesInputEnvelope = {
    data: Affiliate_BusinessCreateManyPipelinesInput | Affiliate_BusinessCreateManyPipelinesInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutPipelineInput = {
    sender: string
    receiver: string
    text: string
    chat_message_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatMessageUncheckedCreateWithoutPipelineInput = {
    id?: number
    sender: string
    receiver: string
    text: string
    chat_message_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutPipelineInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutPipelineInput, ChatMessageUncheckedCreateWithoutPipelineInput>
  }

  export type ChatMessageCreateManyPipelineInputEnvelope = {
    data: ChatMessageCreateManyPipelineInput | ChatMessageCreateManyPipelineInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithoutPipelinesInput = {
    update: XOR<BusinessUpdateWithoutPipelinesInput, BusinessUncheckedUpdateWithoutPipelinesInput>
    create: XOR<BusinessCreateWithoutPipelinesInput, BusinessUncheckedCreateWithoutPipelinesInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutPipelinesInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutPipelinesInput, BusinessUncheckedUpdateWithoutPipelinesInput>
  }

  export type BusinessUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutBusinessNestedInput
    messages?: MessagesUpdateManyWithoutBusinessNestedInput
    orders?: OrdersUpdateManyWithoutBusinessNestedInput
    products?: ProductsUpdateManyWithoutBusinessNestedInput
    pending_payments?: Pending_PaymentsUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutBusinessNestedInput
    messages?: MessagesUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutBusinessNestedInput
    products?: ProductsUncheckedUpdateManyWithoutBusinessNestedInput
    pending_payments?: Pending_PaymentsUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ProductsUpsertWithoutPipelinesInput = {
    update: XOR<ProductsUpdateWithoutPipelinesInput, ProductsUncheckedUpdateWithoutPipelinesInput>
    create: XOR<ProductsCreateWithoutPipelinesInput, ProductsUncheckedCreateWithoutPipelinesInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutPipelinesInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutPipelinesInput, ProductsUncheckedUpdateWithoutPipelinesInput>
  }

  export type ProductsUpdateWithoutPipelinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutProductsNestedInput
    orders?: OrdersUpdateManyWithoutProductsNestedInput
    business?: BusinessUpdateOneWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutPipelinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: IntFieldUpdateOperationsInput | number
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type Affiliate_BusinessUpsertWithWhereUniqueWithoutPipelinesInput = {
    where: Affiliate_BusinessWhereUniqueInput
    update: XOR<Affiliate_BusinessUpdateWithoutPipelinesInput, Affiliate_BusinessUncheckedUpdateWithoutPipelinesInput>
    create: XOR<Affiliate_BusinessCreateWithoutPipelinesInput, Affiliate_BusinessUncheckedCreateWithoutPipelinesInput>
  }

  export type Affiliate_BusinessUpdateWithWhereUniqueWithoutPipelinesInput = {
    where: Affiliate_BusinessWhereUniqueInput
    data: XOR<Affiliate_BusinessUpdateWithoutPipelinesInput, Affiliate_BusinessUncheckedUpdateWithoutPipelinesInput>
  }

  export type Affiliate_BusinessUpdateManyWithWhereWithoutPipelinesInput = {
    where: Affiliate_BusinessScalarWhereInput
    data: XOR<Affiliate_BusinessUpdateManyMutationInput, Affiliate_BusinessUncheckedUpdateManyWithoutPipelinesInput>
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutPipelineInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutPipelineInput, ChatMessageUncheckedUpdateWithoutPipelineInput>
    create: XOR<ChatMessageCreateWithoutPipelineInput, ChatMessageUncheckedCreateWithoutPipelineInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutPipelineInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutPipelineInput, ChatMessageUncheckedUpdateWithoutPipelineInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutPipelineInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutPipelineInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    sender?: StringFilter<"ChatMessage"> | string
    receiver?: StringFilter<"ChatMessage"> | string
    text?: StringFilter<"ChatMessage"> | string
    pipeline_id?: IntFilter<"ChatMessage"> | number
    chat_message_status?: StringNullableFilter<"ChatMessage"> | string | null
    created_at?: DateTimeFilter<"ChatMessage"> | Date | string
    updated_at?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type PipelinesCreateWithoutChatMessageInput = {
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
    business?: BusinessCreateNestedOneWithoutPipelinesInput
    products?: ProductsCreateNestedOneWithoutPipelinesInput
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutPipelinesInput
  }

  export type PipelinesUncheckedCreateWithoutChatMessageInput = {
    id?: number
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    business_id?: string | null
    product_id?: number | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutPipelinesInput
  }

  export type PipelinesCreateOrConnectWithoutChatMessageInput = {
    where: PipelinesWhereUniqueInput
    create: XOR<PipelinesCreateWithoutChatMessageInput, PipelinesUncheckedCreateWithoutChatMessageInput>
  }

  export type PipelinesUpsertWithoutChatMessageInput = {
    update: XOR<PipelinesUpdateWithoutChatMessageInput, PipelinesUncheckedUpdateWithoutChatMessageInput>
    create: XOR<PipelinesCreateWithoutChatMessageInput, PipelinesUncheckedCreateWithoutChatMessageInput>
    where?: PipelinesWhereInput
  }

  export type PipelinesUpdateToOneWithWhereWithoutChatMessageInput = {
    where?: PipelinesWhereInput
    data: XOR<PipelinesUpdateWithoutChatMessageInput, PipelinesUncheckedUpdateWithoutChatMessageInput>
  }

  export type PipelinesUpdateWithoutChatMessageInput = {
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneWithoutPipelinesNestedInput
    products?: ProductsUpdateOneWithoutPipelinesNestedInput
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutPipelinesNestedInput
  }

  export type PipelinesUncheckedUpdateWithoutChatMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutPipelinesNestedInput
  }

  export type BusinessCreateWithoutPending_paymentsInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutBusinessInput
    messages?: MessagesCreateNestedManyWithoutBusinessInput
    orders?: OrdersCreateNestedManyWithoutBusinessInput
    pipelines?: PipelinesCreateNestedManyWithoutBusinessInput
    products?: ProductsCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutPending_paymentsInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email: string
    store_name?: string | null
    slug: string
    description?: string | null
    url?: string | null
    wallet_address?: string | null
    commission?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_hub_description?: string | null
    svix_consumer_app_id?: string | null
    stripe_connected_account?: string | null
    price_plan?: $Enums.PricePlan | null
    trial_ends_at?: Date | string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_preference?: $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutBusinessInput
    messages?: MessagesUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrdersUncheckedCreateNestedManyWithoutBusinessInput
    pipelines?: PipelinesUncheckedCreateNestedManyWithoutBusinessInput
    products?: ProductsUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutPending_paymentsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutPending_paymentsInput, BusinessUncheckedCreateWithoutPending_paymentsInput>
  }

  export type BusinessUpsertWithoutPending_paymentsInput = {
    update: XOR<BusinessUpdateWithoutPending_paymentsInput, BusinessUncheckedUpdateWithoutPending_paymentsInput>
    create: XOR<BusinessCreateWithoutPending_paymentsInput, BusinessUncheckedCreateWithoutPending_paymentsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutPending_paymentsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutPending_paymentsInput, BusinessUncheckedUpdateWithoutPending_paymentsInput>
  }

  export type BusinessUpdateWithoutPending_paymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutBusinessNestedInput
    messages?: MessagesUpdateManyWithoutBusinessNestedInput
    orders?: OrdersUpdateManyWithoutBusinessNestedInput
    pipelines?: PipelinesUpdateManyWithoutBusinessNestedInput
    products?: ProductsUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutPending_paymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    store_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_hub_description?: NullableStringFieldUpdateOperationsInput | string | null
    svix_consumer_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connected_account?: NullableStringFieldUpdateOperationsInput | string | null
    price_plan?: NullableEnumPricePlanFieldUpdateOperationsInput | $Enums.PricePlan | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_preference?: EnumPaymentPreferenceFieldUpdateOperationsInput | $Enums.PaymentPreference
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutBusinessNestedInput
    messages?: MessagesUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutBusinessNestedInput
    pipelines?: PipelinesUncheckedUpdateManyWithoutBusinessNestedInput
    products?: ProductsUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type AffiliatesCreateWithoutAffiliate_pending_paymentsInput = {
    first_name?: string | null
    last_name?: string | null
    email: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    wallet_address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessCreateNestedManyWithoutAffiliateInput
    orders?: OrdersCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliatesUncheckedCreateWithoutAffiliate_pending_paymentsInput = {
    id?: number
    first_name?: string | null
    last_name?: string | null
    email: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    wallet_address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliatesCreateOrConnectWithoutAffiliate_pending_paymentsInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutAffiliate_pending_paymentsInput, AffiliatesUncheckedCreateWithoutAffiliate_pending_paymentsInput>
  }

  export type AffiliatesUpsertWithoutAffiliate_pending_paymentsInput = {
    update: XOR<AffiliatesUpdateWithoutAffiliate_pending_paymentsInput, AffiliatesUncheckedUpdateWithoutAffiliate_pending_paymentsInput>
    create: XOR<AffiliatesCreateWithoutAffiliate_pending_paymentsInput, AffiliatesUncheckedCreateWithoutAffiliate_pending_paymentsInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutAffiliate_pending_paymentsInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutAffiliate_pending_paymentsInput, AffiliatesUncheckedUpdateWithoutAffiliate_pending_paymentsInput>
  }

  export type AffiliatesUpdateWithoutAffiliate_pending_paymentsInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutAffiliateNestedInput
    orders?: OrdersUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutAffiliate_pending_paymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    social_media_profiles?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutAffiliateNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type resourcesCreateWithoutEmbeddingsInput = {
    id?: bigint | number
    content?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type resourcesUncheckedCreateWithoutEmbeddingsInput = {
    id?: bigint | number
    content?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type resourcesCreateOrConnectWithoutEmbeddingsInput = {
    where: resourcesWhereUniqueInput
    create: XOR<resourcesCreateWithoutEmbeddingsInput, resourcesUncheckedCreateWithoutEmbeddingsInput>
  }

  export type resourcesUpsertWithoutEmbeddingsInput = {
    update: XOR<resourcesUpdateWithoutEmbeddingsInput, resourcesUncheckedUpdateWithoutEmbeddingsInput>
    create: XOR<resourcesCreateWithoutEmbeddingsInput, resourcesUncheckedCreateWithoutEmbeddingsInput>
    where?: resourcesWhereInput
  }

  export type resourcesUpdateToOneWithWhereWithoutEmbeddingsInput = {
    where?: resourcesWhereInput
    data: XOR<resourcesUpdateWithoutEmbeddingsInput, resourcesUncheckedUpdateWithoutEmbeddingsInput>
  }

  export type resourcesUpdateWithoutEmbeddingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourcesUncheckedUpdateWithoutEmbeddingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type embeddingsCreateWithoutResourcesInput = {
    id?: bigint | number
    created_at?: Date | string
    content?: string | null
  }

  export type embeddingsUncheckedCreateWithoutResourcesInput = {
    id?: bigint | number
    created_at?: Date | string
    content?: string | null
  }

  export type embeddingsCreateOrConnectWithoutResourcesInput = {
    where: embeddingsWhereUniqueInput
    create: XOR<embeddingsCreateWithoutResourcesInput, embeddingsUncheckedCreateWithoutResourcesInput>
  }

  export type embeddingsCreateManyResourcesInputEnvelope = {
    data: embeddingsCreateManyResourcesInput | embeddingsCreateManyResourcesInput[]
    skipDuplicates?: boolean
  }

  export type embeddingsUpsertWithWhereUniqueWithoutResourcesInput = {
    where: embeddingsWhereUniqueInput
    update: XOR<embeddingsUpdateWithoutResourcesInput, embeddingsUncheckedUpdateWithoutResourcesInput>
    create: XOR<embeddingsCreateWithoutResourcesInput, embeddingsUncheckedCreateWithoutResourcesInput>
  }

  export type embeddingsUpdateWithWhereUniqueWithoutResourcesInput = {
    where: embeddingsWhereUniqueInput
    data: XOR<embeddingsUpdateWithoutResourcesInput, embeddingsUncheckedUpdateWithoutResourcesInput>
  }

  export type embeddingsUpdateManyWithWhereWithoutResourcesInput = {
    where: embeddingsScalarWhereInput
    data: XOR<embeddingsUpdateManyMutationInput, embeddingsUncheckedUpdateManyWithoutResourcesInput>
  }

  export type embeddingsScalarWhereInput = {
    AND?: embeddingsScalarWhereInput | embeddingsScalarWhereInput[]
    OR?: embeddingsScalarWhereInput[]
    NOT?: embeddingsScalarWhereInput | embeddingsScalarWhereInput[]
    id?: BigIntFilter<"embeddings"> | bigint | number
    created_at?: DateTimeFilter<"embeddings"> | Date | string
    content?: StringNullableFilter<"embeddings"> | string | null
    resource_id?: BigIntNullableFilter<"embeddings"> | bigint | number | null
  }

  export type Affiliate_BusinessCreateWithoutIg_scope_identifierInput = {
    id?: string
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    affiliate: AffiliatesCreateNestedOneWithoutAffiliate_businessInput
    business: BusinessCreateNestedOneWithoutAffiliate_businessInput
    products?: ProductsCreateNestedOneWithoutAffiliate_businessInput
    pipelines?: PipelinesCreateNestedOneWithoutAffiliate_businessInput
  }

  export type Affiliate_BusinessUncheckedCreateWithoutIg_scope_identifierInput = {
    id?: string
    business_id: string
    affiliate_id: number
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    product_id?: number | null
    pipeline_id?: number | null
  }

  export type Affiliate_BusinessCreateOrConnectWithoutIg_scope_identifierInput = {
    where: Affiliate_BusinessWhereUniqueInput
    create: XOR<Affiliate_BusinessCreateWithoutIg_scope_identifierInput, Affiliate_BusinessUncheckedCreateWithoutIg_scope_identifierInput>
  }

  export type Affiliate_BusinessCreateManyIg_scope_identifierInputEnvelope = {
    data: Affiliate_BusinessCreateManyIg_scope_identifierInput | Affiliate_BusinessCreateManyIg_scope_identifierInput[]
    skipDuplicates?: boolean
  }

  export type Affiliate_BusinessUpsertWithWhereUniqueWithoutIg_scope_identifierInput = {
    where: Affiliate_BusinessWhereUniqueInput
    update: XOR<Affiliate_BusinessUpdateWithoutIg_scope_identifierInput, Affiliate_BusinessUncheckedUpdateWithoutIg_scope_identifierInput>
    create: XOR<Affiliate_BusinessCreateWithoutIg_scope_identifierInput, Affiliate_BusinessUncheckedCreateWithoutIg_scope_identifierInput>
  }

  export type Affiliate_BusinessUpdateWithWhereUniqueWithoutIg_scope_identifierInput = {
    where: Affiliate_BusinessWhereUniqueInput
    data: XOR<Affiliate_BusinessUpdateWithoutIg_scope_identifierInput, Affiliate_BusinessUncheckedUpdateWithoutIg_scope_identifierInput>
  }

  export type Affiliate_BusinessUpdateManyWithWhereWithoutIg_scope_identifierInput = {
    where: Affiliate_BusinessScalarWhereInput
    data: XOR<Affiliate_BusinessUpdateManyMutationInput, Affiliate_BusinessUncheckedUpdateManyWithoutIg_scope_identifierInput>
  }

  export type Affiliate_BusinessCreateManyBusinessInput = {
    id?: string
    affiliate_id: number
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    product_id?: number | null
    pipeline_id?: number | null
    instagram_scope_identifier?: string | null
  }

  export type MessagesCreateManyBusinessInput = {
    id?: string
    message: string
    type: string
    sent_at?: Date | string
    message_id?: string | null
    email?: string | null
    name?: string | null
    subject: string
    parent_id?: string | null
    channel_id?: string | null
    video_id?: string | null
  }

  export type OrdersCreateManyBusinessInput = {
    id?: string
    customer_name?: string | null
    customer_email: string
    customer_address?: string | null
    invoice_url?: string | null
    order_quantity?: number | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    affiliate_id?: number | null
    product_id?: number | null
  }

  export type PipelinesCreateManyBusinessInput = {
    id?: number
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    product_id?: number | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
  }

  export type ProductsCreateManyBusinessInput = {
    name: string
    description: string
    html_description?: string | null
    image_url?: string | null
    price: number
    price_currency?: string | null
    is_shippable?: boolean | null
    price_type?: $Enums.PriceType | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: number
  }

  export type Pending_PaymentsCreateManyBusinessInput = {
    id?: string
    product_id: number
    full_amount?: Decimal | DecimalJsLike | number | string | null
    fiat_amount?: Decimal | DecimalJsLike | number | string | null
    crypto_amount?: Decimal | DecimalJsLike | number | string | null
    payout_date?: Date | string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Affiliate_BusinessUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    ig_scope_identifier?: ig_scope_identifiersUpdateOneWithoutAffiliate_businessNestedInput
    affiliate?: AffiliatesUpdateOneRequiredWithoutAffiliate_businessNestedInput
    products?: ProductsUpdateOneWithoutAffiliate_businessNestedInput
    pipelines?: PipelinesUpdateOneWithoutAffiliate_businessNestedInput
  }

  export type Affiliate_BusinessUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_id?: IntFieldUpdateOperationsInput | number
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    pipeline_id?: NullableIntFieldUpdateOperationsInput | number | null
    instagram_scope_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Affiliate_BusinessUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_id?: IntFieldUpdateOperationsInput | number
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    pipeline_id?: NullableIntFieldUpdateOperationsInput | number | null
    instagram_scope_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessagesUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    channel_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: MessagesUpdateOneWithoutRepliesNestedInput
    replies?: MessagesUpdateManyWithoutParentNestedInput
  }

  export type MessagesUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    channel_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessagesUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MessagesUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    channel_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrdersUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliatesUpdateOneWithoutOrdersNestedInput
    products?: ProductsUpdateOneWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrdersUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PipelinesUpdateWithoutBusinessInput = {
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductsUpdateOneWithoutPipelinesNestedInput
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutPipelinesNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutPipelineNestedInput
  }

  export type PipelinesUncheckedUpdateWithoutBusinessInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutPipelinesNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type PipelinesUncheckedUpdateManyWithoutBusinessInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductsUpdateWithoutBusinessInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutProductsNestedInput
    orders?: OrdersUpdateManyWithoutProductsNestedInput
    pipelines?: PipelinesUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutBusinessInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: IntFieldUpdateOperationsInput | number
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutProductsNestedInput
    pipelines?: PipelinesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateManyWithoutBusinessInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    html_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    price_currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_shippable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    price_type?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    id?: IntFieldUpdateOperationsInput | number
  }

  export type Pending_PaymentsUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Pending_PaymentsUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Pending_PaymentsUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessagesCreateManyParentInput = {
    id?: string
    message: string
    type: string
    sent_at?: Date | string
    business_id: string
    message_id?: string | null
    email?: string | null
    name?: string | null
    subject: string
    channel_id?: string | null
    video_id?: string | null
  }

  export type MessagesUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    channel_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessUpdateOneRequiredWithoutMessagesNestedInput
    replies?: MessagesUpdateManyWithoutParentNestedInput
  }

  export type MessagesUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business_id?: StringFieldUpdateOperationsInput | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    channel_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessagesUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MessagesUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business_id?: StringFieldUpdateOperationsInput | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    channel_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Affiliate_BusinessCreateManyAffiliateInput = {
    id?: string
    business_id: string
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    product_id?: number | null
    pipeline_id?: number | null
    instagram_scope_identifier?: string | null
  }

  export type OrdersCreateManyAffiliateInput = {
    id?: string
    customer_name?: string | null
    customer_email: string
    customer_address?: string | null
    invoice_url?: string | null
    order_quantity?: number | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    business_id?: string | null
    product_id?: number | null
  }

  export type Affiliate_Pending_PaymentsCreateManyAffiliateInput = {
    id?: string
    product_id: number
    full_amount?: Decimal | DecimalJsLike | number | string | null
    fiat_amount?: Decimal | DecimalJsLike | number | string | null
    crypto_amount?: Decimal | DecimalJsLike | number | string | null
    payout_date?: Date | string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Affiliate_BusinessUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    ig_scope_identifier?: ig_scope_identifiersUpdateOneWithoutAffiliate_businessNestedInput
    business?: BusinessUpdateOneRequiredWithoutAffiliate_businessNestedInput
    products?: ProductsUpdateOneWithoutAffiliate_businessNestedInput
    pipelines?: PipelinesUpdateOneWithoutAffiliate_businessNestedInput
  }

  export type Affiliate_BusinessUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_id?: StringFieldUpdateOperationsInput | string
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    pipeline_id?: NullableIntFieldUpdateOperationsInput | number | null
    instagram_scope_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Affiliate_BusinessUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_id?: StringFieldUpdateOperationsInput | string
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    pipeline_id?: NullableIntFieldUpdateOperationsInput | number | null
    instagram_scope_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrdersUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneWithoutOrdersNestedInput
    products?: ProductsUpdateOneWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrdersUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Affiliate_Pending_PaymentsUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Affiliate_Pending_PaymentsUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Affiliate_Pending_PaymentsUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    full_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fiat_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crypto_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Affiliate_BusinessCreateManyProductsInput = {
    id?: string
    business_id: string
    affiliate_id: number
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    pipeline_id?: number | null
    instagram_scope_identifier?: string | null
  }

  export type OrdersCreateManyProductsInput = {
    id?: string
    customer_name?: string | null
    customer_email: string
    customer_address?: string | null
    invoice_url?: string | null
    order_quantity?: number | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    business_id?: string | null
    affiliate_id?: number | null
  }

  export type PipelinesCreateManyProductsInput = {
    id?: number
    prompt?: string | null
    remark?: string | null
    status?: string
    affiliate_count?: number | null
    business_id?: string | null
    format?: string | null
    location?: string | null
    heygen_video_id?: string | null
    ig_post_id?: string | null
    ig_post_url?: string | null
    run_mode?: $Enums.RunMode | null
    workflow?: string | null
    created_at?: Date | string
  }

  export type Affiliate_BusinessUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    ig_scope_identifier?: ig_scope_identifiersUpdateOneWithoutAffiliate_businessNestedInput
    affiliate?: AffiliatesUpdateOneRequiredWithoutAffiliate_businessNestedInput
    business?: BusinessUpdateOneRequiredWithoutAffiliate_businessNestedInput
    pipelines?: PipelinesUpdateOneWithoutAffiliate_businessNestedInput
  }

  export type Affiliate_BusinessUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_id?: StringFieldUpdateOperationsInput | string
    affiliate_id?: IntFieldUpdateOperationsInput | number
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline_id?: NullableIntFieldUpdateOperationsInput | number | null
    instagram_scope_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Affiliate_BusinessUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_id?: StringFieldUpdateOperationsInput | string
    affiliate_id?: IntFieldUpdateOperationsInput | number
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline_id?: NullableIntFieldUpdateOperationsInput | number | null
    instagram_scope_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrdersUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliatesUpdateOneWithoutOrdersNestedInput
    business?: BusinessUpdateOneWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrdersUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PipelinesUpdateWithoutProductsInput = {
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneWithoutPipelinesNestedInput
    affiliate_business?: Affiliate_BusinessUpdateManyWithoutPipelinesNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutPipelineNestedInput
  }

  export type PipelinesUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate_business?: Affiliate_BusinessUncheckedUpdateManyWithoutPipelinesNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type PipelinesUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    affiliate_count?: NullableIntFieldUpdateOperationsInput | number | null
    business_id?: NullableStringFieldUpdateOperationsInput | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    heygen_video_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    ig_post_url?: NullableStringFieldUpdateOperationsInput | string | null
    run_mode?: NullableEnumRunModeFieldUpdateOperationsInput | $Enums.RunMode | null
    workflow?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Affiliate_BusinessCreateManyPipelinesInput = {
    id?: string
    business_id: string
    affiliate_id: number
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    product_id?: number | null
    instagram_scope_identifier?: string | null
  }

  export type ChatMessageCreateManyPipelineInput = {
    id?: number
    sender: string
    receiver: string
    text: string
    chat_message_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type Affiliate_BusinessUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    ig_scope_identifier?: ig_scope_identifiersUpdateOneWithoutAffiliate_businessNestedInput
    affiliate?: AffiliatesUpdateOneRequiredWithoutAffiliate_businessNestedInput
    business?: BusinessUpdateOneRequiredWithoutAffiliate_businessNestedInput
    products?: ProductsUpdateOneWithoutAffiliate_businessNestedInput
  }

  export type Affiliate_BusinessUncheckedUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_id?: StringFieldUpdateOperationsInput | string
    affiliate_id?: IntFieldUpdateOperationsInput | number
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    instagram_scope_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Affiliate_BusinessUncheckedUpdateManyWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_id?: StringFieldUpdateOperationsInput | string
    affiliate_id?: IntFieldUpdateOperationsInput | number
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    instagram_scope_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatMessageUpdateWithoutPipelineInput = {
    sender?: StringFieldUpdateOperationsInput | string
    receiver?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    chat_message_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateWithoutPipelineInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender?: StringFieldUpdateOperationsInput | string
    receiver?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    chat_message_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutPipelineInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender?: StringFieldUpdateOperationsInput | string
    receiver?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    chat_message_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type embeddingsCreateManyResourcesInput = {
    id?: bigint | number
    created_at?: Date | string
    content?: string | null
  }

  export type embeddingsUpdateWithoutResourcesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type embeddingsUncheckedUpdateWithoutResourcesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type embeddingsUncheckedUpdateManyWithoutResourcesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Affiliate_BusinessCreateManyIg_scope_identifierInput = {
    id?: string
    business_id: string
    affiliate_id: number
    affiliate_link?: string | null
    affiliate_link_key?: string | null
    product_id?: number | null
    pipeline_id?: number | null
  }

  export type Affiliate_BusinessUpdateWithoutIg_scope_identifierInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: AffiliatesUpdateOneRequiredWithoutAffiliate_businessNestedInput
    business?: BusinessUpdateOneRequiredWithoutAffiliate_businessNestedInput
    products?: ProductsUpdateOneWithoutAffiliate_businessNestedInput
    pipelines?: PipelinesUpdateOneWithoutAffiliate_businessNestedInput
  }

  export type Affiliate_BusinessUncheckedUpdateWithoutIg_scope_identifierInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_id?: StringFieldUpdateOperationsInput | string
    affiliate_id?: IntFieldUpdateOperationsInput | number
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    pipeline_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Affiliate_BusinessUncheckedUpdateManyWithoutIg_scope_identifierInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_id?: StringFieldUpdateOperationsInput | string
    affiliate_id?: IntFieldUpdateOperationsInput | number
    affiliate_link?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_link_key?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    pipeline_id?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}